/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/MzY5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!********************!*\
  !*** ./app_ddi.js ***!
  \********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//////////\n// Globals\n\n// hostname default - the app will use it to obtain the variable metadata\n// (ddi) and pre-processed data info if the file id is supplied as an \n// argument (for ex., gui.html?dfId=17), but hostname isn't. \n// Edit it to suit your installation. \n// (NOTE that if the file id isn't supplied, the app will default to the \n// local files specified below!)\n// NEW: it is also possible now to supply complete urls for the ddi and \n// the tab-delimited data file; the parameters are ddiurl and dataurl. \n// These new parameters are optional. If they are not supplied, the app\n// will go the old route - will try to cook standard dataverse urls \n// for both the data and metadata, if the file id is supplied; or the \n// local files if nothing is supplied. \n// -- L.A.\n\n\nvar production = false;\nvar priv = false;\n\nif (production && fileid == \"\") {\n    alert(\"Error: No fileid has been provided.\");\n    throw new Error(\"Error: No fileid has been provided.\");\n}\n\nvar dataverseurl = \"\";\n\nif (hostname) {\n    dataverseurl = \"https://\" + hostname;\n} else {\n    if (production) {\n        dataverseurl = \"%PRODUCTION_DATAVERSE_URL%\";\n    } else {\n        dataverseurl = \"http://localhost:8080\";\n    }\n}\n\nif (fileid && !dataurl) {\n    // file id supplied; we are going to assume that we are dealing with\n    // a dataverse and cook a standard dataverse data access url,\n    // with the fileid supplied and the hostname we have\n    // either supplied or configured:\n    dataurl = dataverseurl + \"/api/access/datafile/\" + fileid;\n    dataurl = dataurl + \"?key=\" + apikey;\n    // (it is also possible to supply dataurl to the script directly, \n    // as an argument -- L.A.)\n}\n\nif (!production) {\n    // base URL for the R apps:\n    var rappURL = \"http://0.0.0.0:8000/custom/\";\n} else {\n    var rappURL = \"https://beta.dataverse.org/custom/\"; //this will change when/if the production host changes\n}\n\n// space index\nvar myspace = 0;\nvar svg = d3.select(\"#main.left div.carousel-inner\").attr('id', 'innercarousel').append('div').attr('class', 'item active').attr('id', 'm0').append('svg').attr('id', 'whitespace');\n\nvar logArray = [];\n\n//.attr('width', width)\n//.attr('height', height);\nvar tempWidth = d3.select(\"#main.left\").style(\"width\");\nvar width = tempWidth.substring(0, tempWidth.length - 2);\n\n/*var tempHeight = d3.select(\"#main.left\").style(\"height\")\nvar height = tempHeight.substring(0,(tempHeight.length-2));*/\n\nvar height = $(window).height() - 120; // Hard coding for header and footer and bottom margin.\n\n\nvar forcetoggle = [\"true\"];\nvar estimated = false;\nvar estimateLadda = Ladda.create(document.getElementById(\"btnEstimate\"));\nvar selectLadda = Ladda.create(document.getElementById(\"btnSelect\"));\nvar rightClickLast = false;\n\n// this is the initial color scale that is used to establish the initial colors of the nodes.  allNodes.push() below establishes a field for the master node array allNodes called \"nodeCol\" and assigns a color from this scale to that field.  everything there after should refer to the nodeCol and not the color scale, this enables us to update colors and pass the variable type to R based on its coloring\nvar colors = d3.scale.category20();\n\nvar colorTime = false;\nvar timeColor = '#2d6ca2';\n\nvar colorCS = false;\nvar csColor = '#419641';\n\nvar depVar = false;\nvar dvColor = '#28a4c9';\n\nvar nomColor = '#ff6600';\n\nvar subsetdiv = false;\nvar setxdiv = false;\n\nvar varColor = '#f0f8ff'; //d3.rgb(\"aliceblue\");\nvar selVarColor = '#fa8072'; //d3.rgb(\"salmon\");\nvar taggedColor = '#f5f5f5'; //d3.rgb(\"whitesmoke\");\nvar d3Color = '#1f77b4'; // d3's default blue\nvar grayColor = '#c0c0c0';\n\nvar lefttab = \"tab1\"; //global for current tab in left panel\nvar righttab = \"btnModels\"; // global for current tab in right panel\n\nvar zparams = { zdata: [], zedges: [], ztime: [], znom: [], zcross: [], zmodel: \"\", zvars: [], zdv: [], zdataurl: \"\", zsubset: [], zsetx: [], zmodelcount: 0, zplot: [], zsessionid: \"\", zdatacite: \"\" };\n\n// Radius of circle\nvar allR = 40;\n\n//Width and height for histgrams\nvar barwidth = 1.3 * allR;\nvar barheight = 0.5 * allR;\nvar barPadding = 0.35;\nvar barnumber = 7;\n\nvar arc0 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(0).endAngle(3.2);\n\nvar arc1 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(0).endAngle(1);\n\nvar arc2 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(1.1).endAngle(2.2);\n\nvar arc3 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(2.3).endAngle(3.3);\n\nvar arc4 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(4.3).endAngle(5.3);\n\n// From .csv\nvar dataset2 = [];\nvar valueKey = [];\nvar lablArray = [];\nvar hold = [];\nvar allNodes = [];\nvar allResults = [];\nvar subsetNodes = [];\nvar links = [];\nvar nodes = [];\nvar transformVar = \"\";\nvar summaryHold = false;\nvar selInteract = false;\nvar modelCount = 0;\nvar callHistory = []; // unique to the space. saves transform and subset calls.\nvar citetoggle = false;\n\n// transformation toolbar options\nvar transformList = [\"log(d)\", \"exp(d)\", \"d^2\", \"sqrt(d)\", \"interact(d,e)\"];\n\n// arry of objects containing allNode, zparams, transform vars\nvar spaces = [];\nvar trans = []; //var list for each space contain variables in original data plus trans in that space\n\n// end of (most) global declarations (minus functions)\n\n\n// collapsable user log\n$('#collapseLog').on('shown.bs.collapse', function () {\n    d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").data(logArray).enter().append(\"p\").text(function (d) {\n        return d;\n    });\n    //$(\"#logicon\").removeClass(\"glyphicon-chevron-up\").addClass(\"glyphicon-chevron-down\");\n});\n\n$('#collapseLog').on('hidden.bs.collapse', function () {\n    d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").remove();\n    //$(\"#logicon\").removeClass(\"glyphicon-chevron-down\").addClass(\"glyphicon-chevron-up\");\n});\n\n// text for the about box\n// note that .textContent is the new way to write text to a div\n$('#about div.panel-body').text('TwoRavens v0.1 \"Dallas\" -- The Norse god Odin had two talking ravens as advisors, who would fly out into the world and report back all they observed.  In the Norse, their names were \"Thought\" and \"Memory\".  In our coming release, our thought-raven automatically advises on statistical model selection, while our memory-raven accumulates previous statistical models from Dataverse, to provide cummulative guidance and meta-analysis.'); //This is the first public release of a new, interactive Web application to explore data, view descriptive statistics, and estimate statistical models.\";\n\n\n//\n// read DDI metadata with d3:\nvar metadataurl = \"\";\nif (ddiurl) {\n    // a complete ddiurl is supplied:\n    metadataurl = ddiurl;\n} else if (fileid) {\n    // file id supplied; we're going to cook a standard dataverse\n    // metadata url, with the file id provided and the hostname\n    // supplied or configured:\n    metadataurl = dataverseurl + \"/api/meta/datafile/\" + fileid;\n} else {\n    // neither a full ddi url, nor file id supplied; use one of the sample DDIs that come with\n    // the app, in the data directory:\n    // metadataurl=\"data/qog137.xml\"; // quality of government\n    //metadataurl=\"data/fearonLaitin.xml\"; // This is Fearon Laitin\n    metadataurl = \"data/PUMS5small-ddi.xml\"; // This is California PUMS subset\n    //metadataurl=\"data/BP.formatted-ddi.xml\";\n    //metadataurl=\"data/FL_insurance_sample-ddi.xml\";\n    //metadataurl=\"data/strezhnev_voeten_2013.xml\";   // This is Strezhnev Voeten\n    //metadataurl=\"data/19.xml\"; // Fearon from DVN Demo\n    //metadataurl=\"data/76.xml\"; // Collier from DVN Demo\n    //metadataurl=\"data/79.xml\"; // two vars from DVN Demo\n    //metadataurl=\"data/000.xml\"; // one var in metadata\n    //metadataurl=\"data/0000.xml\"; // zero vars in metadata\n}\n\n// Reading the pre-processed metadata:\n// Pre-processed data:\nvar pURL = \"\";\nif (dataurl) {\n    // data url is supplied\n    pURL = dataurl + \"&format=prep\";\n} else {\n    // no dataurl/file id supplied; use one of the sample data files distributed with the\n    // app in the \"data\" directory:\n    //pURL = \"data/preprocess2429360.txt\";   // This is the Strezhnev Voeten JSON data\n    // pURL = \"data/fearonLaitin.json\";     // This is the Fearon Laitin JSON data\n    //pURL = \"data/fearonLaitinNewPreprocess3long.json\";     // This is the revised (May 29, 2015) Fearon Laitin JSON data\n    pURL = \"data/preprocessPUMS5small.json\"; // This is California PUMS subset\n    //pURL = \"data/FL_insurance_sample.tab.json\";\n\n    // pURL = \"data/qog_pp.json\";   // This is Qual of Gov\n}\n\nvar preprocess = {};\nvar mods = new Object();\n\n// this is the function and callback routine that loads all external data: metadata (DVN's ddi), preprocessed (for plotting distributions), and zeligmodels (produced by Zelig) and initiates the data download to the server\nreadPreprocess(url = pURL, p = preprocess, v = null, callback = function (_callback) {\n    function callback() {\n        return _callback.apply(this, arguments);\n    }\n\n    callback.toString = function () {\n        return _callback.toString();\n    };\n\n    return callback;\n}(function () {\n    d3.xml(metadataurl, \"application/xml\", function (xml) {\n        var vars = xml.documentElement.getElementsByTagName(\"var\");\n        var temp = xml.documentElement.getElementsByTagName(\"fileName\");\n        zparams.zdata = temp[0].childNodes[0].nodeValue;\n\n        // function to clean the citation so that the POST is valid json\n        function cleanstring(s) {\n            s = s.replace(/\\&/g, \"and\");\n            s = s.replace(/\\;/g, \",\");\n            s = s.replace(/\\%/g, \"-\");\n            return s;\n        }\n\n        var cite = xml.documentElement.getElementsByTagName(\"biblCit\");\n        zparams.zdatacite = cite[0].childNodes[0].nodeValue;\n        zparams.zdatacite = cleanstring(zparams.zdatacite);\n\n        // dataset name trimmed to 12 chars\n        var dataname = zparams.zdata.replace(/\\.(.*)/, \"\"); // regular expression to drop any file extension\n        // Put dataset name, from meta-data, into top panel\n        d3.select(\"#dataName\").html(dataname);\n\n        $('#cite div.panel-body').text(zparams.zdatacite);\n\n        // Put dataset name, from meta-data, into page title\n        d3.select(\"title\").html(\"TwoRavens \" + dataname);\n        //d3.select(\"#title\").html(\"blah\");\n\n        // temporary values for hold that correspond to histogram bins\n        hold = [.6, .2, .9, .8, .1, .3, .4];\n        var myvalues = [0, 0, 0, 0, 0];\n        // console.log(\"GOT HERE A\");\n        // console.log(vars);\n        for (i = 0; i < vars.length; i++) {\n\n            valueKey[i] = vars[i].attributes.name.nodeValue;\n\n            if (vars[i].getElementsByTagName(\"labl\").length === 0) {\n                lablArray[i] = \"no label\";\n            } else {\n                lablArray[i] = vars[i].getElementsByTagName(\"labl\")[0].childNodes[0].nodeValue;\n            }\n\n            var datasetcount = d3.layout.histogram().bins(barnumber).frequency(false)(myvalues);\n\n            // this creates an object to be pushed to allNodes. this contains all the preprocessed data we have for the variable, as well as UI data pertinent to that variable, such as setx values (if the user has selected them) and pebble coordinates\n            var obj1 = { id: i, reflexive: false, \"name\": valueKey[i], \"labl\": lablArray[i], data: [5, 15, 20, 0, 5, 15, 20], count: hold, \"nodeCol\": colors(i), \"baseCol\": colors(i), \"strokeColor\": selVarColor, \"strokeWidth\": \"1\", \"subsetplot\": false, \"subsetrange\": [\"\", \"\"], \"setxplot\": false, \"setxvals\": [\"\", \"\"], \"grayout\": false };\n\n            jQuery.extend(true, obj1, preprocess[valueKey[i]]);\n\n            // console.log(vars[i].childNodes[4].attributes.type.ownerElement.firstChild.data);\n            allNodes.push(obj1);\n        };\n\n        // Reading the zelig models and populating the model list in the right panel.\n        d3.json(\"data/zelig5models.json\", function (error, json) {\n            if (error) return console.warn(error);\n            var jsondata = json;\n\n            console.log(\"zelig models json: \", jsondata);\n            for (var key in jsondata.zelig5models) {\n                if (jsondata.zelig5models.hasOwnProperty(key)) {\n                    mods[jsondata.zelig5models[key].name[0]] = jsondata.zelig5models[key].description[0];\n                }\n            }\n\n            d3.json(\"data/zelig5choicemodels.json\", function (error, json) {\n                if (error) return console.warn(error);\n                var jsondata = json;\n                console.log(\"zelig choice models json: \", jsondata);\n                for (var key in jsondata.zelig5choicemodels) {\n                    if (jsondata.zelig5choicemodels.hasOwnProperty(key)) {\n                        mods[jsondata.zelig5choicemodels[key].name[0]] = jsondata.zelig5choicemodels[key].description[0];\n                    }\n                }\n\n                scaffolding(callback = layout);\n                dataDownload();\n            });\n        });\n    });\n}));\n\n////////////////////////////////////////////\n// everything below this point is a function\n\n\n// scaffolding is called after all external data are guaranteed to have been read to completion. this populates the left panel with variable names, the right panel with model names, the transformation tool, an the associated mouseovers. its callback is layout(), which initializes the modeling space\nfunction scaffolding(callback) {\n\n    // establishing the transformation element\n    d3.select(\"#transformations\").append(\"input\").attr(\"id\", \"tInput\").attr(\"class\", \"form-control\").attr(\"type\", \"text\").attr(\"value\", \"Variable transformation\");\n\n    // the variable dropdown\n    d3.select(\"#transformations\").append(\"ul\").attr(\"id\", \"transSel\").style(\"display\", \"none\").style(\"background-color\", varColor).selectAll('li').data([\"a\", \"b\"]) //set to variables in model space as they're added\n    .enter().append(\"li\").text(function (d) {\n        return d;\n    });\n\n    // the function dropdown\n    d3.select(\"#transformations\").append(\"ul\").attr(\"id\", \"transList\").style(\"display\", \"none\").style(\"background-color\", varColor).selectAll('li').data(transformList).enter().append(\"li\").text(function (d) {\n        return d;\n    });\n\n    //jquery does this well\n    $('#tInput').click(function () {\n        var t = document.getElementById('transSel').style.display;\n        if (t !== \"none\") {\n            // if variable list is displayed when input is clicked...\n            $('#transSel').fadeOut(100);\n            return false;\n        }\n        var t1 = document.getElementById('transList').style.display;\n        if (t1 !== \"none\") {\n            // if function list is displayed when input is clicked...\n            $('#transList').fadeOut(100);\n            return false;\n        }\n\n        // highlight the text\n        $(this).select();\n\n        var pos = $('#tInput').offset();\n        pos.top += $('#tInput').width();\n        $('#transSel').fadeIn(100);\n        return false;\n    });\n\n    $('#tInput').keyup(function (event) {\n        var t = document.getElementById('transSel').style.display;\n        var t1 = document.getElementById('transList').style.display;\n\n        if (t !== \"none\") {\n            $('#transSel').fadeOut(100);\n        } else if (t1 !== \"none\") {\n            $('#transList').fadeOut(100);\n        }\n\n        if (event.keyCode == 13) {\n            // keyup on \"Enter\"\n            var n = $('#tInput').val();\n            var t = transParse(n = n);\n            if (t === null) {\n                return;\n            }\n            //        console.log(t);\n            //      console.log(t.slice(0, t.length-1));\n            //    console.log(t[t.length-1]);\n            transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n        }\n    });\n\n    $('#transList li').click(function (event) {\n        var tvar = $('#tInput').val();\n\n        // if interact is selected, show variable list again\n        if ($(this).text() === \"interact(d,e)\") {\n            $('#tInput').val(tvar.concat('*'));\n            selInteract = true;\n            $(this).parent().fadeOut(100);\n            $('#transSel').fadeIn(100);\n            event.stopPropagation();\n            return;\n        }\n\n        var tfunc = $(this).text().replace(\"d\", \"_transvar0\");\n        var tcall = $(this).text().replace(\"d\", tvar);\n        $('#tInput').val(tcall);\n        $(this).parent().fadeOut(100);\n        event.stopPropagation();\n        transform(n = tvar, t = tfunc, typeTransform = false);\n    });\n\n    // populating the variable list in the left panel\n    d3.select(\"#tab1\").selectAll(\"p\").data(valueKey).enter().append(\"p\").attr(\"id\", function (d) {\n        return d.replace(/\\W/g, \"_\"); // replace non-alphanumerics for selection purposes\n    }) // perhapse ensure this id is unique by adding '_' to the front?\n    .text(function (d) {\n        return d;\n    }).style('background-color', function (d) {\n        if (findNodeIndex(d) > 2) {\n            return varColor;\n        } else {\n            return hexToRgba(selVarColor);\n        }\n    }).attr(\"data-container\", \"body\").attr(\"data-toggle\", \"popover\").attr(\"data-trigger\", \"hover\").attr(\"data-placement\", \"right\").attr(\"data-html\", \"true\").attr(\"onmouseover\", \"$(this).popover('toggle');\").attr(\"onmouseout\", \"$(this).popover('toggle');\").attr(\"data-original-title\", \"Summary Statistics\");\n\n    d3.select(\"#models\").style('height', 2000).style('overfill', 'scroll');\n\n    var modellist = Object.keys(mods);\n\n    d3.select(\"#models\").selectAll(\"p\").data(modellist).enter().append(\"p\").attr(\"id\", function (d) {\n        return \"_model_\".concat(d);\n    }).text(function (d) {\n        return d;\n    }).style('background-color', function (d) {\n        return varColor;\n    }).attr(\"data-container\", \"body\").attr(\"data-toggle\", \"popover\").attr(\"data-trigger\", \"hover\").attr(\"data-placement\", \"top\").attr(\"data-html\", \"true\").attr(\"onmouseover\", \"$(this).popover('toggle');\").attr(\"onmouseout\", \"$(this).popover('toggle');\").attr(\"data-original-title\", \"Model Description\").attr(\"data-content\", function (d) {\n        return mods[d];\n    });\n\n    if (typeof callback === \"function\") {\n        callback(); // this calls layout() because at this point all scaffolding is up and ready\n    }\n}\n\nfunction layout(v) {\n    var myValues = [];\n    nodes = [];\n    links = [];\n\n    if (v === \"add\" | v === \"move\") {\n        d3.select(\"#tab1\").selectAll(\"p\").style('background-color', varColor);\n        for (var j = 0; j < zparams.zvars.length; j++) {\n            var ii = findNodeIndex(zparams.zvars[j]);\n            if (allNodes[ii].grayout) {\n                continue;\n            }\n            nodes.push(allNodes[ii]);\n            var selectMe = zparams.zvars[j].replace(/\\W/g, \"_\");\n            selectMe = \"#\".concat(selectMe);\n            d3.select(selectMe).style('background-color', function () {\n                return hexToRgba(nodes[j].strokeColor);\n            });\n        }\n\n        for (var j = 0; j < zparams.zedges.length; j++) {\n            var mysrc = nodeIndex(zparams.zedges[j][0]);\n            var mytgt = nodeIndex(zparams.zedges[j][1]);\n            links.push({ source: nodes[mysrc], target: nodes[mytgt], left: false, right: true });\n        }\n    } else {\n        if (allNodes.length > 2) {\n            nodes = [allNodes[0], allNodes[1], allNodes[2]];\n            links = [{ source: nodes[1], target: nodes[0], left: false, right: true }, { source: nodes[0], target: nodes[2], left: false, right: true }];\n        } else if (allNodes.length === 2) {\n            nodes = [allNodes[0], allNodes[1]];\n            links = [{ source: nodes[1], target: nodes[0], left: false, right: true }];\n        } else if (allNodes.length === 1) {\n            nodes = [allNodes[0]];\n        } else {\n            alert(\"There are zero variables in the metadata.\");\n            return;\n        }\n    }\n\n    panelPlots(); // after nodes is populated, add subset and setx panels\n    populatePopover(); // pipes in the summary stats shown on mouseovers\n\n\n    // init D3 force layout\n    var force = d3.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(150).charge(-800).on('tick', tick); // .start() is important to initialize the layout\n\n    // define arrow markers for graph links\n    svg.append('svg:defs').append('svg:marker').attr('id', 'end-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 6).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto').append('svg:path').attr('d', 'M0,-5L10,0L0,5').style('fill', '#000');\n\n    svg.append('svg:defs').append('svg:marker').attr('id', 'start-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 4).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto').append('svg:path').attr('d', 'M10,-5L0,0L10,5').style('fill', '#000');\n\n    // line displayed when dragging new nodes\n    var drag_line = svg.append('svg:path').attr('class', 'link dragline hidden').attr('d', 'M0,0L0,0');\n\n    // handles to link and node element groups\n    var path = svg.append('svg:g').selectAll('path'),\n        circle = svg.append('svg:g').selectAll('g');\n\n    // mouse event vars\n    var selected_node = null,\n        selected_link = null,\n        mousedown_link = null,\n        mousedown_node = null,\n        mouseup_node = null;\n\n    function resetMouseVars() {\n        mousedown_node = null;\n        mouseup_node = null;\n        mousedown_link = null;\n    }\n\n    // update force layout (called automatically each iteration)\n    function tick() {\n        // draw directed edges with proper padding from node centers\n        path.attr('d', function (d) {\n            var deltaX = d.target.x - d.source.x,\n                deltaY = d.target.y - d.source.y,\n                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n                normX = deltaX / dist,\n                normY = deltaY / dist,\n                sourcePadding = d.left ? allR + 5 : allR,\n                targetPadding = d.right ? allR + 5 : allR,\n                sourceX = d.source.x + sourcePadding * normX,\n                sourceY = d.source.y + sourcePadding * normY,\n                targetX = d.target.x - targetPadding * normX,\n                targetY = d.target.y - targetPadding * normY;\n            return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;\n        });\n\n        //  if(forcetoggle){\n        circle.attr('transform', function (d) {\n            return 'translate(' + d.x + ',' + d.y + ')';\n        });\n        //  };\n    }\n\n    //  add listeners to leftpanel.left.  every time a variable is clicked, nodes updates and background color changes.  mouseover shows summary stats or model description.\n    d3.select(\"#tab1\").selectAll(\"p\").on(\"mouseover\", function (d) {\n        // REMOVED THIS TOOLTIP CODE AND MADE A BOOTSTRAP POPOVER COMPONENT\n        $(\"body div.popover\").addClass(\"variables\");\n        $(\"body div.popover div.popover-content\").addClass(\"form-horizontal\");\n    }).on(\"mouseout\", function () {\n        //Remove the tooltip\n        //d3.select(\"#tooltip\").style(\"display\", \"none\");\n    }).on(\"click\", function varClick() {\n        if (allNodes[findNodeIndex(this.id)].grayout) {\n            return null;\n        }\n        d3.select(this).style('background-color', function (d) {\n            var myText = d3.select(this).text();\n            var myColor = d3.select(this).style('background-color');\n            var mySC = allNodes[findNodeIndex(myText)].strokeColor;\n\n            zparams.zvars = []; //empty the zvars array\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                // we are adding a var\n                if (nodes.length == 0) {\n                    nodes.push(findNode(myText));\n                    nodes[0].reflexive = true;\n                } else {\n                    nodes.push(findNode(myText));\n                }\n                return hexToRgba(selVarColor);\n            } else {\n                // dropping a variable\n\n                nodes.splice(findNode(myText)[\"index\"], 1);\n                spliceLinksForNode(findNode(myText));\n\n                if (mySC == dvColor) {\n                    var dvIndex = zparams.zdv.indexOf(myText);\n                    if (dvIndex > -1) {\n                        zparams.zdv.splice(dvIndex, 1);\n                    }\n                    //zparams.zdv=\"\";\n                } else if (mySC == csColor) {\n                    var csIndex = zparams.zcross.indexOf(myText);\n                    if (csIndex > -1) {\n                        zparams.zcross.splice(csIndex, 1);\n                    }\n                } else if (mySC == timeColor) {\n                    var timeIndex = zparams.ztime.indexOf(myText);\n                    if (timeIndex > -1) {\n                        zparams.ztime.splice(timeIndex, 1);\n                    }\n                } else if (mySC == nomColor) {\n                    var nomIndex = zparams.znom.indexOf(myText);\n                    if (nomIndex > -1) {\n                        zparams.znom.splice(dvIndex, 1);\n                    }\n                }\n\n                nodeReset(allNodes[findNodeIndex(myText)]);\n                borderState();\n                legend();\n                return varColor;\n            }\n        });\n        panelPlots();\n        restart();\n    });\n\n    d3.select(\"#models\").selectAll(\"p\") // models tab\n    .on(\"mouseover\", function (d) {\n        // REMOVED THIS TOOLTIP CODE AND MADE A BOOTSTRAP POPOVER COMPONENT\n    }).on(\"mouseout\", function () {\n        //Remove the tooltip\n        //d3.select(\"#tooltip\").style(\"display\", \"none\");\n    })\n    //  d3.select(\"#Display_content\")\n    .on(\"click\", function () {\n        var myColor = d3.select(this).style('background-color');\n        d3.select(\"#models\").selectAll(\"p\").style('background-color', varColor);\n        d3.select(this).style('background-color', function (d) {\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                zparams.zmodel = d.toString();\n                return hexToRgba(selVarColor);\n            } else {\n                zparams.zmodel = \"\";\n                return varColor;\n            }\n        });\n        restart();\n    });\n\n    // update graph (called when needed)\n    function restart() {\n        // nodes.id is pegged to allNodes, i.e. the order in which variables are read in\n        // nodes.index is floating and depends on updates to nodes.  a variables index changes when new variables are added.\n\n        circle.call(force.drag);\n        if (forcetoggle[0] === \"true\") {\n            force.gravity(0.1);\n            force.charge(-800);\n            force.linkStrength(1);\n            //  force.resume();\n\n            //  circle\n            //  .on('mousedown.drag', null)\n            //  .on('touchstart.drag', null);\n        } else {\n            force.gravity(0);\n            force.charge(0);\n            force.linkStrength(0);\n            //force.stop();\n            //  force.resume();\n        }\n        force.resume();\n\n        // path (link) group\n        path = path.data(links);\n\n        // update existing links\n        // VJD: dashed links between pebbles are \"selected\". this is disabled for now\n        path.classed('selected', function (d) {\n            return;\n        }) //return d === selected_link; })\n        .style('marker-start', function (d) {\n            return d.left ? 'url(#start-arrow)' : '';\n        }).style('marker-end', function (d) {\n            return d.right ? 'url(#end-arrow)' : '';\n        });\n\n        // add new links\n        path.enter().append('svg:path').attr('class', 'link').classed('selected', function (d) {\n            return;\n        }) //return d === selected_link; })\n        .style('marker-start', function (d) {\n            return d.left ? 'url(#start-arrow)' : '';\n        }).style('marker-end', function (d) {\n            return d.right ? 'url(#end-arrow)' : '';\n        }).on('mousedown', function (d) {\n            // do we ever need to select a link? make it delete..\n            var obj1 = JSON.stringify(d);\n            for (var j = 0; j < links.length; j++) {\n                if (obj1 === JSON.stringify(links[j])) {\n                    links.splice(j, 1);\n                }\n            }\n        });\n\n        // remove old links\n        path.exit().remove();\n\n        // circle (node) group\n        circle = circle.data(nodes, function (d) {\n            return d.id;\n        });\n\n        // update existing nodes (reflexive & selected visual states)\n        //d3.rgb is the function adjusting the color here.\n        circle.selectAll('circle').classed('reflexive', function (d) {\n            return d.reflexive;\n        }).style('fill', function (d) {\n            return d3.rgb(d.nodeCol);\n            //return (d === selected_node) ? d3.rgb(d.nodeCol).brighter() : d3.rgb(d.nodeCol); // IF d is equal to selected_node return brighter color ELSE return normal color\n        }).style('stroke', function (d) {\n            return d3.rgb(d.strokeColor);\n        }).style('stroke-width', function (d) {\n            return d.strokeWidth;\n        });\n\n        // add new nodes\n\n        var g = circle.enter().append('svg:g').attr(\"id\", function (d) {\n            var myname = d.name + \"biggroup\";\n            return myname;\n        });\n\n        // add plot\n        g.each(function (d) {\n            d3.select(this);\n            if (d.plottype === \"continuous\") {\n                densityNode(d, obj = this);\n            } else if (d.plottype === \"bar\") {\n                barsNode(d, obj = this);\n            }\n        });\n\n        // add arc tags\n        // NOTE: this block of code has been commented out to remove the \"cross section\" and \"time series\" arc tags. These tags are functioning as intended, but they do not, at present, do anything to change the statistical model or variables. To avoid confusion when using TwoRavens, they have been dropped. To add them back in, simply uncomment the block below.\n        /*\n        g.append(\"path\")\n        .attr(\"d\", arc1)\n        .attr(\"id\", function(d){\n              return \"timeArc\".concat(d.id);\n              })\n        .style(\"fill\", \"yellow\")\n        .attr(\"fill-opacity\", 0)\n        .on('mouseover', function(d){\n            d3.select(this).transition()  .attr(\"fill-opacity\", .3)\n            .delay(0)\n            .duration(100);   //.attr('transform', 'scale(2)');\n            d3.select(\"#timeText\".concat(d.id)).transition()\n            .attr(\"fill-opacity\", .9)\n            .delay(0)\n            .duration(100);\n            })\n        .on('mouseout', function(d){\n            d3.select(this).transition()\n            .attr(\"fill-opacity\", 0)\n            .delay(100)\n            .duration(500);\n            d3.select(\"#timeText\".concat(d.id)).transition()\n            .attr(\"fill-opacity\", 0)\n            .delay(100)\n            .duration(500);\n            })\n        .on('click', function(d){\n            setColors(d, timeColor);\n            legend(timeColor);\n            restart();\n            });\n        g.append(\"text\")\n        .attr(\"id\", function(d){\n              return \"timeText\".concat(d.id);\n              })\n        .attr(\"x\", 6)\n        .attr(\"dy\", 11.5)\n        .attr(\"fill-opacity\", 0)\n        .append(\"textPath\")\n        .attr(\"xlink:href\", function(d){\n              return \"#timeArc\".concat(d.id);\n              })\n        .text(\"Time\");\n        \n         \n        g.append(\"path\")\n        .attr(\"id\", function(d){\n              return \"csArc\".concat(d.id);\n              })\n        .attr(\"d\", arc2)\n        .style(\"fill\", csColor)\n        .attr(\"fill-opacity\", 0)\n        .on('mouseover', function(d){\n            d3.select(this).transition()\n            .attr(\"fill-opacity\", .3)\n            .delay(0)\n            .duration(100);\n            d3.select(\"#csText\".concat(d.id)).transition()\n            .attr(\"fill-opacity\", .9)\n            .delay(0)\n            .duration(100);\n            })\n        .on('mouseout', function(d){\n            d3.select(this).transition()\n            .attr(\"fill-opacity\", 0)\n            .delay(100)\n            .duration(500);\n            d3.select(\"#csText\".concat(d.id)).transition()\n            .attr(\"fill-opacity\", 0)\n            .delay(100)\n            .duration(500);\n            })\n        .on('click', function(d){\n            setColors(d, csColor);\n            legend(csColor);\n            restart();\n            });\n        g.append(\"text\")\n        .attr(\"id\", function(d){\n              return \"csText\".concat(d.id);\n              })\n        .attr(\"x\", 6)\n        .attr(\"dy\", 11.5)\n        .attr(\"fill-opacity\", 0)\n        .append(\"textPath\")\n        .attr(\"xlink:href\", function(d){\n              return \"#csArc\".concat(d.id);\n              })\n        .text(\"Cross Sec\");\n        */\n\n        g.append(\"path\").attr(\"id\", function (d) {\n            return \"dvArc\".concat(d.id);\n        }).attr(\"d\", arc3).style(\"fill\", dvColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            d3.select(this).transition().attr(\"fill-opacity\", .3).delay(0).duration(100);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", .9).delay(0).duration(100);\n        }).on('mouseout', function (d) {\n            d3.select(this).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n        }).on('click', function (d) {\n            setColors(d, dvColor);\n            legend(dvColor);\n            restart();\n        });\n        g.append(\"text\").attr(\"id\", function (d) {\n            return \"dvText\".concat(d.id);\n        }).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", function (d) {\n            return \"#dvArc\".concat(d.id);\n        }).text(\"Dep Var\");\n\n        g.append(\"path\").attr(\"id\", function (d) {\n            return \"nomArc\".concat(d.id);\n        }).attr(\"d\", arc4).style(\"fill\", nomColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            if (d.defaultNumchar == \"character\") {\n                return;\n            }\n            d3.select(this).transition().attr(\"fill-opacity\", .3).delay(0).duration(100);\n            d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", .9).delay(0).duration(100);\n        }).on('mouseout', function (d) {\n            if (d.defaultNumchar == \"character\") {\n                return;\n            }\n            d3.select(this).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n        }).on('click', function (d) {\n            if (d.defaultNumchar == \"character\") {\n                return;\n            }\n            setColors(d, nomColor);\n            legend(nomColor);\n            restart();\n        });\n        g.append(\"text\").attr(\"id\", function (d) {\n            return \"nomText\".concat(d.id);\n        }).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", function (d) {\n            return \"#nomArc\".concat(d.id);\n        }).text(\"Nominal\");\n\n        g.append('svg:circle').attr('class', 'node').attr('r', allR).style('pointer-events', 'inherit').style('fill', function (d) {\n            //      return (d === selected_node) ? d3.rgb(d.nodeCol).brighter().toString() : d.nodeCol; })\n            return d.nodeCol;\n        }).style('opacity', \"0.5\").style('stroke', function (d) {\n            return d3.rgb(d.strokeColor).toString();\n        }).classed('reflexive', function (d) {\n            return d.reflexive;\n        }).on('mouseover', function (d) {\n            //     if(!mousedown_node || d === mousedown_node) return;\n        }).on('mouseout', function (d) {\n            //    if(!mousedown_node || d === mousedown_node) return;\n            // unenlarge target node\n            //tooltip.style(\"visibility\", \"hidden\");\n            //    d3.select(this).attr('transform', '');\n        })\n        //      .on('mousedown', function(d) {\n        //         })\n        .on('dblclick', function (d) {\n            d3.event.stopPropagation(); // stop click from bubbling\n            summaryHold = true;\n            //            document.getElementById('transformations').setAttribute(\"style\", \"display:block\");\n        }).on('contextmenu', function (d) {\n            // right click on node\n            d3.event.preventDefault();\n            d3.event.stopPropagation(); // stop right click from bubbling\n            rightClickLast = true;\n\n            mousedown_node = d;\n            if (mousedown_node === selected_node) selected_node = null;else selected_node = mousedown_node;\n            selected_link = null;\n\n            // reposition drag line\n            drag_line.style('marker-end', 'url(#end-arrow)').classed('hidden', false).attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + mousedown_node.x + ',' + mousedown_node.y);\n\n            svg.on('mousemove', mousemove);\n            restart();\n        }).on('mouseup', function (d) {\n            d3.event.stopPropagation(); // stop mouseup from bubbling\n\n            if (rightClickLast) {\n                rightClickLast = false;\n                return;\n            }\n\n            if (!mousedown_node) return;\n\n            // needed by FF\n            drag_line.classed('hidden', true).style('marker-end', '');\n\n            // check for drag-to-self\n            mouseup_node = d;\n            if (mouseup_node === mousedown_node) {\n                resetMouseVars();return;\n            }\n\n            // unenlarge target node\n            d3.select(this).attr('transform', '');\n\n            // add link to graph (update if exists)\n            // NB: links are strictly source < target; arrows separately specified by booleans\n            var source, target, direction;\n            if (mousedown_node.id < mouseup_node.id) {\n                source = mousedown_node;\n                target = mouseup_node;\n                direction = 'right';\n            } else {\n                source = mouseup_node;\n                target = mousedown_node;\n                direction = 'left';\n            }\n\n            var link;\n            link = links.filter(function (l) {\n                return l.source === source && l.target === target;\n            })[0];\n            if (link) {\n                link[direction] = true;\n            } else {\n                link = { source: source, target: target, left: false, right: false };\n                link[direction] = true;\n                links.push(link);\n            }\n\n            // select new link\n            selected_link = link;\n            selected_node = null;\n            svg.on('mousemove', null);\n\n            resetMouseVars();\n            restart();\n        });\n\n        // show node Names\n        g.append('svg:text').attr('x', 0).attr('y', 15).attr('class', 'id').text(function (d) {\n            return d.name;\n        });\n\n        // show summary stats on mouseover\n        // SVG doesn't support text wrapping, use html instead\n        g.selectAll(\"circle.node\").on(\"mouseover\", function (d) {\n            tabLeft(\"tab3\");\n            varSummary(d);\n            document.getElementById('transformations').setAttribute(\"style\", \"display:block\");\n            var select = document.getElementById(\"transSel\");\n            select.selectedIndex = d.id;\n            transformVar = valueKey[d.id];\n\n            d3.select(\"#dvArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n            if (d.defaultNumchar == \"numeric\") {\n                d3.select(\"#nomArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n                d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n            }\n            d3.select(\"#csArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n            d3.select(\"#csText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n            d3.select(\"#timeArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n            d3.select(\"#timeText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n        })\n        // popup(d, xPos, yPos);\n\n        .on(\"mouseout\", function (d) {\n            if (summaryHold === false) {\n                tabLeft(lefttab);\n            }\n\n            d3.select(\"#csArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#csText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#timeArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#timeText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#dvArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#nomArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n        });\n\n        // populating transformation dropdown\n        var t = [];\n        for (var j = 0; j < nodes.length; j++) {\n            t.push(nodes[j].name);\n        }\n\n        // the transformation variable list is silently updated as pebbles are added/removed\n        d3.select(\"#transSel\").selectAll('li').remove();\n\n        d3.select(\"#transSel\").selectAll('li').data(t) //set to variables in model space as they're added\n        .enter().append(\"li\").text(function (d) {\n            return d;\n        });\n\n        $('#transSel li').click(function (event) {\n\n            // if 'interaction' is the selected function, don't show the function list again\n            if (selInteract === true) {\n                var n = $('#tInput').val().concat($(this).text());\n                $('#tInput').val(n);\n                event.stopPropagation();\n                var t = transParse(n = n);\n                if (t === null) {\n                    return;\n                }\n                $(this).parent().fadeOut(100);\n                transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n                return;\n            }\n\n            $('#tInput').val($(this).text());\n            $(this).parent().fadeOut(100);\n            $('#transList').fadeIn(100);\n            event.stopPropagation();\n        });\n\n        // remove old nodes\n        circle.exit().remove();\n        force.start();\n    } //end restart function\n\n\n    function mousedown(d) {\n        // prevent I-bar on drag\n        d3.event.preventDefault();\n\n        // because :active only works in WebKit?\n        svg.classed('active', true);\n\n        if (d3.event.ctrlKey || mousedown_node || mousedown_link) {\n            return;\n        }\n\n        restart();\n    }\n\n    function mousemove(d) {\n        if (!mousedown_node) return;\n\n        // update drag line\n        drag_line.attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + d3.mouse(this)[0] + ',' + d3.mouse(this)[1]);\n    }\n\n    function mouseup(d) {\n        if (mousedown_node) {\n            // hide drag line\n            drag_line.classed('hidden', true).style('marker-end', '');\n        }\n        // because :active only works in WebKit?\n        svg.classed('active', false);\n\n        // clear mouse event vars\n        resetMouseVars();\n    }\n\n    // app starts here\n\n    svg.attr('id', function () {\n        return \"whitespace\".concat(myspace);\n    }).attr('height', height).on('mousedown', function () {\n        mousedown(this);\n    }).on('mouseup', function () {\n        mouseup(this);\n    });\n\n    d3.select(window).on('click', function () {\n        //NOTE: all clicks will bubble here unless event.stopPropagation()\n        $('#transList').fadeOut(100);\n        $('#transSel').fadeOut(100);\n    });\n\n    restart(); // this is the call the restart that initializes the force.layout()\n    fakeClick();\n} // end layout\n\n\n// returns id\nvar findNodeIndex = function findNodeIndex(nodeName) {\n    for (var i in allNodes) {\n        if (allNodes[i][\"name\"] === nodeName) {\n            return allNodes[i][\"id\"];\n        }\n    };\n};\n\nvar nodeIndex = function nodeIndex(nodeName) {\n    for (var i in nodes) {\n        if (nodes[i][\"name\"] === nodeName) {\n            return i;\n        }\n    }\n};\n\nvar findNode = function findNode(nodeName) {\n    for (var i in allNodes) {\n        if (allNodes[i][\"name\"] === nodeName) return allNodes[i];\n    };\n};\n\n// function called by force button\nfunction forceSwitch() {\n    if (forcetoggle[0] === \"true\") {\n        forcetoggle = [\"false\"];\n    } else {\n        forcetoggle = [\"true\"];\n    }\n\n    if (forcetoggle[0] === \"false\") {\n        document.getElementById('btnForce').setAttribute(\"class\", \"btn active\");\n    } else {\n        document.getElementById('btnForce').setAttribute(\"class\", \"btn btn-default\");\n        fakeClick();\n    }\n}\n\nfunction spliceLinksForNode(node) {\n    var toSplice = links.filter(function (l) {\n        return l.source === node || l.target === node;\n    });\n    toSplice.map(function (l) {\n        links.splice(links.indexOf(l), 1);\n    });\n}\n\nfunction zPop() {\n    if (dataurl) {\n        zparams.zdataurl = dataurl;\n    }\n\n    zparams.zmodelcount = modelCount;\n\n    zparams.zedges = [];\n    zparams.zvars = [];\n\n    for (var j = 0; j < nodes.length; j++) {\n        //populate zvars array\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n        //var temp = findNodeIndex(nodes[j].name);\n        //console.log(\"node \",nodes[j].id);\n        //console.log(\"temp \", temp);\n\n        zparams.zsetx[j] = allNodes[temp].setxvals;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n    }\n\n    for (var j = 0; j < links.length; j++) {\n        //populate zedges array\n        var srctgt = [];\n        //correct the source target ordering for Zelig\n        if (links[j].left === false) {\n            srctgt = [links[j].source.name, links[j].target.name];\n        } else {\n            srctgt = [links[j].target.name, links[j].source.name];\n        }\n        zparams.zedges.push(srctgt);\n    }\n}\n\nfunction estimate(btn) {\n\n    if (production && zparams.zsessionid == \"\") {\n        alert(\"Warning: Data download is not complete. Try again soon.\");\n        return;\n    }\n\n    zPop();\n    // write links to file & run R CMD\n\n    //package the output as JSON\n    // add call history and package the zparams object as JSON\n    zparams.callHistory = callHistory;\n    var jsonout = JSON.stringify(zparams);\n\n    //var base = rappURL+\"zeligapp?solaJSON=\"\n    urlcall = rappURL + \"zeligapp\"; //base.concat(jsonout);\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    zparams.allVars = valueKey.slice(10, 25); // this is because the URL is too long...\n    var jsonout = JSON.stringify(zparams);\n    //var selectorBase = rappURL+\"selectorapp?solaJSON=\";\n    var selectorurlcall = rappURL + \"selectorapp\"; //.concat(jsonout);\n\n    function estimateSuccess(btn, json) {\n        estimateLadda.stop(); // stop spinner\n        allResults.push(json);\n        console.log(allResults);\n        console.log(\"json in: \", json);\n\n        var myparent = document.getElementById(\"results\");\n        if (estimated == false) {\n            myparent.removeChild(document.getElementById(\"resultsHolder\"));\n        }\n\n        estimated = true;\n        d3.select(\"#results\").style(\"display\", \"block\");\n\n        d3.select(\"#resultsView\").style(\"display\", \"block\");\n\n        d3.select(\"#modelView\").style(\"display\", \"block\");\n\n        // programmatic click on Results button\n        $(\"#btnResults\").trigger(\"click\");\n\n        modelCount = modelCount + 1;\n        var model = \"Model\".concat(modelCount);\n\n        function modCol() {\n            d3.select(\"#modelView\").selectAll(\"p\").style('background-color', hexToRgba(varColor));\n        }\n\n        modCol();\n\n        d3.select(\"#modelView\").insert(\"p\", \":first-child\") // top stack for results\n        .attr(\"id\", model).text(model).style('background-color', hexToRgba(selVarColor)).on(\"click\", function () {\n            var a = this.style.backgroundColor.replace(/\\s*/g, \"\");\n            var b = hexToRgba(selVarColor).replace(/\\s*/g, \"\");\n            if (a.substr(0, 17) === b.substr(0, 17)) {\n                return; //escapes the function early if the displayed model is clicked\n            }\n            modCol();\n            d3.select(this).style('background-color', hexToRgba(selVarColor));\n            viz(this.id);\n        });\n\n        var rCall = [];\n        rCall[0] = json.call;\n        logArray.push(\"estimate: \".concat(rCall[0]));\n        showLog();\n\n        viz(model);\n    }\n\n    function estimateFail(btn) {\n        estimateLadda.stop(); // stop spinner\n        estimated = true;\n    }\n\n    function selectorSuccess(btn, json) {\n        d3.select(\"#ticker\").text(\"Suggested variables and percent improvement on RMSE: \" + json.vars);\n        console.log(\"selectorSuccess: \", json);\n    }\n\n    function selectorFail(btn) {\n        alert(\"Selector Fail\");\n    }\n\n    estimateLadda.start(); // start spinner\n    makeCorsRequest(urlcall, btn, estimateSuccess, estimateFail, solajsonout);\n    //makeCorsRequest(selectorurlcall, btn, selectorSuccess, selectorFail, solajsonout);\n\n}\n\nfunction dataDownload() {\n    zPop();\n    // write links to file & run R CMD\n\n    //package the output as JSON\n    // add call history and package the zparams object as JSON\n    var jsonout = JSON.stringify(zparams);\n    var btn = \"nobutton\";\n\n    //var base = rappURL+\"zeligapp?solaJSON=\"\n    urlcall = rappURL + \"dataapp\"; //base.concat(jsonout);\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    function downloadSuccess(btn, json) {\n        console.log(\"dataDownload json in: \", json);\n        zparams.zsessionid = json.sessionid[0];\n\n        // set the link URL\n        if (production) {\n            var logURL = rappURL + \"log_dir/log_\" + zparams.zsessionid + \".txt\";\n            document.getElementById(\"logID\").href = logURL;\n        } else {\n            var logURL = \"rook/log_\" + zparams.zsessionid + \".txt\";\n            document.getElementById(\"logID\").href = logURL;\n        }\n    }\n\n    function downloadFail(btn) {\n        console.log(\"Data have not been downloaded\");\n    }\n\n    makeCorsRequest(urlcall, btn, downloadSuccess, downloadFail, solajsonout);\n}\n\nfunction viz(m) {\n    var mym = +m.substr(5, 5) - 1;\n\n    function removeKids(parent) {\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n    }\n\n    var myparent = document.getElementById(\"resultsView\");\n    removeKids(myparent);\n\n    var json = allResults[mym];\n\n    // pipe in figures to right panel\n    var filelist = new Array();\n    for (var i in json.images) {\n        var zfig = document.createElement(\"img\");\n        zfig.setAttribute(\"src\", json.images[i]);\n        zfig.setAttribute('width', 200);\n        zfig.setAttribute('height', 200);\n        document.getElementById(\"resultsView\").appendChild(zfig);\n    }\n\n    // var rCall = [];\n    // rCall[0] = json.call;\n    // logArray.push(\"estimate: \".concat(rCall[0]));\n    // showLog();\n\n\n    // write the results table\n    var resultsArray = [];\n    for (var key in json.sumInfo) {\n        if (key == \"colnames\") {\n            continue;\n        }\n\n        var obj = json.sumInfo[key];\n        resultsArray.push(obj);\n        /* SO says this is important check, but I don't see how it helps here...\n         for (var prop in obj) {\n         // important check that this is objects own property\n         // not from prototype prop inherited\n         if(obj.hasOwnProperty(prop)){\n         alert(prop + \" = \" + obj[prop]);\n         }\n         }  */\n    }\n\n    var table = d3.select(\"#resultsView\").append(\"p\")\n    //    .html(\"<center><b>Results</b></center>\")\n    .append(\"table\");\n\n    var thead = table.append(\"thead\");\n    thead.append(\"tr\").selectAll(\"th\").data(json.sumInfo.colnames).enter().append(\"th\").text(function (d) {\n        return d;\n    });\n\n    var tbody = table.append(\"tbody\");\n    tbody.selectAll(\"tr\").data(resultsArray).enter().append(\"tr\").selectAll(\"td\").data(function (d) {\n        return d;\n    }).enter().append(\"td\").text(function (d) {\n        var myNum = Number(d);\n        if (isNaN(myNum)) {\n            return d;\n        }\n        return myNum.toPrecision(3);\n    }).on(\"mouseover\", function () {\n        d3.select(this).style(\"background-color\", \"aliceblue\");\n    }) // for no discernable reason\n    .on(\"mouseout\", function () {\n        d3.select(this).style(\"background-color\", \"#F9F9F9\");\n    }); //(but maybe we'll think of one)\n\n    d3.select(\"#resultsView\").append(\"p\").html(function () {\n        return \"<b>Formula: </b>\".concat(json.call[0]);\n    });\n}\n\n// this function parses the transformation input. variable names are often nested inside one another, e.g., ethwar, war, wars, and so this is handled\nfunction transParse(n) {\n\n    var out2 = [];\n    var t2 = n;\n    var k2 = 0;\n    var subMe2 = \"_transvar\".concat(k2);\n    var indexed = [];\n\n    // out2 is all matched variables, indexed is an array, each element is an object that contains the matched variables starting index and finishing index.  e.g., n=\"wars+2\", out2=[war, wars], indexed=[{0,2},{0,3}]\n    for (var i in valueKey) {\n        var m2 = n.match(valueKey[i]);\n        if (m2 !== null) {\n            out2.push(m2[0]);\n        }\n\n        var re = new RegExp(valueKey[i], \"g\");\n        var s = n.search(re);\n        if (s != -1) {\n            indexed.push({ from: s, to: s + valueKey[i].length });\n        }\n    }\n\n    // nested loop not good, but indexed is not likely to be very large.\n    // if a variable is nested, it is removed from out2\n    // notice, loop is backwards so that index changes don't affect the splice\n    console.log(\"indexed \", indexed);\n    for (var i = indexed.length - 1; i > -1; i--) {\n        for (var j = indexed.length - 1; j > -1; j--) {\n            if (i === j) {\n                continue;\n            }\n            if (indexed[i].from >= indexed[j].from & indexed[i].to <= indexed[j].to) {\n                console.log(i, \" is nested in \", j);\n                out2.splice(i, 1);\n            }\n        }\n    }\n\n    for (var i in out2) {\n        t2 = t2.replace(out2[i], subMe2); //something that'll never be a variable name\n        k2 = k2 + 1;\n        subMe2 = \"_transvar\".concat(k2);\n    }\n\n    if (out2.length > 0) {\n        out2.push(t2);\n        console.log(\"new out \", out2);\n        return out2;\n    } else {\n        alert(\"No variable name found. Perhaps check your spelling?\");\n        return null;\n    }\n}\n\nfunction transform(n, t, typeTransform) {\n\n    if (production && zparams.zsessionid == \"\") {\n        alert(\"Warning: Data download is not complete. Try again soon.\");\n        return;\n    }\n\n    if (!typeTransform) {\n        t = t.replace(\"+\", \"_plus_\"); // can't send the plus operator\n    }\n\n    console.log(n);\n    console.log(t);\n\n    var btn = document.getElementById('btnEstimate');\n\n    var myn = allNodes[findNodeIndex(n[0])];\n    if (typeof myn === \"undefined\") {\n        var myn = allNodes[findNodeIndex(n)];\n    }\n\n    var outtypes = { varnamesTypes: n, interval: myn.interval, numchar: myn.numchar, nature: myn.nature, binary: myn.binary };\n\n    console.log(myn);\n    // if typeTransform but we already have the metadata\n    if (typeTransform) {\n        if (myn.nature == \"nominal\" & typeof myn.plotvalues !== \"undefined\") {\n            myn.plottype = \"bar\";\n            barsNode(myn);\n            populatePopover();\n            panelPlots();\n            return;\n        } else if (myn.nature != \"nominal\" & typeof myn.plotx !== \"undefined\") {\n            myn.plottype = \"continuous\";\n            densityNode(myn);\n            populatePopover();\n            panelPlots();\n            return;\n        }\n    }\n\n    //package the output as JSON\n    var transformstuff = { zdataurl: dataurl, zvars: n, zsessionid: zparams.zsessionid, transform: t, callHistory: callHistory, typeTransform: typeTransform, typeStuff: outtypes };\n    var jsonout = JSON.stringify(transformstuff);\n    //var base = rappURL+\"transformapp?solaJSON=\"\n\n    urlcall = rappURL + \"transformapp\"; //base.concat(jsonout);\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    function transformSuccess(btn, json) {\n        estimateLadda.stop();\n        console.log(\"json in: \", json);\n\n        if (json.typeTransform[0]) {\n\n            d3.json(json.url, function (error, json) {\n                if (error) return console.warn(error);\n                var jsondata = json;\n\n                for (var key in jsondata) {\n                    var myIndex = findNodeIndex(key);\n                    jQuery.extend(true, allNodes[myIndex], jsondata[key]);\n\n                    if (allNodes[myIndex].plottype === \"continuous\") {\n                        densityNode(allNodes[myIndex]);\n                    } else if (allNodes[myIndex].plottype === \"bar\") {\n                        barsNode(allNodes[myIndex]);\n                    }\n                }\n\n                fakeClick();\n                populatePopover();\n                panelPlots();\n                console.log(allNodes[myIndex]);\n            });\n        } else {\n\n            callHistory.push({ func: \"transform\", zvars: n, transform: t });\n\n            var subseted = false;\n            var rCall = [];\n            rCall[0] = json.call;\n            var newVar = rCall[0][0];\n            trans.push(newVar);\n\n            d3.json(json.url, function (error, json) {\n                if (error) return console.warn(error);\n                var jsondata = json;\n\n                for (var key in jsondata) {\n                    var myIndex = findNodeIndex(key);\n                    if (typeof myIndex !== \"undefined\") {\n                        alert(\"Invalid transformation: this variable name already exists.\");\n                        return;\n                    }\n                    // add transformed variable to the current space\n                    var i = allNodes.length;\n                    var obj1 = { id: i, reflexive: false, \"name\": key, \"labl\": \"transformlabel\", data: [5, 15, 20, 0, 5, 15, 20], count: [.6, .2, .9, .8, .1, .3, .4], \"nodeCol\": colors(i), \"baseCol\": colors(i), \"strokeColor\": selVarColor, \"strokeWidth\": \"1\", \"subsetplot\": false, \"subsetrange\": [\"\", \"\"], \"setxplot\": false, \"setxvals\": [\"\", \"\"], \"grayout\": false, \"defaultInterval\": jsondata[key][\"interval\"], \"defaultNumchar\": jsondata[key][\"numchar\"], \"defaultNature\": jsondata[key][\"nature\"], \"defaultBinary\": jsondata[key][\"binary\"] };\n\n                    jQuery.extend(true, obj1, jsondata[key]);\n                    allNodes.push(obj1);\n\n                    scaffoldingPush(rCall[0]);\n                    valueKey.push(newVar);\n                    nodes.push(allNodes[i]);\n                    fakeClick();\n                    panelPlots();\n\n                    if (allNodes[i].plottype === \"continuous\") {\n                        densityNode(allNodes[i]);\n                    } else if (allNodes[i].plottype === \"bar\") {\n                        barsNode(allNodes[i]);\n                    }\n                } //for\n\n            });\n\n            // update the log\n            logArray.push(\"transform: \".concat(rCall[0]));\n            showLog();\n\n            /*\n                    // NOTE: below is the carousel portion that needs to be revised as of May 29 2015\n            \n            // add transformed variable to all spaces\n            // check if myspace callHistory contains a subset\n            for(var k0=0; k0<callHistory.length; k0++) {\n                if(callHistory[k0].func===\"subset\") {\n                    var subseted = true;\n                }\n            }\n                 loopJ:\n            for(var j in spaces) {\n                if(j===myspace) {continue;}\n                var i = spaces[j].allNodes.length;\n                if(subseted===true) { // myspace has been subseted\n                    offspaceTransform(j);\n                    continue loopJ;\n                }\n            loopK:\n                for(var k=0; k<spaces[j].callHistory.length; k++) { // gets here if myspace has not been subseted\n                    if(spaces[j].callHistory[k].func===\"subset\") { // check if space j has been subseted\n                        offspaceTransform(j);\n                        continue loopJ;\n                    }\n                }\n                // if there is a subset in the callHistory of the current space, transformation is different\n                function offspaceTransform(j) {\n                    transformstuff = {zdataurl:dataurl, zvars:n, zsessionid:zparams.zsessionid, transform:t, callHistory:spaces[j].callHistory};\n                    var jsonout = JSON.stringify(transformstuff);\n                    //var base = rappURL+\"transformapp?solaJSON=\"\n                    urlcall = rappURL+\"transformapp\"; //base.concat(jsonout);\n                    var solajsonout = \"solaJSON=\"+jsonout;\n                    console.log(\"urlcall out: \", urlcall);\n                    console.log(\"POST out: \", solajsonout);\n                 \n                    function offspaceSuccess(btn, json) {\n                        spaces[j].callHistory.push({func:\"transform\", zvars:n, transform:t});\n                        spaces[j].logArray.push(\"transform: \".concat(rCall[0]));\n                        readPreprocess(json.url, p=spaces[j].preprocess, v=newVar, callback=null);\n                    \n                        spaces[j].allNodes.push({id:i, reflexive: false, \"name\": rCall[0][0], \"labl\": \"transformlabel\", data: [5,15,20,0,5,15,20], count: hold, \"nodeCol\":colors(i), \"baseCol\":colors(i), \"strokeColor\":selVarColor, \"strokeWidth\":\"1\", \"interval\":json.types.interval[0], \"numchar\":json.types.numchar[0], \"nature\":json.types.nature[0], \"binary\":json.types.binary[0], \"defaultInterval\":json.types.interval[0], \"defaultNumchar\":json.types.numchar[0], \"defaultNature\":json.types.nature[0], \"defaultBinary\":json.types.binary[0], \"min\":json.sumStats.min[0], \"median\":json.sumStats.median[0], \"sd\":json.sumStats.sd[0], \"mode\":(json.sumStats.mode[0]).toString(), \"freqmode\":json.sumStats.freqmode[0],\"fewest\":(json.sumStats.fewest[0]).toString(), \"freqfewest\":json.sumStats.freqfewest[0], \"mid\":(json.sumStats.mid[0]).toString(), \"freqmid\":json.sumStats.freqmid[0], \"uniques\":json.sumStats.uniques[0], \"herfindahl\":json.sumStats.herfindahl[0],\n                        \"valid\":json.sumStats.valid[0], \"mean\":json.sumStats.mean[0], \"max\":json.sumStats.max[0], \"invalid\":json.sumStats.invalid[0], \"subsetplot\":false, \"subsetrange\":[\"\", \"\"],\"setxplot\":false, \"setxvals\":[\"\", \"\"], \"grayout\":false});\n                    }\n                    function offspaceFail(btn) {\n                        alert(\"transform fail\");\n                    }\n                    makeCorsRequest(urlcall,btn, offspaceSuccess, offspaceFail, solajsonout);\n                }\n            \n                // if myspace and space j have not been subseted, append the same transformation\n                spaces[j].callHistory.push({func:\"transform\", zvars:n, transform:t});\n                spaces[j].logArray.push(\"transform: \".concat(rCall[0]));\n                 spaces[j].allNodes.push({id:i, reflexive: false, \"name\": rCall[0][0], \"labl\": \"transformlabel\", data: [5,15,20,0,5,15,20], count: hold, \"nodeCol\":colors(i), \"baseCol\":colors(i), \"strokeColor\":selVarColor, \"strokeWidth\":\"1\", \"interval\":json.types.interval[0], \"numchar\":json.types.numchar[0], \"nature\":json.types.nature[0], \"binary\":json.types.binary[0], \"defaultInterval\":json.types.interval[0], \"defaultNumchar\":json.types.numchar[0], \"defaultNature\":json.types.nature[0], \"defaultBinary\":json.types.binary[0], \"min\":json.sumStats.min[0], \"median\":json.sumStats.median[0], \"sd\":json.sumStats.sd[0], \"mode\":(json.sumStats.mode[0]).toString(), \"freqmode\":json.sumStats.freqmode[0],\"fewest\":(json.sumStats.fewest[0]).toString(), \"freqfewest\":json.sumStats.freqfewest[0], \"mid\":(json.sumStats.mid[0]).toString(), \"freqmid\":json.sumStats.freqmid[0], \"uniques\":json.sumStats.uniques[0], \"herfindahl\":json.sumStats.herfindahl[0],\n                \"valid\":json.sumStats.valid[0], \"mean\":json.sumStats.mean[0], \"max\":json.sumStats.max[0], \"invalid\":json.sumStats.invalid[0], \"subsetplot\":false, \"subsetrange\":[\"\", \"\"],\"setxplot\":false, \"setxvals\":[\"\", \"\"], \"grayout\":false});\n            \n                readPreprocess(json.url, p=spaces[j].preprocess, v=newVar, callback=null);\n            }   */\n        }\n    }\n\n    function transformFail(btn) {\n        alert(\"transform fail\");\n        estimateLadda.stop();\n    }\n\n    estimateLadda.start(); // start spinner\n    makeCorsRequest(urlcall, btn, transformSuccess, transformFail, solajsonout);\n}\n\nfunction scaffoldingPush(v) {\n    // adding a variable to the variable list after a transformation\n\n    d3.select(\"#tab1\").data(v).append(\"p\").attr(\"id\", function () {\n        return v[0].replace(/\\W/g, \"_\");\n    }).text(v[0]).style('background-color', hexToRgba(selVarColor)).attr(\"data-container\", \"body\").attr(\"data-toggle\", \"popover\").attr(\"data-trigger\", \"hover\").attr(\"data-placement\", \"right\").attr(\"data-html\", \"true\").attr(\"onmouseover\", \"$(this).popover('toggle');\").attr(\"onmouseout\", \"$(this).popover('toggle');\").attr(\"data-original-title\", \"Summary Statistics\").on(\"click\", function varClick() {\n        // we've added a new variable, so we need to add the listener\n        d3.select(this).style('background-color', function (d) {\n            var myText = d3.select(this).text();\n            var myColor = d3.select(this).style('background-color');\n            var mySC = allNodes[findNodeIndex(myText)].strokeColor;\n\n            zparams.zvars = []; //empty the zvars array\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                // we are adding a var\n                if (nodes.length == 0) {\n                    nodes.push(findNode(myText));\n                    nodes[0].reflexive = true;\n                } else {\n                    nodes.push(findNode(myText));\n                }\n                return hexToRgba(selVarColor);\n            } else {\n                // dropping a variable\n\n                nodes.splice(findNode(myText)[\"index\"], 1);\n                spliceLinksForNode(findNode(myText));\n\n                if (mySC == dvColor) {\n                    var dvIndex = zparams.zdv.indexOf(myText);\n                    if (dvIndex > -1) {\n                        zparams.zdv.splice(dvIndex, 1);\n                    }\n                } else if (mySC == csColor) {\n                    var csIndex = zparams.zcross.indexOf(myText);\n                    if (csIndex > -1) {\n                        zparams.zcross.splice(csIndex, 1);\n                    }\n                } else if (mySC == timeColor) {\n                    var timeIndex = zparams.ztime.indexOf(myText);\n                    if (timeIndex > -1) {\n                        zparams.ztime.splice(dvIndex, 1);\n                    }\n                } else if (mySC == nomColor) {\n                    var nomIndex = zparams.znom.indexOf(myText);\n                    if (nomIndex > -1) {\n                        zparams.znom.splice(dvIndex, 1);\n                    }\n                }\n\n                nodeReset(allNodes[findNodeIndex(myText)]);\n                borderState();\n                return varColor;\n            }\n        });\n        fakeClick();\n        panelPlots();\n    });\n    populatePopover(); // pipes in the summary stats\n\n    // drop down menu for tranformation toolbar\n    d3.select(\"#transSel\").data(v).append(\"option\").text(function (d) {\n        return d;\n    });\n}\n\n// below from http://www.html5rocks.com/en/tutorials/cors/ for cross-origin resource sharing\n// Create the XHR object.\nfunction createCORSRequest(method, url, callback) {\n    var xhr = new XMLHttpRequest();\n    if (\"withCredentials\" in xhr) {\n        // XHR for Chrome/Firefox/Opera/Safari.\n        xhr.open(method, url, true);\n    } else if (typeof XDomainRequest != \"undefined\") {\n        // XDomainRequest for IE.\n        xhr = new XDomainRequest();\n        xhr.open(method, url);\n    } else {\n        // CORS not supported.\n        xhr = null;\n    }\n    //    xhr.setRequestHeader('Content-Type', 'text/plain');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    return xhr;\n}\n\n// Make the actual CORS request.\nfunction makeCorsRequest(url, btn, callback, warningcallback, jsonstring) {\n    var xhr = createCORSRequest('POST', url);\n    if (!xhr) {\n        alert('CORS not supported');\n        return;\n    }\n    // Response handlers for asynchronous load\n    // onload or onreadystatechange?\n\n    xhr.onload = function () {\n\n        var text = xhr.responseText;\n        console.log(\"text \", text);\n\n        try {\n            var json = JSON.parse(text); // should wrap in try / catch\n            var names = Object.keys(json);\n        } catch (err) {\n            estimateLadda.stop();\n            selectLadda.stop();\n            console.log(err);\n            alert('Error: Could not parse incoming JSON.');\n        }\n\n        if (names[0] == \"warning\") {\n            warningcallback(btn);\n            alert(\"Warning: \" + json.warning);\n        } else {\n            callback(btn, json);\n        }\n    };\n    xhr.onerror = function () {\n        // note: xhr.readystate should be 4, and status should be 200.  a status of 0 occurs when the url becomes too large\n        if (xhr.status == 0) {\n            alert('There was an error making the request. xmlhttprequest status is 0.');\n        } else if (xhr.readyState != 4) {\n            alert('There was an error making the request. xmlhttprequest readystate is not 4.');\n        } else {\n            alert('Woops, there was an error making the request.');\n        }\n        console.log(xhr);\n        estimateLadda.stop();\n        selectLadda.stop();\n    };\n    xhr.send(jsonstring);\n}\n\nfunction legend(c) {\n    // this could be made smarter\n    if (zparams.ztime.length != 0 | zparams.zcross.length != 0 | zparams.zdv.length != 0 | zparams.znom.length != 0) {\n        document.getElementById(\"legend\").setAttribute(\"style\", \"display:block\");\n    } else {\n        document.getElementById(\"legend\").setAttribute(\"style\", \"display:none\");\n    }\n\n    if (zparams.ztime.length == 0) {\n        document.getElementById(\"timeButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        document.getElementById(\"timeButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n    if (zparams.zcross.length == 0) {\n        document.getElementById(\"csButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        document.getElementById(\"csButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n    if (zparams.zdv.length == 0) {\n        document.getElementById(\"dvButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        document.getElementById(\"dvButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n    if (zparams.znom.length == 0) {\n        document.getElementById(\"nomButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        document.getElementById(\"nomButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n\n    borderState();\n}\n\nfunction reset() {\n    location.reload();\n}\n\n// programmatically deselecting every selected variable...\nfunction erase() {\n    leftpanelMedium();\n    rightpanelMedium();\n    document.getElementById(\"legend\").setAttribute(\"style\", \"display:none\");\n\n    tabLeft('tab1');\n\n    jQuery.fn.d3Click = function () {\n        this.children().each(function (i, e) {\n            var mycol = d3.rgb(this.style.backgroundColor);\n            if (mycol.toString() === varColor.toString()) {\n                return;\n            }\n            var evt = document.createEvent(\"MouseEvents\");\n            evt.initMouseEvent(\"click\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\n            e.dispatchEvent(evt);\n        });\n    };\n    $(\"#tab1\").d3Click();\n}\n\nfunction deselect(d) {\n    console.log(d);\n}\n\n// http://www.tutorials2learn.com/tutorials/scripts/javascript/xml-parser-javascript.html\nfunction loadXMLDoc(XMLname) {\n    var xmlDoc;\n    if (window.XMLHttpRequest) {\n        xmlDoc = new window.XMLHttpRequest();\n        xmlDoc.open(\"GET\", XMLname, false);\n        xmlDoc.send(\"\");\n        return xmlDoc.responseXML;\n    }\n    // IE 5 and IE 6\n    else if (ActiveXObject(\"Microsoft.XMLDOM\")) {\n            xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n            xmlDoc.async = false;\n            xmlDoc.load(XMLname);\n            return xmlDoc;\n        }\n    alert(\"Error loading document!\");\n    return null;\n}\n\nfunction tabLeft(tab) {\n\n    if (tab != \"tab3\") {\n        lefttab = tab;\n    }\n    var tabi = tab.substring(3);\n\n    document.getElementById('tab1').style.display = 'none';\n    document.getElementById('tab2').style.display = 'none';\n    document.getElementById('tab3').style.display = 'none';\n\n    if (tab === \"tab1\") {\n        summaryHold = false;\n        document.getElementById('btnSubset').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnVariables').setAttribute(\"class\", \"btn active\");\n        document.getElementById(\"btnSelect\").style.display = 'none';\n\n        d3.select(\"#leftpanel\").attr(\"class\", \"sidepanel container clearfix\");\n    } else if (tab === \"tab2\") {\n        summaryHold = false;\n        document.getElementById('btnVariables').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnSubset').setAttribute(\"class\", \"btn active\");\n\n        d3.select(\"#leftpanel\").attr(\"class\", function (d) {\n            if (this.getAttribute(\"class\") === \"sidepanel container clearfix expandpanel\") {\n                document.getElementById(\"btnSelect\").style.display = 'none';\n                return \"sidepanel container clearfix\";\n            } else {\n                document.getElementById(\"btnSelect\").style.display = 'block';\n                return \"sidepanel container clearfix expandpanel\";\n            }\n        });\n    } else {\n        document.getElementById('btnSubset').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnVariables').setAttribute(\"class\", \"btn btn-default\");\n\n        d3.select(\"#leftpanel\").attr(\"class\", \"sidepanel container clearfix\");\n    }\n\n    document.getElementById(tab).style.display = 'block';\n}\n\nfunction tabRight(tabid) {\n\n    document.getElementById('models').style.display = 'none';\n    document.getElementById('setx').style.display = 'none';\n    document.getElementById('results').style.display = 'none';\n\n    if (tabid == \"btnModels\") {\n        document.getElementById('btnSetx').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnResults').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnModels').setAttribute(\"class\", \"btn active\");\n        document.getElementById('models').style.display = 'block';\n\n        d3.select(\"#rightpanel\").attr(\"class\", \"sidepanel container clearfix\");\n    } else if (tabid == \"btnSetx\") {\n        document.getElementById('btnModels').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnResults').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnSetx').setAttribute(\"class\", \"btn active\");\n        document.getElementById('setx').style.display = 'block';\n\n        if (righttab == \"btnSetx\" | d3.select(\"#rightpanel\").attr(\"class\") == \"sidepanel container clearfix\") {\n            toggleR();\n        };\n    } else if (tabid == \"btnResults\") {\n        document.getElementById('btnModels').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnSetx').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnResults').setAttribute(\"class\", \"btn active\");\n        document.getElementById('results').style.display = 'block';\n\n        if (estimated === false) {\n            d3.select(\"#rightpanel\").attr(\"class\", \"sidepanel container clearfix\");\n        } else if (righttab == \"btnResults\" | d3.select(\"#rightpanel\").attr(\"class\") == \"sidepanel container clearfix\") {\n            toggleR();\n        };\n    }\n\n    righttab = tabid; // a global that may be of use\n\n    function toggleR() {\n        d3.select(\"#rightpanel\").attr(\"class\", function (d) {\n            if (this.getAttribute(\"class\") === \"sidepanel container clearfix expandpanel\") {\n                return \"sidepanel container clearfix\";\n            } else {\n                return \"sidepanel container clearfix expandpanel\";\n            }\n        });\n    }\n}\n\nfunction varSummary(d) {\n\n    var rint = d3.format(\"r\");\n\n    var summarydata = [],\n        tmpDataset = [],\n        t1 = [\"Mean:\", \"Median:\", \"Most Freq:\", \"Occurrences:\", \"Median Freq:\", \"Occurrences:\", \"Least Freq:\", \"Occurrences:\", \"Stand.Dev:\", \"Minimum:\", \"Maximum:\", \"Invalid:\", \"Valid:\", \"Uniques:\", \"Herfindahl:\"],\n        t2 = [(+d.mean).toPrecision(4).toString(), (+d.median).toPrecision(4).toString(), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), (+d.sd).toPrecision(4).toString(), (+d.min).toPrecision(4).toString(), (+d.max).toPrecision(4).toString(), rint(d.invalid), rint(d.valid), rint(d.uniques), (+d.herfindahl).toPrecision(4).toString()],\n        i,\n        j;\n    if (priv) {\n        if (d.meanCI) {\n            t1 = [\"Mean:\", \"Median:\", \"Most Freq:\", \"Occurrences:\", \"Median Freq:\", \"Occurrences:\", \"Least Freq:\", \"Occurrences:\", \"Stand.Dev:\", \"Minimum:\", \"Maximum:\", \"Invalid:\", \"Valid:\", \"Uniques:\", \"Herfindahl:\"], t2 = [(+d.mean).toPrecision(2).toString() + \" (\" + (+d.meanCI.lowerBound).toPrecision(2).toString() + \" - \" + (+d.meanCI.upperBound).toPrecision(2).toString() + \")\", (+d.median).toPrecision(4).toString(), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), (+d.sd).toPrecision(4).toString(), (+d.min).toPrecision(4).toString(), (+d.max).toPrecision(4).toString(), rint(d.invalid), rint(d.valid), rint(d.uniques), (+d.herfindahl).toPrecision(4).toString()], i, j;\n        }\n    }\n\n    for (i = 0; i < t1.length; i++) {\n        if (t2[i].indexOf(\"NaN\") > -1 | t2[i] == \"NA\" | t2[i] == \"\") continue;\n        tmpDataset = [];\n        tmpDataset.push(t1[i]);\n        tmpDataset.push(t2[i]);\n        summarydata.push(tmpDataset);\n    };\n\n    //  console.log(summarydata);\n    d3.select(\"#tab3\") //tab when you mouseover a pebble\n    .select(\"p\").html(\"<center><b>\" + d.name + \"</b><br><i>\" + d.labl + \"</i></center>\").append(\"table\").selectAll(\"tr\").data(summarydata).enter().append(\"tr\").selectAll(\"td\").data(function (d) {\n        return d;\n    }).enter().append(\"td\").text(function (d) {\n        return d;\n    }).on(\"mouseover\", function () {\n        d3.select(this).style(\"background-color\", \"aliceblue\");\n    }) // for no discernable reason\n    .on(\"mouseout\", function () {\n        d3.select(this).style(\"background-color\", \"#F9F9F9\");\n    }); //(but maybe we'll think of one)\n    //    .style(\"font-size\", \"12px\");\n\n\n    var plotsvg = d3.select(\"#tab3\").selectAll(\"svg\").remove();\n\n    if (typeof d.plottype === \"undefined\") {\n        // .properties is undefined for some vars\n        return;\n    } else if (d.plottype === \"continuous\") {\n        density(d, div = \"varSummary\", priv);\n    } else if (d.plottype === \"bar\") {\n        bars(d, div = \"varSummary\", priv);\n    } else {\n        var plotsvg = d3.select(\"#tab3\") // no graph to draw, but still need to remove previous graph\n        .selectAll(\"svg\").remove();\n    };\n}\n\nfunction populatePopover() {\n\n    d3.select(\"#tab1\").selectAll(\"p\").attr(\"data-content\", function (d) {\n        var onNode = findNodeIndex(d);\n        return popoverContent(allNodes[onNode]);\n    });\n}\n\nfunction popoverContent(d) {\n\n    var rint = d3.format(\"r\");\n\n    var outtext = \"\";\n\n    if (d.labl != \"\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Label</label><div class='col-sm-6'><p class='form-control-static'><i>\" + d.labl + \"</i></p></div></div>\";\n    }\n\n    if (d.mean != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Mean</label><div class='col-sm-6'><p class='form-control-static'>\";\n        if (priv && d.meanCI) {\n            outtext += (+d.mean).toPrecision(2).toString() + \" (\" + (+d.meanCI.lowerBound).toPrecision(2).toString() + \" - \" + (+d.meanCI.upperBound).toPrecision(2).toString() + \")\";\n        } else {\n            outtext += (+d.mean).toPrecision(4).toString();\n        }\n        outtext += \"</p></div></div>\";\n    }\n\n    if (d.median != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Median</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.median).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n\n    if (d.mode != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Most Freq</label><div class='col-sm-6'><p class='form-control-static'>\" + d.mode + \"</p></div></div>\";\n    }\n\n    if (d.freqmode != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Occurrences</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.freqmode) + \"</p></div></div>\";\n    }\n\n    if (d.mid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Median Freq</label><div class='col-sm-6'><p class='form-control-static'>\" + d.mid + \"</p></div></div>\";\n    }\n\n    if (d.freqmid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Occurrences</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.freqmid) + \"</p></div></div>\";\n    }\n    if (d.fewest != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Least Freq</label><div class='col-sm-6'><p class='form-control-static'>\" + d.fewest + \"</p></div></div>\";\n    }\n\n    if (d.freqfewest != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Occurrences</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.freqfewest) + \"</p></div></div>\";\n    }\n\n    if (d.sd != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Stand Dev</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.sd).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n\n    if (d.max != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Maximum</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.max).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n\n    if (d.min != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Minimum</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.min).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n    if (d.invalid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Invalid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.invalid) + \"</p></div></div>\";\n    }\n    if (d.valid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Valid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.valid) + \"</p></div></div>\";\n    }\n\n    if (d.uniques != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Uniques</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.uniques) + \"</p></div></div>\";\n    }\n    if (d.herfindahl != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Herfindahl</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.herfindahl).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n\n    return outtext;\n}\n\nfunction popupX(d) {\n\n    var tsf = d3.format(\".4r\");\n    var rint = d3.format(\"r\");\n\n    //Create the tooltip label\n    d3.select(\"#tooltip\").style(\"left\", tempX + \"px\").style(\"top\", tempY + \"px\").select(\"#tooltiptext\").html(\"<div class='form-group'><label class='col-sm-4 control-label'>Mean</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.mean) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Median</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.median) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Mode</label><div class='col-sm-6'><p class='form-control-static'>\" + d.mode + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Stand Dev</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.sd) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Maximum</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.max) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Minimum</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.min) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Valid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.valid) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Invalid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.invalid) + \"</p></div></div>\");\n\n    /*.html(\"Median: \" + d.median + \"<br>Mode: \" + d.mode + \"<br>Maximum: \" + d.max + \"<br>Minimum: \" + d.min + \"<br>Mean: \" + d.mean + \"<br>Invalid: \" + d.invalid + \"<br>Valid: \" + d.valid + \"<br>Stand Dev: \" + d.sd);*/\n\n    //d3.select(\"#tooltip\")\n    //.style(\"display\", \"inline\")\n    //.select(\"#tooltip h3.popover-title\")\n    //.html(\"Summary Statistics\");\n}\n\nfunction panelPlots() {\n\n    // build arrays from nodes in main\n    var varArray = [];\n    var idArray = [];\n\n    for (var j = 0; j < nodes.length; j++) {\n        varArray.push(nodes[j].name.replace(/\\(|\\)/g, \"\"));\n        idArray.push(nodes[j].id);\n    }\n\n    //remove all plots, could be smarter here\n    d3.select(\"#setx\").selectAll(\"svg\").remove();\n    d3.select(\"#tab2\").selectAll(\"svg\").remove();\n\n    for (var i = 0; i < varArray.length; i++) {\n        allNodes[idArray[i]].setxplot = false;\n        allNodes[idArray[i]].subsetplot = false;\n        if (allNodes[idArray[i]].plottype === \"continuous\" & allNodes[idArray[i]].setxplot == false) {\n            allNodes[idArray[i]].setxplot = true;\n            console.log(priv);\n            density(allNodes[idArray[i]], div = \"setx\", priv);\n            allNodes[idArray[i]].subsetplot = true;\n            density(allNodes[idArray[i]], div = \"subset\", priv);\n        } else if (allNodes[idArray[i]].plottype === \"bar\" & allNodes[idArray[i]].setxplot == false) {\n            allNodes[idArray[i]].setxplot = true;\n            bars(allNodes[idArray[i]], div = \"setx\", priv);\n            allNodes[idArray[i]].subsetplot = true;\n            barsSubset(allNodes[idArray[i]]);\n        }\n    }\n\n    d3.select(\"#setx\").selectAll(\"svg\").each(function () {\n        d3.select(this);\n        var regstr = /(.+)_setx_(\\d+)/;\n        var myname = regstr.exec(this.id);\n        var nodeid = myname[2];\n        myname = myname[1];\n        var j = varArray.indexOf(myname);\n\n        if (j == -1) {\n            allNodes[nodeid].setxplot = false;\n            var temp = \"#\".concat(myname, \"_setx_\", nodeid);\n            d3.select(temp).remove();\n\n            allNodes[nodeid].subsetplot = false;\n            var temp = \"#\".concat(myname, \"_tab2_\", nodeid);\n            d3.select(temp).remove();\n        }\n    });\n}\n\n// easy functions to collapse panels to base\nfunction rightpanelMedium() {\n    d3.select(\"#rightpanel\").attr(\"class\", \"sidepanel container clearfix\");\n}\nfunction leftpanelMedium() {\n    d3.select(\"#leftpanel\").attr(\"class\", \"sidepanel container clearfix\");\n}\n\n// function to convert color codes\nfunction hexToRgba(hex) {\n    var h = hex.replace('#', '');\n\n    var bigint = parseInt(h, 16);\n    var r = bigint >> 16 & 255;\n    var g = bigint >> 8 & 255;\n    var b = bigint & 255;\n    var a = '0.5';\n\n    return \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + a + \")\";\n}\n\n// function takes a node and a color and updates zparams\nfunction setColors(n, c) {\n\n    if (n.strokeWidth == '1') {\n        // adding time, cs, dv, nom to a node with no stroke\n        n.strokeWidth = '4';\n        n.strokeColor = c;\n        n.nodeCol = taggedColor;\n        if (dvColor == c) {\n            // check if array, if not, make it an array\n            //  console.log(Object.prototype.toString.call(zparams.zdv));\n            zparams.zdv = Object.prototype.toString.call(zparams.zdv) == \"[object Array]\" ? zparams.zdv : [];\n            zparams.zdv.push(n.name);\n        } else if (csColor == c) {\n            zparams.zcross = Object.prototype.toString.call(zparams.zcross) == \"[object Array]\" ? zparams.zcross : [];\n            zparams.zcross.push(n.name);\n        } else if (timeColor == c) {\n            zparams.ztime = Object.prototype.toString.call(zparams.ztime) == \"[object Array]\" ? zparams.ztime : [];\n            zparams.ztime.push(n.name);\n        } else if (nomColor == c) {\n            zparams.znom = Object.prototype.toString.call(zparams.znom) == \"[object Array]\" ? zparams.znom : [];\n            zparams.znom.push(n.name);\n            allNodes[findNodeIndex(n.name)].nature = \"nominal\";\n            transform(n.name, t = null, typeTransform = true);\n        }\n\n        d3.select(\"#tab1\").select(\"p#\".concat(n.name)).style('background-color', hexToRgba(c));\n    } else if (n.strokeWidth == '4') {\n        if (c == n.strokeColor) {\n            // deselecting time, cs, dv, nom\n            n.strokeWidth = '1';\n            n.strokeColor = selVarColor;\n            n.nodeCol = colors(n.id);\n            d3.select(\"#tab1\").select(\"p#\".concat(n.name)).style('background-color', hexToRgba(selVarColor));\n\n            if (dvColor == c) {\n                var dvIndex = zparams.zdv.indexOf(n.name);\n                if (dvIndex > -1) {\n                    zparams.zdv.splice(dvIndex, 1);\n                }\n            } else if (csColor == c) {\n                var csIndex = zparams.zcross.indexOf(n.name);\n                if (csIndex > -1) {\n                    zparams.zcross.splice(csIndex, 1);\n                }\n            } else if (timeColor == c) {\n                var timeIndex = zparams.ztime.indexOf(n.name);\n                if (timeIndex > -1) {\n                    zparams.ztime.splice(timeIndex, 1);\n                }\n            } else if (nomColor == c) {\n                var nomIndex = zparams.znom.indexOf(n.name);\n                if (nomIndex > -1) {\n                    zparams.znom.splice(nomIndex, 1);\n                    allNodes[findNodeIndex(n.name)].nature = allNodes[findNodeIndex(n.name)].defaultNature;\n                    transform(n.name, t = null, typeTransform = true);\n                }\n            }\n        } else {\n            // deselecting time, cs, dv, nom AND changing it to time, cs, dv, nom\n            if (dvColor == n.strokeColor) {\n                var dvIndex = zparams.zdv.indexOf(n.name);\n                if (dvIndex > -1) {\n                    zparams.zdv.splice(dvIndex, 1);\n                }\n            } else if (csColor == n.strokeColor) {\n                var csIndex = zparams.zcross.indexOf(n.name);\n                if (csIndex > -1) {\n                    zparams.zcross.splice(csIndex, 1);\n                }\n            } else if (timeColor == n.strokeColor) {\n                var timeIndex = zparams.ztime.indexOf(n.name);\n                if (timeIndex > -1) {\n                    zparams.ztime.splice(timeIndex, 1);\n                }\n            } else if (nomColor == n.strokeColor) {\n                var nomIndex = zparams.znom.indexOf(n.name);\n                if (nomIndex > -1) {\n                    zparams.znom.splice(nomIndex, 1);\n                    allNodes[findNodeIndex(n.name)].nature = allNodes[findNodeIndex(n.name)].defaultNature;\n                    transform(n.name, t = null, typeTransform = true);\n                }\n            }\n            n.strokeColor = c;\n            d3.select(\"#tab1\").select(\"p#\".concat(n.name)).style('background-color', hexToRgba(c));\n\n            if (dvColor == c) {\n                zparams.zdv.push(n.name);\n            } else if (csColor == c) {\n                zparams.zcross.push(n.name);\n            } else if (timeColor == c) {\n                zparams.ztime.push(n.name);\n            } else if (nomColor == c) {\n                zparams.znom.push(n.name);\n                allNodes[findNodeIndex(n.name)].nature = \"nominal\";\n                transform(n.name, t = null, typeTransform = true);\n            }\n        }\n    }\n}\n\nfunction borderState() {\n    if (zparams.zdv.length > 0) {\n        $('#dvButton .rectColor svg circle').attr('stroke', dvColor);\n    } else {\n        $('#dvButton').css('border-color', '#ccc');\n    }\n    if (zparams.zcross.length > 0) {\n        $('#csButton .rectColor svg circle').attr('stroke', csColor);\n    } else {\n        $('#csButton').css('border-color', '#ccc');\n    }\n    if (zparams.ztime.length > 0) {\n        $('#timeButton .rectColor svg circle').attr('stroke', timeColor);\n    } else {\n        $('#timeButton').css('border-color', '#ccc');\n    }\n    if (zparams.znom.length > 0) {\n        $('#nomButton .rectColor svg circle').attr('stroke', nomColor);\n    } else {\n        $('#nomButton').css('border-color', '#ccc');\n    }\n}\n\n// small appearance resets, but perhaps this will become a hard reset back to all original allNode values?\nfunction nodeReset(n) {\n    n.strokeColor = selVarColor;\n    n.strokeWidth = \"1\";\n    n.nodeCol = n.baseCol;\n}\n\nfunction subsetSelect(btn) {\n\n    if (dataurl) {\n        zparams.zdataurl = dataurl;\n    }\n\n    if (production && zparams.zsessionid == \"\") {\n        alert(\"Warning: Data download is not complete. Try again soon.\");\n        return;\n    }\n\n    zparams.zvars = [];\n    zparams.zplot = [];\n\n    var subsetEmpty = true;\n\n    // is this the same as zPop()?\n    for (var j = 0; j < nodes.length; j++) {\n        //populate zvars and zsubset arrays\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n        if (zparams.zsubset[j].length > 0) {\n            if (zparams.zsubset[j][0] != \"\") {\n                zparams.zsubset[j][0] = Number(zparams.zsubset[j][0]);\n            }\n            if (zparams.zsubset[j][1] != \"\") {\n                zparams.zsubset[j][1] = Number(zparams.zsubset[j][1]);\n            }\n        }\n        zparams.zplot.push(allNodes[temp].plottype);\n        if (zparams.zsubset[j][1] != \"\") {\n            subsetEmpty = false;\n        } //only need to check one\n    }\n\n    if (subsetEmpty == true) {\n        alert(\"Warning: No new subset selected.\");\n        return;\n    }\n\n    var outtypes = [];\n    for (var j = 0; j < allNodes.length; j++) {\n        outtypes.push({ varnamesTypes: allNodes[j].name, nature: allNodes[j].nature, numchar: allNodes[j].numchar, binary: allNodes[j].binary, interval: allNodes[j].interval });\n    }\n\n    var subsetstuff = { zdataurl: zparams.zdataurl, zvars: zparams.zvars, zsubset: zparams.zsubset, zsessionid: zparams.zsessionid, zplot: zparams.zplot, callHistory: callHistory, typeStuff: outtypes };\n\n    var jsonout = JSON.stringify(subsetstuff);\n    //var base = rappURL+\"subsetapp?solaJSON=\"\n    urlcall = rappURL + \"subsetapp\"; //base.concat(jsonout);\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    function subsetSelectSuccess(btn, json) {\n\n        selectLadda.stop(); // stop motion\n        $(\"#btnVariables\").trigger(\"click\"); // programmatic clicks\n        $(\"#btnModels\").trigger(\"click\");\n\n        var grayOuts = [];\n\n        var rCall = [];\n        rCall[0] = json.call;\n\n        // store contents of the pre-subset space\n        zPop();\n        var myNodes = jQuery.extend(true, [], allNodes);\n        var myParams = jQuery.extend(true, {}, zparams);\n        var myTrans = jQuery.extend(true, [], trans);\n        var myForce = jQuery.extend(true, [], forcetoggle);\n        var myPreprocess = jQuery.extend(true, {}, preprocess);\n        var myLog = jQuery.extend(true, [], logArray);\n        var myHistory = jQuery.extend(true, [], callHistory);\n\n        spaces[myspace] = { \"allNodes\": myNodes, \"zparams\": myParams, \"trans\": myTrans, \"force\": myForce, \"preprocess\": myPreprocess, \"logArray\": myLog, \"callHistory\": myHistory };\n\n        // remove pre-subset svg\n        var selectMe = \"#m\".concat(myspace);\n        d3.select(selectMe).attr('class', 'item');\n        selectMe = \"#whitespace\".concat(myspace);\n        d3.select(selectMe).remove();\n\n        // selectMe = \"navdot\".concat(myspace);\n        // var mynavdot = document.getElementById(selectMe);\n        // mynavdot.removeAttribute(\"class\");\n\n        myspace = spaces.length;\n        callHistory.push({ func: \"subset\", zvars: jQuery.extend(true, [], zparams.zvars), zsubset: jQuery.extend(true, [], zparams.zsubset), zplot: jQuery.extend(true, [], zparams.zplot) });\n\n        //  selectMe = \"navdot\".concat(myspace-1);\n        //  mynavdot = document.getElementById(selectMe);\n\n        //   var newnavdot = document.createElement(\"li\");\n        //   newnavdot.setAttribute(\"class\", \"active\");\n        //    selectMe = \"navdot\".concat(myspace);\n        //    newnavdot.setAttribute(\"id\", selectMe);\n        //    mynavdot.parentNode.insertBefore(newnavdot, mynavdot.nextSibling);\n\n\n        // this is to be used to gray out and remove listeners for variables that have been subsetted out of the data\n        function varOut(v) {\n            // if in nodes, remove\n            // gray out in left panel\n            // make unclickable in left panel\n            for (var i = 0; i < v.length; i++) {\n                var selectMe = v[i].replace(/\\W/g, \"_\");\n                document.getElementById(selectMe).style.color = hexToRgba(grayColor);\n                selectMe = \"p#\".concat(selectMe);\n                d3.select(selectMe).on(\"click\", null);\n            }\n        }\n\n        logArray.push(\"subset: \".concat(rCall[0]));\n        showLog();\n        reWriteLog();\n\n        d3.select(\"#innercarousel\").append('div').attr('class', 'item active').attr('id', function () {\n            return \"m\".concat(myspace.toString());\n        }).append('svg').attr('id', 'whitespace');\n        svg = d3.select(\"#whitespace\");\n\n        d3.json(json.url, function (error, json) {\n            if (error) return console.warn(error);\n            var jsondata = json;\n\n            for (var key in jsondata) {\n                var myIndex = findNodeIndex(key);\n\n                allNodes[myIndex].plotx = undefined;\n                allNodes[myIndex].ploty = undefined;\n                allNodes[myIndex].plotvalues = undefined;\n                allNodes[myIndex].plottype = \"\";\n\n                jQuery.extend(true, allNodes[myIndex], jsondata[key]);\n\n                allNodes[myIndex].subsetplot = false;\n                allNodes[myIndex].subsetrange = [\"\", \"\"];\n                allNodes[myIndex].setxplot = false;\n                allNodes[myIndex].setxvals = [\"\", \"\"];\n\n                if (allNodes[myIndex].valid == 0) {\n                    grayOuts.push(allNodes[myIndex].name);\n                    allNodes[myIndex].grayout = true;\n                }\n            }\n\n            rePlot();\n            populatePopover();\n            layout(v = \"add\");\n        });\n\n        varOut(grayOuts);\n    }\n\n    function subsetSelectFail(btn) {\n        selectLadda.stop(); //stop motion\n    }\n\n    selectLadda.start(); //start button motion\n    makeCorsRequest(urlcall, btn, subsetSelectSuccess, subsetSelectFail, solajsonout);\n}\n\nfunction readPreprocess(url, p, v, callback) {\n    console.log(url);\n    d3.json(url, function (error, json) {\n        if (error) return console.warn(error);\n        var jsondata = json;\n\n        console.log(\"inside readPreprocess function\");\n        console.log(jsondata);\n        console.log(jsondata[\"variables\"]);\n\n        if (jsondata.dataset.priv) {\n            priv = jsondata[\"dataset\"][\"priv\"];\n        };\n\n        //copying the object\n        for (var key in jsondata[\"variables\"]) {\n            p[key] = jsondata[\"variables\"][key];\n        }\n        // console.log(\"we're here\")\n        // console.log(p);\n\n        if (typeof callback === \"function\") {\n            callback();\n        }\n    });\n}\n\n/*\nfunction delSpace() {\n    if (spaces.length===0 | (spaces.length===1 & myspace===0)) {return;}\n    var lastSpace = false;\n    if(myspace >= spaces.length-1) { lastSpace=true; }\n    spaces.splice(myspace, 1);\n    \n    // remove current whitespace\n    var selectMe = \"#m\".concat(myspace);\n    d3.select(selectMe).attr('class', 'item');\n    selectMe = \"#whitespace\".concat(myspace);\n    d3.select(selectMe).remove();\n    \n    // remove last navdot\n    selectMe = \"navdot\".concat(spaces.length);\n    var mynavdot = document.getElementById(selectMe);\n    mynavdot.parentElement.removeChild(mynavdot); // remove from parent to remove the pointer to the child\n    \n    // remove last inner carousel m\n    selectMe = \"m\".concat(spaces.length);\n    var mynavdot = document.getElementById(selectMe);\n    mynavdot.parentElement.removeChild(mynavdot);\n    \n    if(lastSpace) { myspace = myspace-1; }\n    \n    selectMe = \"navdot\".concat(myspace);\n    newnavdot = document.getElementById(selectMe);\n    newnavdot.setAttribute(\"class\", \"active\");\n    \n    // add whitespace back in to current inner carousel m\n    selectMe = \"#m\".concat(myspace);\n    d3.select(selectMe).attr('class', 'item active')\n    .append('svg').attr('id', function(){\n                        return \"whitespace\".concat(myspace);\n                        });\n    \n    allNodes = jQuery.extend(true, [], spaces[myspace].allNodes);\n    zparams = jQuery.extend(true, {}, spaces[myspace].zparams);\n    trans = jQuery.extend(true, [], spaces[myspace].trans);\n    forcetoggle = jQuery.extend(true, [], spaces[myspace].force);\n    preprocess = jQuery.extend(true, {}, spaces[myspace].preprocess);\n    \n    selectMe = \"#whitespace\".concat(myspace);\n    svg = d3.select(selectMe);\n    \n    layout(v=\"move\");\n}\n\n\n// for the following three functions, the general idea is to store the new information for the current space, and then move myspace according (right: +1, left: -1, addSpace: spaces.length)\nfunction addSpace() {\n\n    zPop();\n    \n    // everything we need to save the image of the current space.\n    var myNodes = jQuery.extend(true, [], allNodes); // very important. this clones the allNodes object, and may slow us down in the future.  if user hits plus 4 times, we'll have four copies of the same space in memory.  certainly a way to optimize this\n    var myParams = jQuery.extend(true, {}, zparams);\n    var myTrans = jQuery.extend(true, [], trans);\n    var myForce = jQuery.extend(true, [], forcetoggle);\n    var myPreprocess = jQuery.extend(true, {}, preprocess);\n    var myLog = jQuery.extend(true, [], logArray);\n    var myHistory = jQuery.extend(true, [], callHistory);\n\n  \n    spaces[myspace] = {\"allNodes\":myNodes, \"zparams\":myParams, \"trans\":myTrans, \"force\":myForce, \"preprocess\":myPreprocess, \"logArray\":myLog, \"callHistory\":myHistory};\n    \n    var selectMe = \"#m\".concat(myspace);\n    d3.select(selectMe).attr('class', 'item');\n    selectMe = \"#whitespace\".concat(myspace);\n    d3.select(selectMe).remove();\n    \n    selectMe = \"navdot\".concat(myspace);\n    var mynavdot = document.getElementById(selectMe);\n    mynavdot.removeAttribute(\"class\");\n    \n    myspace = spaces.length;\n    \n    selectMe = \"navdot\".concat(myspace-1);\n    mynavdot = document.getElementById(selectMe);\n    \n    var newnavdot = document.createElement(\"li\");\n    newnavdot.setAttribute(\"class\", \"active\");\n    selectMe = \"navdot\".concat(myspace);\n    newnavdot.setAttribute(\"id\", selectMe);\n    mynavdot.parentNode.insertBefore(newnavdot, mynavdot.nextSibling);\n    \n    d3.select(\"#innercarousel\")\n    .append('div')\n    .attr('class', 'item active')\n    .attr('id', function(){\n          return \"m\".concat(myspace.toString());\n          })\n    .append('svg')\n    .attr('id', 'whitespace');\n    svg = d3.select(\"#whitespace\");\n\n    layout(v=\"add\");\n\n}\n\nfunction left() {\n    \n    zPop();\n    \n    var myNodes = jQuery.extend(true, [], allNodes); // very important. this clones the allNodes object, and may slow us down in the future.  if user hits plus 4 times, we'll have four copies of the same space in memory.  certainly a way to optimize this\n    var myParams = jQuery.extend(true, {}, zparams);\n    var myTrans = jQuery.extend(true, [], trans);\n    var myForce = jQuery.extend(true, [], forcetoggle);\n    var myPreprocess = jQuery.extend(true, {}, preprocess);\n    var myLog = jQuery.extend(true, [], logArray);\n    var myHistory = jQuery.extend(true, [], callHistory);\n    \n    if(typeof spaces[myspace] === \"undefined\") {\n        spaces.push({\"allNodes\":myNodes, \"zparams\":myParams, \"trans\":myTrans, \"force\":myForce, \"preprocess\":myPreprocess, \"logArray\":myLog, \"callHistory\":myHistory});\n    }\n    else {\n        spaces[myspace] = {\"allNodes\":myNodes, \"zparams\":myParams, \"trans\":myTrans, \"force\":myForce, \"preprocess\":myPreprocess, \"logArray\":myLog, \"callHistory\":myHistory};\n    }\n    \n    if(myspace===0) {\n        myspace=spaces.length-1; // move to last when left is click at 0\n    }\n    else {\n        myspace = myspace-1;\n    }\n    \n    selectMe = \"#m\".concat(myspace);\n    d3.select(selectMe)\n    .append('svg').attr('id', function(){\n                        return \"whitespace\".concat(myspace);\n                        });\n\n    allNodes = jQuery.extend(true, [], spaces[myspace].allNodes);\n    zparams = jQuery.extend(true, {}, spaces[myspace].zparams);\n    trans = jQuery.extend(true, [], spaces[myspace].trans);\n    forcetoggle = jQuery.extend(true, [], spaces[myspace].force);\n    preprocess = jQuery.extend(true, {}, spaces[myspace].preprocess);\n    logArray = jQuery.extend(true, [], spaces[myspace].logArray);\n    callHistory = jQuery.extend(true, [], spaces[myspace].callHistory);\n\n    selectMe = \"#whitespace\".concat(myspace);\n    svg = d3.select(selectMe);\n    \n    rePlot();\n    layout(v=\"move\");\n    \n    selectMe = \"navdot\".concat(myspace);\n    newnavdot = document.getElementById(selectMe);\n    newnavdot.setAttribute(\"class\", \"active\");\n  \n    if(myspace===spaces.length-1) {\n        myspace=0;\n    }\n    else {\n        myspace = myspace+1;\n    }\n\n    selectMe = \"navdot\".concat(myspace);\n    var mynavdot = document.getElementById(selectMe);\n    mynavdot.removeAttribute(\"class\", \"active\");\n    \n    selectMe = \"#whitespace\".concat(myspace);\n    d3.select(selectMe).remove();\n\n    if(myspace===0) {\n        myspace=spaces.length-1; // move to last when left is click at 0\n    }\n    else {\n        myspace = myspace-1;\n    }\n\n\n    if(forcetoggle[0]===\"false\") {\n        document.getElementById('btnForce').setAttribute(\"class\", \"btn active\");\n    }\n    else {\n        document.getElementById('btnForce').setAttribute(\"class\", \"btn btn-default\");\n    }\n\n    d3.select(\"#models\").selectAll(\"p\").style(\"background-color\", varColor);\n    selectMe = \"#_model_\".concat(zparams.zmodel);\n    d3.select(selectMe).style(\"background-color\", hexToRgba(selVarColor));\n    \n    selectMe = \"#whitespace\".concat(myspace);\n    svg = d3.select(selectMe);\n\n    legend();\n    showLog();\n    reWriteLog();\n    \n //   event.preventDefault();\n\n}\n\nfunction right() {\n    zPop();\n    var myNodes = jQuery.extend(true, [], allNodes);\n    var myParams = jQuery.extend(true, {}, zparams);\n    var myTrans = jQuery.extend(true, [], trans);\n    var myForce = jQuery.extend(true, [], forcetoggle);\n    var myPreprocess = jQuery.extend(true, {}, preprocess);\n    var myLog = jQuery.extend(true, [], logArray);\n    var myHistory = jQuery.extend(true, [], callHistory);\n    \n    spaces[myspace] = {\"allNodes\":myNodes, \"zparams\":myParams, \"trans\":myTrans, \"force\":myForce, \"preprocess\":myPreprocess, \"logArray\":myLog,\"callHistory\":myHistory};\n    \n  \n    if(myspace===spaces.length-1) {\n        myspace=0; // move to last when left is click at 0\n    }\n    else {\n        myspace = myspace+1;\n    }\n\n    selectMe = \"#m\".concat(myspace);\n    d3.select(selectMe)\n    .append('svg').attr('id', function(){\n                        return \"whitespace\".concat(myspace);\n                        });\n\n    allNodes = jQuery.extend(true, [], spaces[myspace].allNodes);\n    zparams = jQuery.extend(true, {}, spaces[myspace].zparams);\n    trans = jQuery.extend(true, [], spaces[myspace].trans);\n    forcetoggle = jQuery.extend(true, [], spaces[myspace].force);\n    preprocess = jQuery.extend(true, {}, spaces[myspace].preprocess);\n    logArray = jQuery.extend(true, [], spaces[myspace].logArray);\n    callHistory = jQuery.extend(true, [], spaces[myspace].callHistory);\n\n    selectMe = \"#whitespace\".concat(myspace);\n    svg = d3.select(selectMe);\n    \n    rePlot();\n    layout(v=\"move\");\n\n    if(myspace===0) {\n        myspace=spaces.length-1;\n    }\n    else {\n        myspace = myspace-1;\n    }\n    \n    selectMe = \"navdot\".concat(myspace);\n    var mynavdot = document.getElementById(selectMe);\n    mynavdot.removeAttribute(\"class\", \"active\");\n    \n    selectMe = \"#whitespace\".concat(myspace);\n    d3.select(selectMe).remove();\n    \n    if(myspace===spaces.length-1) {\n        myspace=0; // move to last when left is click at 0\n    }\n    else {\n        myspace = myspace+1;\n    }\n    \n    selectMe = \"navdot\".concat(myspace);\n    var newnavdot = document.getElementById(selectMe);\n    newnavdot.setAttribute(\"class\", \"active\");\n   \n    if(forcetoggle[0]===\"false\") {\n        document.getElementById('btnForce').setAttribute(\"class\", \"btn active\");\n    }\n    else {\n        document.getElementById('btnForce').setAttribute(\"class\", \"btn btn-default\");\n    }\n\n    d3.select(\"#models\").selectAll(\"p\").style(\"background-color\", varColor);\n    selectMe = \"#_model_\".concat(zparams.zmodel);\n    d3.select(selectMe).style(\"background-color\", hexToRgba(selVarColor));\n    \n    selectMe = \"#whitespace\".concat(myspace);\n    svg = d3.select(selectMe);\n    \n    legend();\n    showLog();\n    reWriteLog();\n    \n  //  event.preventDefault();\n}\n\n*/\n\nfunction about() {\n    $('#about').show();\n}\n\nfunction closeabout() {\n    $('#about').hide();\n}\n\nfunction opencite() {\n    $('#cite').show();\n}\n\nfunction closecite(toggle) {\n    if (toggle == false) {\n        $('#cite').hide();\n    }\n}\n\nfunction clickcite(toggle) {\n    if (toggle == false) {\n        $('#cite').show();\n        return true;\n    } else {\n        $('#cite').hide();\n        return false;\n    }\n}\n// function to remove all the children svgs inside subset and setx divs\nfunction rePlot() {\n\n    d3.select(\"#tab2\").selectAll(\"svg\").remove();\n\n    d3.select(\"#setx\").selectAll(\"svg\").remove();\n\n    // make this smarter\n    for (var i = 0; i < allNodes.length; i++) {\n        allNodes[i].setxplot = false;\n        allNodes[i].subsetplot = false;\n    }\n}\n\nfunction showLog() {\n    if (logArray.length > 0) {\n        document.getElementById('logdiv').setAttribute(\"style\", \"display:block\");\n        d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").data(logArray).enter().append(\"p\").text(function (d) {\n            return d;\n        });\n    } else {\n        document.getElementById('logdiv').setAttribute(\"style\", \"display:none\");\n    }\n}\n\nfunction reWriteLog() {\n    d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").remove();\n    d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").data(logArray).enter().append(\"p\").text(function (d) {\n        return d;\n    });\n}\n\n// acts as if the user clicked in whitespace. useful when restart() is outside of scope\nfunction fakeClick() {\n    var myws = \"#whitespace\".concat(myspace);\n    // d3 and programmatic events don't mesh well, here's a SO workaround that looks good but uses jquery...\n    jQuery.fn.d3Click = function () {\n        this.each(function (i, e) {\n            var evt = document.createEvent(\"MouseEvents\");\n            evt.initMouseEvent(\"mousedown\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\n            e.dispatchEvent(evt);\n        });\n    };\n    $(myws).d3Click();\n\n    d3.select(myws).classed('active', false); // remove active class\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9hcHBfZGRpLmpzPzdhNjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8vLy8vLy8vL1xuLy8gR2xvYmFsc1xuXG4vLyBob3N0bmFtZSBkZWZhdWx0IC0gdGhlIGFwcCB3aWxsIHVzZSBpdCB0byBvYnRhaW4gdGhlIHZhcmlhYmxlIG1ldGFkYXRhXG4vLyAoZGRpKSBhbmQgcHJlLXByb2Nlc3NlZCBkYXRhIGluZm8gaWYgdGhlIGZpbGUgaWQgaXMgc3VwcGxpZWQgYXMgYW4gXG4vLyBhcmd1bWVudCAoZm9yIGV4LiwgZ3VpLmh0bWw/ZGZJZD0xNyksIGJ1dCBob3N0bmFtZSBpc24ndC4gXG4vLyBFZGl0IGl0IHRvIHN1aXQgeW91ciBpbnN0YWxsYXRpb24uIFxuLy8gKE5PVEUgdGhhdCBpZiB0aGUgZmlsZSBpZCBpc24ndCBzdXBwbGllZCwgdGhlIGFwcCB3aWxsIGRlZmF1bHQgdG8gdGhlIFxuLy8gbG9jYWwgZmlsZXMgc3BlY2lmaWVkIGJlbG93ISlcbi8vIE5FVzogaXQgaXMgYWxzbyBwb3NzaWJsZSBub3cgdG8gc3VwcGx5IGNvbXBsZXRlIHVybHMgZm9yIHRoZSBkZGkgYW5kIFxuLy8gdGhlIHRhYi1kZWxpbWl0ZWQgZGF0YSBmaWxlOyB0aGUgcGFyYW1ldGVycyBhcmUgZGRpdXJsIGFuZCBkYXRhdXJsLiBcbi8vIFRoZXNlIG5ldyBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbC4gSWYgdGhleSBhcmUgbm90IHN1cHBsaWVkLCB0aGUgYXBwXG4vLyB3aWxsIGdvIHRoZSBvbGQgcm91dGUgLSB3aWxsIHRyeSB0byBjb29rIHN0YW5kYXJkIGRhdGF2ZXJzZSB1cmxzIFxuLy8gZm9yIGJvdGggdGhlIGRhdGEgYW5kIG1ldGFkYXRhLCBpZiB0aGUgZmlsZSBpZCBpcyBzdXBwbGllZDsgb3IgdGhlIFxuLy8gbG9jYWwgZmlsZXMgaWYgbm90aGluZyBpcyBzdXBwbGllZC4gXG4vLyAtLSBMLkEuXG5cblxudmFyIHByb2R1Y3Rpb249ZmFsc2U7XG52YXIgcHJpdj1mYWxzZTtcblxuaWYocHJvZHVjdGlvbiAmJiBmaWxlaWQ9PVwiXCIpIHtcbiAgICBhbGVydChcIkVycm9yOiBObyBmaWxlaWQgaGFzIGJlZW4gcHJvdmlkZWQuXCIpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yOiBObyBmaWxlaWQgaGFzIGJlZW4gcHJvdmlkZWQuXCIpO1xufVxuXG52YXIgZGF0YXZlcnNldXJsPVwiXCI7XG5cbmlmIChob3N0bmFtZSkge1xuICAgIGRhdGF2ZXJzZXVybD1cImh0dHBzOi8vXCIraG9zdG5hbWU7XG59IGVsc2Uge1xuICAgIGlmIChwcm9kdWN0aW9uKSB7XG4gICAgICAgIGRhdGF2ZXJzZXVybD1cIiVQUk9EVUNUSU9OX0RBVEFWRVJTRV9VUkwlXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YXZlcnNldXJsPVwiaHR0cDovL2xvY2FsaG9zdDo4MDgwXCI7XG4gICAgfVxufVxuXG5pZiAoZmlsZWlkICYmICFkYXRhdXJsKSB7XG4gICAgLy8gZmlsZSBpZCBzdXBwbGllZDsgd2UgYXJlIGdvaW5nIHRvIGFzc3VtZSB0aGF0IHdlIGFyZSBkZWFsaW5nIHdpdGhcbiAgICAvLyBhIGRhdGF2ZXJzZSBhbmQgY29vayBhIHN0YW5kYXJkIGRhdGF2ZXJzZSBkYXRhIGFjY2VzcyB1cmwsXG4gICAgLy8gd2l0aCB0aGUgZmlsZWlkIHN1cHBsaWVkIGFuZCB0aGUgaG9zdG5hbWUgd2UgaGF2ZVxuICAgIC8vIGVpdGhlciBzdXBwbGllZCBvciBjb25maWd1cmVkOlxuICAgIGRhdGF1cmwgPSBkYXRhdmVyc2V1cmwrXCIvYXBpL2FjY2Vzcy9kYXRhZmlsZS9cIitmaWxlaWQ7XG4gICAgZGF0YXVybCA9IGRhdGF1cmwrXCI/a2V5PVwiK2FwaWtleTtcbiAgICAvLyAoaXQgaXMgYWxzbyBwb3NzaWJsZSB0byBzdXBwbHkgZGF0YXVybCB0byB0aGUgc2NyaXB0IGRpcmVjdGx5LCBcbiAgICAvLyBhcyBhbiBhcmd1bWVudCAtLSBMLkEuKVxufVxuXG5pZiAoIXByb2R1Y3Rpb24pIHtcbiAgICAvLyBiYXNlIFVSTCBmb3IgdGhlIFIgYXBwczpcbiAgICB2YXIgcmFwcFVSTCA9IFwiaHR0cDovLzAuMC4wLjA6ODAwMC9jdXN0b20vXCI7XG59IGVsc2Uge1xuICAgIHZhciByYXBwVVJMID0gXCJodHRwczovL2JldGEuZGF0YXZlcnNlLm9yZy9jdXN0b20vXCI7IC8vdGhpcyB3aWxsIGNoYW5nZSB3aGVuL2lmIHRoZSBwcm9kdWN0aW9uIGhvc3QgY2hhbmdlc1xufVxuXG4vLyBzcGFjZSBpbmRleFxudmFyIG15c3BhY2UgPSAwO1xudmFyIHN2ZyA9IGQzLnNlbGVjdChcIiNtYWluLmxlZnQgZGl2LmNhcm91c2VsLWlubmVyXCIpLmF0dHIoJ2lkJywgJ2lubmVyY2Fyb3VzZWwnKVxuLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCAnaXRlbSBhY3RpdmUnKS5hdHRyKCdpZCcsICdtMCcpLmFwcGVuZCgnc3ZnJykuYXR0cignaWQnLCAnd2hpdGVzcGFjZScpO1xuXG52YXIgbG9nQXJyYXkgPSBbXTtcblxuICAgICAgICAgICBcbi8vLmF0dHIoJ3dpZHRoJywgd2lkdGgpXG4vLy5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpO1xudmFyIHRlbXBXaWR0aCA9IGQzLnNlbGVjdChcIiNtYWluLmxlZnRcIikuc3R5bGUoXCJ3aWR0aFwiKVxudmFyIHdpZHRoID0gdGVtcFdpZHRoLnN1YnN0cmluZygwLCh0ZW1wV2lkdGgubGVuZ3RoLTIpKTtcblxuLyp2YXIgdGVtcEhlaWdodCA9IGQzLnNlbGVjdChcIiNtYWluLmxlZnRcIikuc3R5bGUoXCJoZWlnaHRcIilcbnZhciBoZWlnaHQgPSB0ZW1wSGVpZ2h0LnN1YnN0cmluZygwLCh0ZW1wSGVpZ2h0Lmxlbmd0aC0yKSk7Ki9cblxudmFyIGhlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKSAtMTIwOyAgLy8gSGFyZCBjb2RpbmcgZm9yIGhlYWRlciBhbmQgZm9vdGVyIGFuZCBib3R0b20gbWFyZ2luLlxuXG5cbnZhciBmb3JjZXRvZ2dsZT1bXCJ0cnVlXCJdO1xudmFyIGVzdGltYXRlZD1mYWxzZTtcbnZhciBlc3RpbWF0ZUxhZGRhID0gTGFkZGEuY3JlYXRlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnRuRXN0aW1hdGVcIikpO1xudmFyIHNlbGVjdExhZGRhID0gTGFkZGEuY3JlYXRlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnRuU2VsZWN0XCIpKTtcbnZhciByaWdodENsaWNrTGFzdCA9IGZhbHNlO1xuXG5cbi8vIHRoaXMgaXMgdGhlIGluaXRpYWwgY29sb3Igc2NhbGUgdGhhdCBpcyB1c2VkIHRvIGVzdGFibGlzaCB0aGUgaW5pdGlhbCBjb2xvcnMgb2YgdGhlIG5vZGVzLiAgYWxsTm9kZXMucHVzaCgpIGJlbG93IGVzdGFibGlzaGVzIGEgZmllbGQgZm9yIHRoZSBtYXN0ZXIgbm9kZSBhcnJheSBhbGxOb2RlcyBjYWxsZWQgXCJub2RlQ29sXCIgYW5kIGFzc2lnbnMgYSBjb2xvciBmcm9tIHRoaXMgc2NhbGUgdG8gdGhhdCBmaWVsZC4gIGV2ZXJ5dGhpbmcgdGhlcmUgYWZ0ZXIgc2hvdWxkIHJlZmVyIHRvIHRoZSBub2RlQ29sIGFuZCBub3QgdGhlIGNvbG9yIHNjYWxlLCB0aGlzIGVuYWJsZXMgdXMgdG8gdXBkYXRlIGNvbG9ycyBhbmQgcGFzcyB0aGUgdmFyaWFibGUgdHlwZSB0byBSIGJhc2VkIG9uIGl0cyBjb2xvcmluZ1xudmFyIGNvbG9ycyA9IGQzLnNjYWxlLmNhdGVnb3J5MjAoKTtcblxudmFyIGNvbG9yVGltZT1mYWxzZTtcbnZhciB0aW1lQ29sb3IgPSAnIzJkNmNhMic7XG5cbnZhciBjb2xvckNTPWZhbHNlO1xudmFyIGNzQ29sb3IgPSAnIzQxOTY0MSc7XG5cbnZhciBkZXBWYXI9ZmFsc2U7XG52YXIgZHZDb2xvciA9ICcjMjhhNGM5JztcblxudmFyIG5vbUNvbG9yID0gJyNmZjY2MDAnO1xuXG52YXIgc3Vic2V0ZGl2PWZhbHNlO1xudmFyIHNldHhkaXY9ZmFsc2U7XG5cblxudmFyIHZhckNvbG9yID0gJyNmMGY4ZmYnOyAgIC8vZDMucmdiKFwiYWxpY2VibHVlXCIpO1xudmFyIHNlbFZhckNvbG9yID0gJyNmYTgwNzInOyAgICAvL2QzLnJnYihcInNhbG1vblwiKTtcbnZhciB0YWdnZWRDb2xvciA9ICcjZjVmNWY1JzsgICAgLy9kMy5yZ2IoXCJ3aGl0ZXNtb2tlXCIpO1xudmFyIGQzQ29sb3IgPSAnIzFmNzdiNCc7ICAvLyBkMydzIGRlZmF1bHQgYmx1ZVxudmFyIGdyYXlDb2xvciA9ICcjYzBjMGMwJztcblxudmFyIGxlZnR0YWIgPSBcInRhYjFcIjsgLy9nbG9iYWwgZm9yIGN1cnJlbnQgdGFiIGluIGxlZnQgcGFuZWxcbnZhciByaWdodHRhYiA9IFwiYnRuTW9kZWxzXCI7IC8vIGdsb2JhbCBmb3IgY3VycmVudCB0YWIgaW4gcmlnaHQgcGFuZWxcblxudmFyIHpwYXJhbXMgPSB7IHpkYXRhOltdLCB6ZWRnZXM6W10sIHp0aW1lOltdLCB6bm9tOltdLCB6Y3Jvc3M6W10sIHptb2RlbDpcIlwiLCB6dmFyczpbXSwgemR2OltdLCB6ZGF0YXVybDpcIlwiLCB6c3Vic2V0OltdLCB6c2V0eDpbXSwgem1vZGVsY291bnQ6MCwgenBsb3Q6W10sIHpzZXNzaW9uaWQ6XCJcIiwgemRhdGFjaXRlOlwiXCJ9O1xuXG5cbi8vIFJhZGl1cyBvZiBjaXJjbGVcbnZhciBhbGxSID0gNDA7XG5cbi8vV2lkdGggYW5kIGhlaWdodCBmb3IgaGlzdGdyYW1zXG52YXIgYmFyd2lkdGggPSAxLjMqYWxsUjtcbnZhciBiYXJoZWlnaHQgPSAwLjUqYWxsUjtcbnZhciBiYXJQYWRkaW5nID0gMC4zNTtcbnZhciBiYXJudW1iZXIgPTc7XG5cblxudmFyIGFyYzAgPSBkMy5zdmcuYXJjKClcbi5pbm5lclJhZGl1cyhhbGxSICsgNSlcbi5vdXRlclJhZGl1cyhhbGxSICsgMjApXG4uc3RhcnRBbmdsZSgwKVxuLmVuZEFuZ2xlKDMuMik7XG5cbnZhciBhcmMxID0gZDMuc3ZnLmFyYygpXG4uaW5uZXJSYWRpdXMoYWxsUiArIDUpXG4ub3V0ZXJSYWRpdXMoYWxsUiArIDIwKVxuLnN0YXJ0QW5nbGUoMClcbi5lbmRBbmdsZSgxKTtcblxudmFyIGFyYzIgPSBkMy5zdmcuYXJjKClcbi5pbm5lclJhZGl1cyhhbGxSICsgNSlcbi5vdXRlclJhZGl1cyhhbGxSICsgMjApXG4uc3RhcnRBbmdsZSgxLjEpXG4uZW5kQW5nbGUoMi4yKTtcblxudmFyIGFyYzMgPSBkMy5zdmcuYXJjKClcbi5pbm5lclJhZGl1cyhhbGxSICsgNSlcbi5vdXRlclJhZGl1cyhhbGxSICsgMjApXG4uc3RhcnRBbmdsZSgyLjMpXG4uZW5kQW5nbGUoMy4zKTtcblxudmFyIGFyYzQgPSBkMy5zdmcuYXJjKClcbi5pbm5lclJhZGl1cyhhbGxSICsgNSlcbi5vdXRlclJhZGl1cyhhbGxSICsgMjApXG4uc3RhcnRBbmdsZSg0LjMpXG4uZW5kQW5nbGUoNS4zKTtcblxuXG5cbi8vIEZyb20gLmNzdlxudmFyIGRhdGFzZXQyID0gW107XG52YXIgdmFsdWVLZXkgPSBbXTtcbnZhciBsYWJsQXJyYXkgPSBbXTtcbnZhciBob2xkID0gW107XG52YXIgYWxsTm9kZXMgPSBbXTtcbnZhciBhbGxSZXN1bHRzID0gW107XG52YXIgc3Vic2V0Tm9kZXMgPSBbXTtcbnZhciBsaW5rcyA9IFtdO1xudmFyIG5vZGVzID0gW107XG52YXIgdHJhbnNmb3JtVmFyID0gXCJcIjtcbnZhciBzdW1tYXJ5SG9sZCA9IGZhbHNlO1xudmFyIHNlbEludGVyYWN0ID0gZmFsc2U7XG52YXIgbW9kZWxDb3VudCA9IDA7XG52YXIgY2FsbEhpc3RvcnkgPSBbXTsgLy8gdW5pcXVlIHRvIHRoZSBzcGFjZS4gc2F2ZXMgdHJhbnNmb3JtIGFuZCBzdWJzZXQgY2FsbHMuXG52YXIgY2l0ZXRvZ2dsZSA9IGZhbHNlO1xuXG5cbi8vIHRyYW5zZm9ybWF0aW9uIHRvb2xiYXIgb3B0aW9uc1xudmFyIHRyYW5zZm9ybUxpc3QgPSBbXCJsb2coZClcIiwgXCJleHAoZClcIiwgXCJkXjJcIiwgXCJzcXJ0KGQpXCIsIFwiaW50ZXJhY3QoZCxlKVwiXTtcblxuLy8gYXJyeSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYWxsTm9kZSwgenBhcmFtcywgdHJhbnNmb3JtIHZhcnNcbnZhciBzcGFjZXMgPSBbXTtcbnZhciB0cmFucyA9IFtdOyAvL3ZhciBsaXN0IGZvciBlYWNoIHNwYWNlIGNvbnRhaW4gdmFyaWFibGVzIGluIG9yaWdpbmFsIGRhdGEgcGx1cyB0cmFucyBpbiB0aGF0IHNwYWNlXG5cbi8vIGVuZCBvZiAobW9zdCkgZ2xvYmFsIGRlY2xhcmF0aW9ucyAobWludXMgZnVuY3Rpb25zKVxuXG5cbi8vIGNvbGxhcHNhYmxlIHVzZXIgbG9nXG4kKCcjY29sbGFwc2VMb2cnKS5vbignc2hvd24uYnMuY29sbGFwc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgICAgICAgICAgLmRhdGEobG9nQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgIC8vJChcIiNsb2dpY29uXCIpLnJlbW92ZUNsYXNzKFwiZ2x5cGhpY29uLWNoZXZyb24tdXBcIikuYWRkQ2xhc3MoXCJnbHlwaGljb24tY2hldnJvbi1kb3duXCIpO1xuICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiQoJyNjb2xsYXBzZUxvZycpLm9uKCdoaWRkZW4uYnMuY29sbGFwc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgLy8kKFwiI2xvZ2ljb25cIikucmVtb3ZlQ2xhc3MoXCJnbHlwaGljb24tY2hldnJvbi1kb3duXCIpLmFkZENsYXNzKFwiZ2x5cGhpY29uLWNoZXZyb24tdXBcIik7XG4gICAgICAgICAgICAgICAgICAgICB9KTtcblxuXG4vLyB0ZXh0IGZvciB0aGUgYWJvdXQgYm94XG4vLyBub3RlIHRoYXQgLnRleHRDb250ZW50IGlzIHRoZSBuZXcgd2F5IHRvIHdyaXRlIHRleHQgdG8gYSBkaXZcbiQoJyNhYm91dCBkaXYucGFuZWwtYm9keScpLnRleHQoJ1R3b1JhdmVucyB2MC4xIFwiRGFsbGFzXCIgLS0gVGhlIE5vcnNlIGdvZCBPZGluIGhhZCB0d28gdGFsa2luZyByYXZlbnMgYXMgYWR2aXNvcnMsIHdobyB3b3VsZCBmbHkgb3V0IGludG8gdGhlIHdvcmxkIGFuZCByZXBvcnQgYmFjayBhbGwgdGhleSBvYnNlcnZlZC4gIEluIHRoZSBOb3JzZSwgdGhlaXIgbmFtZXMgd2VyZSBcIlRob3VnaHRcIiBhbmQgXCJNZW1vcnlcIi4gIEluIG91ciBjb21pbmcgcmVsZWFzZSwgb3VyIHRob3VnaHQtcmF2ZW4gYXV0b21hdGljYWxseSBhZHZpc2VzIG9uIHN0YXRpc3RpY2FsIG1vZGVsIHNlbGVjdGlvbiwgd2hpbGUgb3VyIG1lbW9yeS1yYXZlbiBhY2N1bXVsYXRlcyBwcmV2aW91cyBzdGF0aXN0aWNhbCBtb2RlbHMgZnJvbSBEYXRhdmVyc2UsIHRvIHByb3ZpZGUgY3VtbXVsYXRpdmUgZ3VpZGFuY2UgYW5kIG1ldGEtYW5hbHlzaXMuJyk7IC8vVGhpcyBpcyB0aGUgZmlyc3QgcHVibGljIHJlbGVhc2Ugb2YgYSBuZXcsIGludGVyYWN0aXZlIFdlYiBhcHBsaWNhdGlvbiB0byBleHBsb3JlIGRhdGEsIHZpZXcgZGVzY3JpcHRpdmUgc3RhdGlzdGljcywgYW5kIGVzdGltYXRlIHN0YXRpc3RpY2FsIG1vZGVscy5cIjtcblxuXG5cblxuLy9cbi8vIHJlYWQgRERJIG1ldGFkYXRhIHdpdGggZDM6XG52YXIgbWV0YWRhdGF1cmwgPSBcIlwiO1xuaWYgKGRkaXVybCkge1xuICAgIC8vIGEgY29tcGxldGUgZGRpdXJsIGlzIHN1cHBsaWVkOlxuICAgIG1ldGFkYXRhdXJsPWRkaXVybDtcbn0gZWxzZSBpZiAoZmlsZWlkKSB7XG4gICAgLy8gZmlsZSBpZCBzdXBwbGllZDsgd2UncmUgZ29pbmcgdG8gY29vayBhIHN0YW5kYXJkIGRhdGF2ZXJzZVxuICAgIC8vIG1ldGFkYXRhIHVybCwgd2l0aCB0aGUgZmlsZSBpZCBwcm92aWRlZCBhbmQgdGhlIGhvc3RuYW1lXG4gICAgLy8gc3VwcGxpZWQgb3IgY29uZmlndXJlZDpcbiAgICBtZXRhZGF0YXVybD1kYXRhdmVyc2V1cmwrXCIvYXBpL21ldGEvZGF0YWZpbGUvXCIrZmlsZWlkO1xufSBlbHNlIHtcbiAgICAvLyBuZWl0aGVyIGEgZnVsbCBkZGkgdXJsLCBub3IgZmlsZSBpZCBzdXBwbGllZDsgdXNlIG9uZSBvZiB0aGUgc2FtcGxlIERESXMgdGhhdCBjb21lIHdpdGhcbiAgICAvLyB0aGUgYXBwLCBpbiB0aGUgZGF0YSBkaXJlY3Rvcnk6XG4gICAgLy8gbWV0YWRhdGF1cmw9XCJkYXRhL3FvZzEzNy54bWxcIjsgLy8gcXVhbGl0eSBvZiBnb3Zlcm5tZW50XG4gICAgLy9tZXRhZGF0YXVybD1cImRhdGEvZmVhcm9uTGFpdGluLnhtbFwiOyAvLyBUaGlzIGlzIEZlYXJvbiBMYWl0aW5cbiAgICBtZXRhZGF0YXVybD1cImRhdGEvUFVNUzVzbWFsbC1kZGkueG1sXCI7IC8vIFRoaXMgaXMgQ2FsaWZvcm5pYSBQVU1TIHN1YnNldFxuICAgIC8vbWV0YWRhdGF1cmw9XCJkYXRhL0JQLmZvcm1hdHRlZC1kZGkueG1sXCI7XG4gICAgLy9tZXRhZGF0YXVybD1cImRhdGEvRkxfaW5zdXJhbmNlX3NhbXBsZS1kZGkueG1sXCI7XG4gICAgLy9tZXRhZGF0YXVybD1cImRhdGEvc3RyZXpobmV2X3ZvZXRlbl8yMDEzLnhtbFwiOyAgIC8vIFRoaXMgaXMgU3RyZXpobmV2IFZvZXRlblxuICAgIC8vbWV0YWRhdGF1cmw9XCJkYXRhLzE5LnhtbFwiOyAvLyBGZWFyb24gZnJvbSBEVk4gRGVtb1xuICAgIC8vbWV0YWRhdGF1cmw9XCJkYXRhLzc2LnhtbFwiOyAvLyBDb2xsaWVyIGZyb20gRFZOIERlbW9cbiAgICAvL21ldGFkYXRhdXJsPVwiZGF0YS83OS54bWxcIjsgLy8gdHdvIHZhcnMgZnJvbSBEVk4gRGVtb1xuICAgIC8vbWV0YWRhdGF1cmw9XCJkYXRhLzAwMC54bWxcIjsgLy8gb25lIHZhciBpbiBtZXRhZGF0YVxuICAgIC8vbWV0YWRhdGF1cmw9XCJkYXRhLzAwMDAueG1sXCI7IC8vIHplcm8gdmFycyBpbiBtZXRhZGF0YVxufVxuXG4vLyBSZWFkaW5nIHRoZSBwcmUtcHJvY2Vzc2VkIG1ldGFkYXRhOlxuLy8gUHJlLXByb2Nlc3NlZCBkYXRhOlxudmFyIHBVUkwgPSBcIlwiO1xuaWYgKGRhdGF1cmwpIHtcbiAgICAvLyBkYXRhIHVybCBpcyBzdXBwbGllZFxuICAgIHBVUkwgPSBkYXRhdXJsK1wiJmZvcm1hdD1wcmVwXCI7XG59IGVsc2Uge1xuICAgIC8vIG5vIGRhdGF1cmwvZmlsZSBpZCBzdXBwbGllZDsgdXNlIG9uZSBvZiB0aGUgc2FtcGxlIGRhdGEgZmlsZXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGVcbiAgICAvLyBhcHAgaW4gdGhlIFwiZGF0YVwiIGRpcmVjdG9yeTpcbiAgICAvL3BVUkwgPSBcImRhdGEvcHJlcHJvY2VzczI0MjkzNjAudHh0XCI7ICAgLy8gVGhpcyBpcyB0aGUgU3RyZXpobmV2IFZvZXRlbiBKU09OIGRhdGFcbiAgIC8vIHBVUkwgPSBcImRhdGEvZmVhcm9uTGFpdGluLmpzb25cIjsgICAgIC8vIFRoaXMgaXMgdGhlIEZlYXJvbiBMYWl0aW4gSlNPTiBkYXRhXG4gICAgLy9wVVJMID0gXCJkYXRhL2ZlYXJvbkxhaXRpbk5ld1ByZXByb2Nlc3MzbG9uZy5qc29uXCI7ICAgICAvLyBUaGlzIGlzIHRoZSByZXZpc2VkIChNYXkgMjksIDIwMTUpIEZlYXJvbiBMYWl0aW4gSlNPTiBkYXRhXG4gICAgcFVSTCA9IFwiZGF0YS9wcmVwcm9jZXNzUFVNUzVzbWFsbC5qc29uXCI7ICAgLy8gVGhpcyBpcyBDYWxpZm9ybmlhIFBVTVMgc3Vic2V0XG4gICAgLy9wVVJMID0gXCJkYXRhL0ZMX2luc3VyYW5jZV9zYW1wbGUudGFiLmpzb25cIjtcblxuICAgIC8vIHBVUkwgPSBcImRhdGEvcW9nX3BwLmpzb25cIjsgICAvLyBUaGlzIGlzIFF1YWwgb2YgR292XG59XG5cbnZhciBwcmVwcm9jZXNzID0ge307XG52YXIgbW9kcyA9IG5ldyBPYmplY3Q7XG5cbi8vIHRoaXMgaXMgdGhlIGZ1bmN0aW9uIGFuZCBjYWxsYmFjayByb3V0aW5lIHRoYXQgbG9hZHMgYWxsIGV4dGVybmFsIGRhdGE6IG1ldGFkYXRhIChEVk4ncyBkZGkpLCBwcmVwcm9jZXNzZWQgKGZvciBwbG90dGluZyBkaXN0cmlidXRpb25zKSwgYW5kIHplbGlnbW9kZWxzIChwcm9kdWNlZCBieSBaZWxpZykgYW5kIGluaXRpYXRlcyB0aGUgZGF0YSBkb3dubG9hZCB0byB0aGUgc2VydmVyXG5yZWFkUHJlcHJvY2Vzcyh1cmw9cFVSTCwgcD1wcmVwcm9jZXNzLCB2PW51bGwsIGNhbGxiYWNrPWZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICBkMy54bWwobWV0YWRhdGF1cmwsIFwiYXBwbGljYXRpb24veG1sXCIsIGZ1bmN0aW9uKHhtbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB2YXJzID0geG1sLmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInZhclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHhtbC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJmaWxlTmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpkYXRhID0gdGVtcFswXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiB0byBjbGVhbiB0aGUgY2l0YXRpb24gc28gdGhhdCB0aGUgUE9TVCBpcyB2YWxpZCBqc29uXG4gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY2xlYW5zdHJpbmcocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcz1zLnJlcGxhY2UoL1xcJi9nLCBcImFuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHM9cy5yZXBsYWNlKC9cXDsvZywgXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcz1zLnJlcGxhY2UoL1xcJS9nLCBcIi1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGNpdGUgPSB4bWwuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYmlibENpdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpkYXRhY2l0ZT1jaXRlWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuemRhdGFjaXRlPWNsZWFuc3RyaW5nKHpwYXJhbXMuemRhdGFjaXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhc2V0IG5hbWUgdHJpbW1lZCB0byAxMiBjaGFyc1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhbmFtZSA9IHpwYXJhbXMuemRhdGEucmVwbGFjZSggL1xcLiguKikvLCBcIlwiKSA7ICAvLyByZWd1bGFyIGV4cHJlc3Npb24gdG8gZHJvcCBhbnkgZmlsZSBleHRlbnNpb25cbiAgICAgICAgICAgICAgICAgICAgICAvLyBQdXQgZGF0YXNldCBuYW1lLCBmcm9tIG1ldGEtZGF0YSwgaW50byB0b3AgcGFuZWxcbiAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjZGF0YU5hbWVcIilcbiAgICAgICAgICAgICAgICAgICAgICAuaHRtbChkYXRhbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgJCgnI2NpdGUgZGl2LnBhbmVsLWJvZHknKS50ZXh0KHpwYXJhbXMuemRhdGFjaXRlKTtcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIFB1dCBkYXRhc2V0IG5hbWUsIGZyb20gbWV0YS1kYXRhLCBpbnRvIHBhZ2UgdGl0bGVcbiAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCJ0aXRsZVwiKS5odG1sKFwiVHdvUmF2ZW5zIFwiICtkYXRhbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAvL2QzLnNlbGVjdChcIiN0aXRsZVwiKS5odG1sKFwiYmxhaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAvLyB0ZW1wb3JhcnkgdmFsdWVzIGZvciBob2xkIHRoYXQgY29ycmVzcG9uZCB0byBoaXN0b2dyYW0gYmluc1xuICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPSBbLjYsIC4yLCAuOSwgLjgsIC4xLCAuMywgLjRdO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBteXZhbHVlcyA9IFswLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkdPVCBIRVJFIEFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codmFycyk7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7aTx2YXJzLmxlbmd0aDtpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUtleVtpXSA9IHZhcnNbaV0uYXR0cmlidXRlcy5uYW1lLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICBpZih2YXJzW2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGFibFwiKS5sZW5ndGggPT09IDApIHtsYWJsQXJyYXlbaV09XCJubyBsYWJlbFwiO31cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtsYWJsQXJyYXlbaV0gPSB2YXJzW2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGFibFwiKVswXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZTt9XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFzZXRjb3VudCA9IGQzLmxheW91dC5oaXN0b2dyYW0oKVxuICAgICAgICAgICAgICAgICAgICAgIC5iaW5zKGJhcm51bWJlcikuZnJlcXVlbmN5KGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgIChteXZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjcmVhdGVzIGFuIG9iamVjdCB0byBiZSBwdXNoZWQgdG8gYWxsTm9kZXMuIHRoaXMgY29udGFpbnMgYWxsIHRoZSBwcmVwcm9jZXNzZWQgZGF0YSB3ZSBoYXZlIGZvciB0aGUgdmFyaWFibGUsIGFzIHdlbGwgYXMgVUkgZGF0YSBwZXJ0aW5lbnQgdG8gdGhhdCB2YXJpYWJsZSwgc3VjaCBhcyBzZXR4IHZhbHVlcyAoaWYgdGhlIHVzZXIgaGFzIHNlbGVjdGVkIHRoZW0pIGFuZCBwZWJibGUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqMSA9IHtpZDppLCByZWZsZXhpdmU6IGZhbHNlLCBcIm5hbWVcIjogdmFsdWVLZXlbaV0sIFwibGFibFwiOiBsYWJsQXJyYXlbaV0sIGRhdGE6IFs1LDE1LDIwLDAsNSwxNSwyMF0sIGNvdW50OiBob2xkLCBcIm5vZGVDb2xcIjpjb2xvcnMoaSksIFwiYmFzZUNvbFwiOmNvbG9ycyhpKSwgXCJzdHJva2VDb2xvclwiOnNlbFZhckNvbG9yLCBcInN0cm9rZVdpZHRoXCI6XCIxXCIsIFwic3Vic2V0cGxvdFwiOmZhbHNlLCBcInN1YnNldHJhbmdlXCI6W1wiXCIsIFwiXCJdLFwic2V0eHBsb3RcIjpmYWxzZSwgXCJzZXR4dmFsc1wiOltcIlwiLCBcIlwiXSwgXCJncmF5b3V0XCI6ZmFsc2V9O1xuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgb2JqMSwgcHJlcHJvY2Vzc1t2YWx1ZUtleVtpXV0pO1xuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHZhcnNbaV0uY2hpbGROb2Rlc1s0XS5hdHRyaWJ1dGVzLnR5cGUub3duZXJFbGVtZW50LmZpcnN0Q2hpbGQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXMucHVzaChvYmoxKTtcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gUmVhZGluZyB0aGUgemVsaWcgbW9kZWxzIGFuZCBwb3B1bGF0aW5nIHRoZSBtb2RlbCBsaXN0IGluIHRoZSByaWdodCBwYW5lbC5cbiAgICAgICAgICAgICAgICAgICAgICBkMy5qc29uKFwiZGF0YS96ZWxpZzVtb2RlbHMuanNvblwiLCBmdW5jdGlvbihlcnJvciwganNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqc29uZGF0YSA9IGpzb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiemVsaWcgbW9kZWxzIGpzb246IFwiLCBqc29uZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGtleSBpbiBqc29uZGF0YS56ZWxpZzVtb2RlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGpzb25kYXRhLnplbGlnNW1vZGVscy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RzW2pzb25kYXRhLnplbGlnNW1vZGVsc1trZXldLm5hbWVbMF1dID0ganNvbmRhdGEuemVsaWc1bW9kZWxzW2tleV0uZGVzY3JpcHRpb25bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQzLmpzb24oXCJkYXRhL3plbGlnNWNob2ljZW1vZGVscy5qc29uXCIsIGZ1bmN0aW9uKGVycm9yLCBqc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqc29uZGF0YSA9IGpzb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiemVsaWcgY2hvaWNlIG1vZGVscyBqc29uOiBcIiwganNvbmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGtleSBpbiBqc29uZGF0YS56ZWxpZzVjaG9pY2Vtb2RlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoanNvbmRhdGEuemVsaWc1Y2hvaWNlbW9kZWxzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kc1tqc29uZGF0YS56ZWxpZzVjaG9pY2Vtb2RlbHNba2V5XS5uYW1lWzBdXSA9IGpzb25kYXRhLnplbGlnNWNob2ljZW1vZGVsc1trZXldLmRlc2NyaXB0aW9uWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWZmb2xkaW5nKGNhbGxiYWNrPWxheW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFEb3dubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGV2ZXJ5dGhpbmcgYmVsb3cgdGhpcyBwb2ludCBpcyBhIGZ1bmN0aW9uXG5cblxuLy8gc2NhZmZvbGRpbmcgaXMgY2FsbGVkIGFmdGVyIGFsbCBleHRlcm5hbCBkYXRhIGFyZSBndWFyYW50ZWVkIHRvIGhhdmUgYmVlbiByZWFkIHRvIGNvbXBsZXRpb24uIHRoaXMgcG9wdWxhdGVzIHRoZSBsZWZ0IHBhbmVsIHdpdGggdmFyaWFibGUgbmFtZXMsIHRoZSByaWdodCBwYW5lbCB3aXRoIG1vZGVsIG5hbWVzLCB0aGUgdHJhbnNmb3JtYXRpb24gdG9vbCwgYW4gdGhlIGFzc29jaWF0ZWQgbW91c2VvdmVycy4gaXRzIGNhbGxiYWNrIGlzIGxheW91dCgpLCB3aGljaCBpbml0aWFsaXplcyB0aGUgbW9kZWxpbmcgc3BhY2VcbmZ1bmN0aW9uIHNjYWZmb2xkaW5nKGNhbGxiYWNrKSB7XG4gXG4gICAgLy8gZXN0YWJsaXNoaW5nIHRoZSB0cmFuc2Zvcm1hdGlvbiBlbGVtZW50XG4gICAgZDMuc2VsZWN0KFwiI3RyYW5zZm9ybWF0aW9uc1wiKVxuICAgIC5hcHBlbmQoXCJpbnB1dFwiKVxuICAgIC5hdHRyKFwiaWRcIiwgXCJ0SW5wdXRcIilcbiAgICAuYXR0cihcImNsYXNzXCIsIFwiZm9ybS1jb250cm9sXCIpXG4gICAgLmF0dHIoXCJ0eXBlXCIsIFwidGV4dFwiKVxuICAgIC5hdHRyKFwidmFsdWVcIiwgXCJWYXJpYWJsZSB0cmFuc2Zvcm1hdGlvblwiKTtcblxuICAgIC8vIHRoZSB2YXJpYWJsZSBkcm9wZG93blxuICAgIGQzLnNlbGVjdChcIiN0cmFuc2Zvcm1hdGlvbnNcIilcbiAgICAuYXBwZW5kKFwidWxcIilcbiAgICAuYXR0cihcImlkXCIsIFwidHJhbnNTZWxcIilcbiAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxuICAgIC5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgdmFyQ29sb3IpXG4gICAgLnNlbGVjdEFsbCgnbGknKVxuICAgIC5kYXRhKFtcImFcIiwgXCJiXCJdKSAvL3NldCB0byB2YXJpYWJsZXMgaW4gbW9kZWwgc3BhY2UgYXMgdGhleSdyZSBhZGRlZFxuICAgIC5lbnRlcigpXG4gICAgLmFwcGVuZChcImxpXCIpXG4gICAgLnRleHQoZnVuY3Rpb24oZCkge3JldHVybiBkOyB9KTtcbiAgICBcbiAgICAvLyB0aGUgZnVuY3Rpb24gZHJvcGRvd25cbiAgICBkMy5zZWxlY3QoXCIjdHJhbnNmb3JtYXRpb25zXCIpXG4gICAgLmFwcGVuZChcInVsXCIpXG4gICAgLmF0dHIoXCJpZFwiLCBcInRyYW5zTGlzdFwiKVxuICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpXG4gICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCB2YXJDb2xvcilcbiAgICAuc2VsZWN0QWxsKCdsaScpXG4gICAgLmRhdGEodHJhbnNmb3JtTGlzdClcbiAgICAuZW50ZXIoKVxuICAgIC5hcHBlbmQoXCJsaVwiKVxuICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtyZXR1cm4gZDsgfSk7XG4gICAgXG4gICAgLy9qcXVlcnkgZG9lcyB0aGlzIHdlbGxcbiAgICAkKCcjdElucHV0JykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RyYW5zU2VsJykuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgaWYodCAhPT0gXCJub25lXCIpIHsgLy8gaWYgdmFyaWFibGUgbGlzdCBpcyBkaXNwbGF5ZWQgd2hlbiBpbnB1dCBpcyBjbGlja2VkLi4uXG4gICAgICAgICAgICAkKCcjdHJhbnNTZWwnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RyYW5zTGlzdCcpLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgIGlmKHQxICE9PSBcIm5vbmVcIikgeyAvLyBpZiBmdW5jdGlvbiBsaXN0IGlzIGRpc3BsYXllZCB3aGVuIGlucHV0IGlzIGNsaWNrZWQuLi5cbiAgICAgICAgICAgICQoJyN0cmFuc0xpc3QnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGhpZ2hsaWdodCB0aGUgdGV4dFxuICAgICAgICAkKHRoaXMpLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgdmFyIHBvcyA9ICQoJyN0SW5wdXQnKS5vZmZzZXQoKTtcbiAgICAgICAgcG9zLnRvcCArPSAkKCcjdElucHV0Jykud2lkdGgoKTtcbiAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZUluKDEwMCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgXG4gICAgJCgnI3RJbnB1dCcpLmtleXVwKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RyYW5zU2VsJykuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RyYW5zTGlzdCcpLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICBpZih0ICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHQxICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyN0cmFuc0xpc3QnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgIGlmKGV2ZW50LmtleUNvZGUgPT0gMTMpeyAvLyBrZXl1cCBvbiBcIkVudGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9ICQoJyN0SW5wdXQnKS52YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRyYW5zUGFyc2Uobj1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0ID09PSBudWxsKSB7cmV0dXJuO31cbiAgICAgICAgICAgICAgIC8vICAgICAgICBjb25zb2xlLmxvZyh0KTtcbiAgICAgICAgICAgICAgICAgLy8gICAgICBjb25zb2xlLmxvZyh0LnNsaWNlKDAsIHQubGVuZ3RoLTEpKTtcbiAgICAgICAgICAgICAgICAgICAvLyAgICBjb25zb2xlLmxvZyh0W3QubGVuZ3RoLTFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obj10LnNsaWNlKDAsIHQubGVuZ3RoLTEpLCB0PXRbdC5sZW5ndGgtMV0sIHR5cGVUcmFuc2Zvcm09ZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICQoJyN0cmFuc0xpc3QgbGknKS5jbGljayhmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHZhciA9ICAkKCcjdElucHV0JykudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpbnRlcmFjdCBpcyBzZWxlY3RlZCwgc2hvdyB2YXJpYWJsZSBsaXN0IGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCQodGhpcykudGV4dCgpID09PSBcImludGVyYWN0KGQsZSlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjdElucHV0JykudmFsKHR2YXIuY29uY2F0KCcqJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxJbnRlcmFjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykucGFyZW50KCkuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjdHJhbnNTZWwnKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGZ1bmMgPSAkKHRoaXMpLnRleHQoKS5yZXBsYWNlKFwiZFwiLCBcIl90cmFuc3ZhcjBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0Y2FsbCA9ICQodGhpcykudGV4dCgpLnJlcGxhY2UoXCJkXCIsIHR2YXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjdElucHV0JykudmFsKHRjYWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuPXR2YXIsIHQ9dGZ1bmMsIHR5cGVUcmFuc2Zvcm09ZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAvLyBwb3B1bGF0aW5nIHRoZSB2YXJpYWJsZSBsaXN0IGluIHRoZSBsZWZ0IHBhbmVsXG4gICAgZDMuc2VsZWN0KFwiI3RhYjFcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgIC5kYXRhKHZhbHVlS2V5KVxuICAgIC5lbnRlcigpXG4gICAgLmFwcGVuZChcInBcIilcbiAgICAuYXR0cihcImlkXCIsZnVuY3Rpb24oZCl7XG4gICAgICAgICAgcmV0dXJuIGQucmVwbGFjZSgvXFxXL2csIFwiX1wiKTsgLy8gcmVwbGFjZSBub24tYWxwaGFudW1lcmljcyBmb3Igc2VsZWN0aW9uIHB1cnBvc2VzXG4gICAgICAgICAgfSkgLy8gcGVyaGFwc2UgZW5zdXJlIHRoaXMgaWQgaXMgdW5pcXVlIGJ5IGFkZGluZyAnXycgdG8gdGhlIGZyb250P1xuICAgIC50ZXh0KGZ1bmN0aW9uKGQpe3JldHVybiBkO30pXG4gICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJyxmdW5jdGlvbihkKSB7XG4gICAgICAgICAgIGlmKGZpbmROb2RlSW5kZXgoZCkgPiAyKSB7cmV0dXJuIHZhckNvbG9yO31cbiAgICAgICAgICAgZWxzZSB7cmV0dXJuIGhleFRvUmdiYShzZWxWYXJDb2xvcik7fVxuICAgICAgICAgICB9KVxuICAgIC5hdHRyKFwiZGF0YS1jb250YWluZXJcIiwgXCJib2R5XCIpXG4gICAgLmF0dHIoXCJkYXRhLXRvZ2dsZVwiLCBcInBvcG92ZXJcIilcbiAgICAuYXR0cihcImRhdGEtdHJpZ2dlclwiLCBcImhvdmVyXCIpXG4gICAgLmF0dHIoXCJkYXRhLXBsYWNlbWVudFwiLCBcInJpZ2h0XCIpXG4gICAgLmF0dHIoXCJkYXRhLWh0bWxcIiwgXCJ0cnVlXCIpXG4gICAgLmF0dHIoXCJvbm1vdXNlb3ZlclwiLCBcIiQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XCIpXG4gICAgLmF0dHIoXCJvbm1vdXNlb3V0XCIsIFwiJCh0aGlzKS5wb3BvdmVyKCd0b2dnbGUnKTtcIilcbiAgICAuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIiwgXCJTdW1tYXJ5IFN0YXRpc3RpY3NcIik7XG4gICAgXG4gICAgZDMuc2VsZWN0KFwiI21vZGVsc1wiKVxuICAgIC5zdHlsZSgnaGVpZ2h0JywgMjAwMClcbiAgICAuc3R5bGUoJ292ZXJmaWxsJywgJ3Njcm9sbCcpO1xuICAgIFxuICAgIHZhciBtb2RlbGxpc3QgPSBPYmplY3Qua2V5cyhtb2RzKTtcbiAgICBcbiAgICBkMy5zZWxlY3QoXCIjbW9kZWxzXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAuZGF0YShtb2RlbGxpc3QpXG4gICAgLmVudGVyKClcbiAgICAuYXBwZW5kKFwicFwiKVxuICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZCl7XG4gICAgICAgICAgcmV0dXJuIFwiX21vZGVsX1wiLmNvbmNhdChkKTtcbiAgICAgICAgICB9KVxuICAgIC50ZXh0KGZ1bmN0aW9uKGQpe3JldHVybiBkO30pXG4gICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJyxmdW5jdGlvbihkKSB7XG4gICAgICAgICAgIHJldHVybiB2YXJDb2xvcjtcbiAgICAgICAgICAgfSlcbiAgICAuYXR0cihcImRhdGEtY29udGFpbmVyXCIsIFwiYm9keVwiKVxuICAgIC5hdHRyKFwiZGF0YS10b2dnbGVcIiwgXCJwb3BvdmVyXCIpXG4gICAgLmF0dHIoXCJkYXRhLXRyaWdnZXJcIiwgXCJob3ZlclwiKVxuICAgIC5hdHRyKFwiZGF0YS1wbGFjZW1lbnRcIiwgXCJ0b3BcIilcbiAgICAuYXR0cihcImRhdGEtaHRtbFwiLCBcInRydWVcIilcbiAgICAuYXR0cihcIm9ubW91c2VvdmVyXCIsIFwiJCh0aGlzKS5wb3BvdmVyKCd0b2dnbGUnKTtcIilcbiAgICAuYXR0cihcIm9ubW91c2VvdXRcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgIC5hdHRyKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiLCBcIk1vZGVsIERlc2NyaXB0aW9uXCIpXG4gICAgLmF0dHIoXCJkYXRhLWNvbnRlbnRcIiwgZnVuY3Rpb24oZCl7XG4gICAgICAgICAgcmV0dXJuIG1vZHNbZF07XG4gICAgICAgICAgfSk7XG4gICAgXG4gICAgaWYodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2soKTsgLy8gdGhpcyBjYWxscyBsYXlvdXQoKSBiZWNhdXNlIGF0IHRoaXMgcG9pbnQgYWxsIHNjYWZmb2xkaW5nIGlzIHVwIGFuZCByZWFkeVxuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBsYXlvdXQodikge1xuICAgIHZhciBteVZhbHVlcz1bXTtcbiAgICBub2RlcyA9IFtdO1xuICAgIGxpbmtzID0gW107XG4gICAgXG4gICAgaWYodiA9PT0gXCJhZGRcIiB8IHYgPT09IFwibW92ZVwiKSB7XG4gICAgICAgIGQzLnNlbGVjdChcIiN0YWIxXCIpLnNlbGVjdEFsbChcInBcIikuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLHZhckNvbG9yKTtcbiAgICAgICAgZm9yKHZhciBqID0wOyBqIDwgenBhcmFtcy56dmFycy5sZW5ndGg7IGorKyApIHtcbiAgICAgICAgICAgIHZhciBpaSA9IGZpbmROb2RlSW5kZXgoenBhcmFtcy56dmFyc1tqXSk7XG4gICAgICAgICAgICBpZihhbGxOb2Rlc1tpaV0uZ3JheW91dCkge2NvbnRpbnVlO31cbiAgICAgICAgICAgIG5vZGVzLnB1c2goYWxsTm9kZXNbaWldKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RNZSA9IHpwYXJhbXMuenZhcnNbal0ucmVwbGFjZSgvXFxXL2csIFwiX1wiKTtcbiAgICAgICAgICAgIHNlbGVjdE1lID0gXCIjXCIuY29uY2F0KHNlbGVjdE1lKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSkuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZXhUb1JnYmEobm9kZXNbal0uc3Ryb2tlQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgZm9yKHZhciBqPTA7IGogPCB6cGFyYW1zLnplZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIG15c3JjID0gbm9kZUluZGV4KHpwYXJhbXMuemVkZ2VzW2pdWzBdKTtcbiAgICAgICAgICAgIHZhciBteXRndCA9IG5vZGVJbmRleCh6cGFyYW1zLnplZGdlc1tqXVsxXSk7XG4gICAgICAgICAgICBsaW5rcy5wdXNoKHtzb3VyY2U6bm9kZXNbbXlzcmNdLCB0YXJnZXQ6bm9kZXNbbXl0Z3RdLCBsZWZ0OmZhbHNlLCByaWdodDp0cnVlfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmKGFsbE5vZGVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW2FsbE5vZGVzWzBdLCBhbGxOb2Rlc1sxXSwgYWxsTm9kZXNbMl1dO1xuICAgICAgICAgICAgbGlua3MgPSBbXG4gICAgICAgICAgICAgICAge3NvdXJjZTogbm9kZXNbMV0sIHRhcmdldDogbm9kZXNbMF0sIGxlZnQ6IGZhbHNlLCByaWdodDogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgIHtzb3VyY2U6IG5vZGVzWzBdLCB0YXJnZXQ6IG5vZGVzWzJdLCBsZWZ0OiBmYWxzZSwgcmlnaHQ6IHRydWUgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihhbGxOb2Rlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW2FsbE5vZGVzWzBdLCBhbGxOb2Rlc1sxXV07XG4gICAgICAgICAgICBsaW5rcyA9IFt7c291cmNlOiBub2Rlc1sxXSwgdGFyZ2V0OiBub2Rlc1swXSwgbGVmdDogZmFsc2UsIHJpZ2h0OiB0cnVlIH1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoYWxsTm9kZXMubGVuZ3RoID09PSAxKXtcbiAgICAgICAgICAgIG5vZGVzID0gW2FsbE5vZGVzWzBdXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiVGhlcmUgYXJlIHplcm8gdmFyaWFibGVzIGluIHRoZSBtZXRhZGF0YS5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcGFuZWxQbG90cygpOyAvLyBhZnRlciBub2RlcyBpcyBwb3B1bGF0ZWQsIGFkZCBzdWJzZXQgYW5kIHNldHggcGFuZWxzXG4gICAgcG9wdWxhdGVQb3BvdmVyKCk7IC8vIHBpcGVzIGluIHRoZSBzdW1tYXJ5IHN0YXRzIHNob3duIG9uIG1vdXNlb3ZlcnNcbiAgICBcbiAgICBcbiAgICAvLyBpbml0IEQzIGZvcmNlIGxheW91dFxuICAgICAgICB2YXIgZm9yY2UgPSBkMy5sYXlvdXQuZm9yY2UoKVxuICAgICAgICAubm9kZXMobm9kZXMpXG4gICAgICAgIC5saW5rcyhsaW5rcylcbiAgICAgICAgLnNpemUoW3dpZHRoLCBoZWlnaHRdKVxuICAgICAgICAubGlua0Rpc3RhbmNlKDE1MClcbiAgICAgICAgLmNoYXJnZSgtODAwKVxuICAgICAgICAub24oJ3RpY2snLHRpY2spOyAgLy8gLnN0YXJ0KCkgaXMgaW1wb3J0YW50IHRvIGluaXRpYWxpemUgdGhlIGxheW91dFxuICBcbiAgICAgICAgLy8gZGVmaW5lIGFycm93IG1hcmtlcnMgZm9yIGdyYXBoIGxpbmtzXG4gICAgICAgIHN2Zy5hcHBlbmQoJ3N2ZzpkZWZzJykuYXBwZW5kKCdzdmc6bWFya2VyJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2VuZC1hcnJvdycpXG4gICAgICAgIC5hdHRyKCd2aWV3Qm94JywgJzAgLTUgMTAgMTAnKVxuICAgICAgICAuYXR0cigncmVmWCcsIDYpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDMpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCAzKVxuICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxuICAgICAgICAuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgIC5hdHRyKCdkJywgJ00wLC01TDEwLDBMMCw1JylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJyMwMDAnKTtcbiAgICAgICAgXG4gICAgICAgIHN2Zy5hcHBlbmQoJ3N2ZzpkZWZzJykuYXBwZW5kKCdzdmc6bWFya2VyJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ3N0YXJ0LWFycm93JylcbiAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCAnMCAtNSAxMCAxMCcpXG4gICAgICAgIC5hdHRyKCdyZWZYJywgNClcbiAgICAgICAgLmF0dHIoJ21hcmtlcldpZHRoJywgMylcbiAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDMpXG4gICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXG4gICAgICAgIC5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTEwLC01TDAsMEwxMCw1JylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJyMwMDAnKTtcblxuICAgICAgICAvLyBsaW5lIGRpc3BsYXllZCB3aGVuIGRyYWdnaW5nIG5ldyBub2Rlc1xuICAgICAgICB2YXIgZHJhZ19saW5lID0gc3ZnLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluayBkcmFnbGluZSBoaWRkZW4nKVxuICAgICAgICAuYXR0cignZCcsICdNMCwwTDAsMCcpO1xuICAgICAgICBcbiAgICAgICAgLy8gaGFuZGxlcyB0byBsaW5rIGFuZCBub2RlIGVsZW1lbnQgZ3JvdXBzXG4gICAgICAgIHZhciBwYXRoID0gc3ZnLmFwcGVuZCgnc3ZnOmcnKS5zZWxlY3RBbGwoJ3BhdGgnKSxcbiAgICAgICAgY2lyY2xlID0gc3ZnLmFwcGVuZCgnc3ZnOmcnKS5zZWxlY3RBbGwoJ2cnKTtcbiAgICBcbiAgICAgICAgLy8gbW91c2UgZXZlbnQgdmFyc1xuICAgICAgICB2YXIgc2VsZWN0ZWRfbm9kZSA9IG51bGwsXG4gICAgICAgIHNlbGVjdGVkX2xpbmsgPSBudWxsLFxuICAgICAgICBtb3VzZWRvd25fbGluayA9IG51bGwsXG4gICAgICAgIG1vdXNlZG93bl9ub2RlID0gbnVsbCxcbiAgICAgICAgbW91c2V1cF9ub2RlID0gbnVsbDtcblxuICAgICAgICBmdW5jdGlvbiByZXNldE1vdXNlVmFycygpIHtcbiAgICAgICAgICAgIG1vdXNlZG93bl9ub2RlID0gbnVsbDtcbiAgICAgICAgICAgIG1vdXNldXBfbm9kZSA9IG51bGw7XG4gICAgICAgICAgICBtb3VzZWRvd25fbGluayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHVwZGF0ZSBmb3JjZSBsYXlvdXQgKGNhbGxlZCBhdXRvbWF0aWNhbGx5IGVhY2ggaXRlcmF0aW9uKVxuICAgICAgICBmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgICAgICAgLy8gZHJhdyBkaXJlY3RlZCBlZGdlcyB3aXRoIHByb3BlciBwYWRkaW5nIGZyb20gbm9kZSBjZW50ZXJzXG4gICAgICAgICAgICBwYXRoLmF0dHIoJ2QnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhWCA9IGQudGFyZ2V0LnggLSBkLnNvdXJjZS54LFxuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhWSA9IGQudGFyZ2V0LnkgLSBkLnNvdXJjZS55LFxuICAgICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKSxcbiAgICAgICAgICAgICAgICAgICAgICBub3JtWCA9IGRlbHRhWCAvIGRpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgbm9ybVkgPSBkZWx0YVkgLyBkaXN0LFxuICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVBhZGRpbmcgPSBkLmxlZnQgPyBhbGxSKzUgOiBhbGxSLFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFBhZGRpbmcgPSBkLnJpZ2h0ID8gYWxsUis1IDogYWxsUixcbiAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VYID0gZC5zb3VyY2UueCArIChzb3VyY2VQYWRkaW5nICogbm9ybVgpLFxuICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVkgPSBkLnNvdXJjZS55ICsgKHNvdXJjZVBhZGRpbmcgKiBub3JtWSksXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WCA9IGQudGFyZ2V0LnggLSAodGFyZ2V0UGFkZGluZyAqIG5vcm1YKSxcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRZID0gZC50YXJnZXQueSAtICh0YXJnZXRQYWRkaW5nICogbm9ybVkpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnTScgKyBzb3VyY2VYICsgJywnICsgc291cmNlWSArICdMJyArIHRhcmdldFggKyAnLCcgKyB0YXJnZXRZO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyAgaWYoZm9yY2V0b2dnbGUpe1xuICAgICAgICAgICAgY2lyY2xlLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBkLnggKyAnLCcgKyBkLnkgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vICB9O1xuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICBcbiAgICBcbiAgICAvLyAgYWRkIGxpc3RlbmVycyB0byBsZWZ0cGFuZWwubGVmdC4gIGV2ZXJ5IHRpbWUgYSB2YXJpYWJsZSBpcyBjbGlja2VkLCBub2RlcyB1cGRhdGVzIGFuZCBiYWNrZ3JvdW5kIGNvbG9yIGNoYW5nZXMuICBtb3VzZW92ZXIgc2hvd3Mgc3VtbWFyeSBzdGF0cyBvciBtb2RlbCBkZXNjcmlwdGlvbi5cbiAgICBkMy5zZWxlY3QoXCIjdGFiMVwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgLy8gUkVNT1ZFRCBUSElTIFRPT0xUSVAgQ09ERSBBTkQgTUFERSBBIEJPT1RTVFJBUCBQT1BPVkVSIENPTVBPTkVOVFxuICAgICAgICAkKFwiYm9keSBkaXYucG9wb3ZlclwiKVxuICAgICAgICAuYWRkQ2xhc3MoXCJ2YXJpYWJsZXNcIik7XG4gICAgICAgICQoXCJib2R5IGRpdi5wb3BvdmVyIGRpdi5wb3BvdmVyLWNvbnRlbnRcIilcbiAgICAgICAgLmFkZENsYXNzKFwiZm9ybS1ob3Jpem9udGFsXCIpO1xuICAgICAgICAgfSlcbiAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9SZW1vdmUgdGhlIHRvb2x0aXBcbiAgICAgICAgLy9kMy5zZWxlY3QoXCIjdG9vbHRpcFwiKS5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgICAgICB9KVxuICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIHZhckNsaWNrKCl7XG4gICAgICAgIGlmKGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgodGhpcy5pZCldLmdyYXlvdXQpIHtyZXR1cm4gbnVsbDt9XG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgIHZhciBteVRleHQgPSBkMy5zZWxlY3QodGhpcykudGV4dCgpO1xuICAgICAgICAgICAgICAgdmFyIG15Q29sb3IgPSBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InKTtcbiAgICAgICAgICAgICAgIHZhciBteVNDID0gYWxsTm9kZXNbZmluZE5vZGVJbmRleChteVRleHQpXS5zdHJva2VDb2xvcjtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgenBhcmFtcy56dmFycyA9IFtdOyAvL2VtcHR5IHRoZSB6dmFycyBhcnJheVxuICAgICAgICAgICAgICAgaWYoZDMucmdiKG15Q29sb3IpLnRvU3RyaW5nKCkgPT09IHZhckNvbG9yLnRvU3RyaW5nKCkpIHsgLy8gd2UgYXJlIGFkZGluZyBhIHZhclxuICAgICAgICAgICAgICAgIGlmKG5vZGVzLmxlbmd0aD09MCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGZpbmROb2RlKG15VGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1swXS5yZWZsZXhpdmU9dHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7bm9kZXMucHVzaChmaW5kTm9kZShteVRleHQpKTt9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleFRvUmdiYShzZWxWYXJDb2xvcik7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBlbHNlIHsgLy8gZHJvcHBpbmcgYSB2YXJpYWJsZVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShmaW5kTm9kZShteVRleHQpW1wiaW5kZXhcIl0sIDEpO1xuICAgICAgICAgICAgICAgICAgICBzcGxpY2VMaW5rc0Zvck5vZGUoZmluZE5vZGUobXlUZXh0KSk7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihteVNDPT1kdkNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkdkluZGV4ID0genBhcmFtcy56ZHYuaW5kZXhPZihteVRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHZJbmRleCA+IC0xKSB7IHpwYXJhbXMuemR2LnNwbGljZShkdkluZGV4LCAxKTsgfVxuICAgICAgICAgICAgICAgICAgICAvL3pwYXJhbXMuemR2PVwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYobXlTQz09Y3NDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3NJbmRleCA9IHpwYXJhbXMuemNyb3NzLmluZGV4T2YobXlUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzSW5kZXggPiAtMSkgeyB6cGFyYW1zLnpjcm9zcy5zcGxpY2UoY3NJbmRleCwgMSk7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihteVNDPT10aW1lQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVJbmRleCA9IHpwYXJhbXMuenRpbWUuaW5kZXhPZihteVRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZUluZGV4ID4gLTEpIHsgenBhcmFtcy56dGltZS5zcGxpY2UodGltZUluZGV4LCAxKTsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVsc2UgaWYobXlTQz09bm9tQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vbUluZGV4ID0genBhcmFtcy56bm9tLmluZGV4T2YobXlUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vbUluZGV4ID4gLTEpIHsgenBhcmFtcy56bm9tLnNwbGljZShkdkluZGV4LCAxKTsgfVxuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZVJlc2V0KGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgobXlUZXh0KV0pO1xuICAgICAgICAgICAgICAgIGJvcmRlclN0YXRlKCk7XG4gICAgICAgICAgICAgICBsZWdlbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyQ29sb3I7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgcGFuZWxQbG90cygpO1xuICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICBkMy5zZWxlY3QoXCIjbW9kZWxzXCIpLnNlbGVjdEFsbChcInBcIikgLy8gbW9kZWxzIHRhYlxuICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgIC8vIFJFTU9WRUQgVEhJUyBUT09MVElQIENPREUgQU5EIE1BREUgQSBCT09UU1RSQVAgUE9QT1ZFUiBDT01QT05FTlRcbiAgICAgICAgfSlcbiAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9SZW1vdmUgdGhlIHRvb2x0aXBcbiAgICAgICAgLy9kMy5zZWxlY3QoXCIjdG9vbHRpcFwiKS5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgICAgICB9KVxuICAgICAgICAvLyAgZDMuc2VsZWN0KFwiI0Rpc3BsYXlfY29udGVudFwiKVxuICAgICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIG15Q29sb3IgPSBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbHNcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJyx2YXJDb2xvcik7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgIGlmKGQzLnJnYihteUNvbG9yKS50b1N0cmluZygpID09PSB2YXJDb2xvci50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuem1vZGVsID0gZC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGV4VG9SZ2JhKHNlbFZhckNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuem1vZGVsID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhckNvbG9yO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBcblxuICAgIFxuICAgIC8vIHVwZGF0ZSBncmFwaCAoY2FsbGVkIHdoZW4gbmVlZGVkKVxuICAgIGZ1bmN0aW9uIHJlc3RhcnQoKSB7XG4gICAgICAgIC8vIG5vZGVzLmlkIGlzIHBlZ2dlZCB0byBhbGxOb2RlcywgaS5lLiB0aGUgb3JkZXIgaW4gd2hpY2ggdmFyaWFibGVzIGFyZSByZWFkIGluXG4gICAgICAgIC8vIG5vZGVzLmluZGV4IGlzIGZsb2F0aW5nIGFuZCBkZXBlbmRzIG9uIHVwZGF0ZXMgdG8gbm9kZXMuICBhIHZhcmlhYmxlcyBpbmRleCBjaGFuZ2VzIHdoZW4gbmV3IHZhcmlhYmxlcyBhcmUgYWRkZWQuXG4gICAgXG4gICAgICAgIGNpcmNsZS5jYWxsKGZvcmNlLmRyYWcpO1xuICAgICAgICBpZihmb3JjZXRvZ2dsZVswXT09PVwidHJ1ZVwiKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3JjZS5ncmF2aXR5KDAuMSk7XG4gICAgICAgICAgICBmb3JjZS5jaGFyZ2UoLTgwMCk7XG4gICAgICAgICAgICBmb3JjZS5saW5rU3RyZW5ndGgoMSk7XG4gICAgICAgICAgLy8gIGZvcmNlLnJlc3VtZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgLy8gIGNpcmNsZVxuICAgICAgICAgIC8vICAub24oJ21vdXNlZG93bi5kcmFnJywgbnVsbClcbiAgICAgICAgICAvLyAgLm9uKCd0b3VjaHN0YXJ0LmRyYWcnLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvcmNlLmdyYXZpdHkoMCk7XG4gICAgICAgICAgICBmb3JjZS5jaGFyZ2UoMCk7XG4gICAgICAgICAgICBmb3JjZS5saW5rU3RyZW5ndGgoMCk7XG4gICAgICAgICAgICAvL2ZvcmNlLnN0b3AoKTtcbiAgICAgICAgICAvLyAgZm9yY2UucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yY2UucmVzdW1lKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBwYXRoIChsaW5rKSBncm91cFxuICAgICAgICBwYXRoID0gcGF0aC5kYXRhKGxpbmtzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIHVwZGF0ZSBleGlzdGluZyBsaW5rc1xuICAgICAgICAvLyBWSkQ6IGRhc2hlZCBsaW5rcyBiZXR3ZWVuIHBlYmJsZXMgYXJlIFwic2VsZWN0ZWRcIi4gdGhpcyBpcyBkaXNhYmxlZCBmb3Igbm93XG4gICAgICAgIHBhdGguY2xhc3NlZCgnc2VsZWN0ZWQnLCBmdW5jdGlvbihkKSB7IHJldHVybjt9KS8vcmV0dXJuIGQgPT09IHNlbGVjdGVkX2xpbms7IH0pXG4gICAgICAgIC5zdHlsZSgnbWFya2VyLXN0YXJ0JywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5sZWZ0ID8gJ3VybCgjc3RhcnQtYXJyb3cpJyA6ICcnOyB9KVxuICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnJpZ2h0ID8gJ3VybCgjZW5kLWFycm93KScgOiAnJzsgfSk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy8gYWRkIG5ldyBsaW5rc1xuICAgICAgICBwYXRoLmVudGVyKCkuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5rJylcbiAgICAgICAgLmNsYXNzZWQoJ3NlbGVjdGVkJywgZnVuY3Rpb24oZCkgeyByZXR1cm47fSkvL3JldHVybiBkID09PSBzZWxlY3RlZF9saW5rOyB9KVxuICAgICAgICAuc3R5bGUoJ21hcmtlci1zdGFydCcsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQubGVmdCA/ICd1cmwoI3N0YXJ0LWFycm93KScgOiAnJzsgfSlcbiAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5yaWdodCA/ICd1cmwoI2VuZC1hcnJvdyknIDogJyc7IH0pXG4gICAgICAgIC5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZCkgeyAvLyBkbyB3ZSBldmVyIG5lZWQgdG8gc2VsZWN0IGEgbGluaz8gbWFrZSBpdCBkZWxldGUuLlxuICAgICAgICAgICAgdmFyIG9iajEgPSBKU09OLnN0cmluZ2lmeShkKTtcbiAgICAgICAgICAgIGZvcih2YXIgaiA9MDsgaiA8IGxpbmtzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYob2JqMSA9PT0gSlNPTi5zdHJpbmdpZnkobGlua3Nbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmtzLnNwbGljZShqLDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyByZW1vdmUgb2xkIGxpbmtzXG4gICAgICAgIHBhdGguZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gY2lyY2xlIChub2RlKSBncm91cFxuICAgICAgIGNpcmNsZSA9IGNpcmNsZS5kYXRhKG5vZGVzLCBmdW5jdGlvbihkKSB7cmV0dXJuIGQuaWQ7IH0pO1xuICAgICBcbiAgICAgICAgXG4gICAgICAgIC8vIHVwZGF0ZSBleGlzdGluZyBub2RlcyAocmVmbGV4aXZlICYgc2VsZWN0ZWQgdmlzdWFsIHN0YXRlcylcbiAgICAgICAgLy9kMy5yZ2IgaXMgdGhlIGZ1bmN0aW9uIGFkanVzdGluZyB0aGUgY29sb3IgaGVyZS5cbiAgICAgICAgY2lyY2xlLnNlbGVjdEFsbCgnY2lyY2xlJylcbiAgICAgICAgLmNsYXNzZWQoJ3JlZmxleGl2ZScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQucmVmbGV4aXZlOyB9KVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgIHJldHVybiBkMy5yZ2IoZC5ub2RlQ29sKTtcbiAgICAgICAgICAgICAgICAvL3JldHVybiAoZCA9PT0gc2VsZWN0ZWRfbm9kZSkgPyBkMy5yZ2IoZC5ub2RlQ29sKS5icmlnaHRlcigpIDogZDMucmdiKGQubm9kZUNvbCk7IC8vIElGIGQgaXMgZXF1YWwgdG8gc2VsZWN0ZWRfbm9kZSByZXR1cm4gYnJpZ2h0ZXIgY29sb3IgRUxTRSByZXR1cm4gbm9ybWFsIGNvbG9yXG4gICAgICAgICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICAgcmV0dXJuIChkMy5yZ2IoZC5zdHJva2VDb2xvcikpO1xuICAgICAgICAgICAgICAgfSlcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgIHJldHVybiAoZC5zdHJva2VXaWR0aCk7XG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIGFkZCBuZXcgbm9kZXNcbiAgICAgICAgXG4gICAgICAgIHZhciBnID0gY2lyY2xlLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgnc3ZnOmcnKVxuICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgdmFyIG15bmFtZSA9IGQubmFtZStcImJpZ2dyb3VwXCI7XG4gICAgICAgICAgICAgIHJldHVybiAobXluYW1lKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgXG4gICAgICAgIC8vIGFkZCBwbG90XG4gICAgICAgIGcuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICAgICBpZihkLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgICAgICAgICAgIGRlbnNpdHlOb2RlKGQsIG9iaj10aGlzKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVsc2UgaWYgKGQucGxvdHR5cGUgPT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgICAgICBiYXJzTm9kZShkLCBvYmo9dGhpcyk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIGFkZCBhcmMgdGFnc1xuICAgICAgICAvLyBOT1RFOiB0aGlzIGJsb2NrIG9mIGNvZGUgaGFzIGJlZW4gY29tbWVudGVkIG91dCB0byByZW1vdmUgdGhlIFwiY3Jvc3Mgc2VjdGlvblwiIGFuZCBcInRpbWUgc2VyaWVzXCIgYXJjIHRhZ3MuIFRoZXNlIHRhZ3MgYXJlIGZ1bmN0aW9uaW5nIGFzIGludGVuZGVkLCBidXQgdGhleSBkbyBub3QsIGF0IHByZXNlbnQsIGRvIGFueXRoaW5nIHRvIGNoYW5nZSB0aGUgc3RhdGlzdGljYWwgbW9kZWwgb3IgdmFyaWFibGVzLiBUbyBhdm9pZCBjb25mdXNpb24gd2hlbiB1c2luZyBUd29SYXZlbnMsIHRoZXkgaGF2ZSBiZWVuIGRyb3BwZWQuIFRvIGFkZCB0aGVtIGJhY2sgaW4sIHNpbXBseSB1bmNvbW1lbnQgdGhlIGJsb2NrIGJlbG93LlxuICAgICAgICAvKlxuICAgICAgICBnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzEpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICAgIHJldHVybiBcInRpbWVBcmNcIi5jb25jYXQoZC5pZCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCJ5ZWxsb3dcIilcbiAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC4zKVxuICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwKTsgICAvLy5hdHRyKCd0cmFuc2Zvcm0nLCAnc2NhbGUoMiknKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiN0aW1lVGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAuOSlcbiAgICAgICAgICAgIC5kZWxheSgwKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmRlbGF5KDEwMClcbiAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3RpbWVUZXh0XCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDUwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICBzZXRDb2xvcnMoZCwgdGltZUNvbG9yKTtcbiAgICAgICAgICAgIGxlZ2VuZCh0aW1lQ29sb3IpO1xuICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICByZXR1cm4gXCJ0aW1lVGV4dFwiLmNvbmNhdChkLmlkKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ4XCIsIDYpXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgMTEuNSlcbiAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgLmFwcGVuZChcInRleHRQYXRoXCIpXG4gICAgICAgIC5hdHRyKFwieGxpbms6aHJlZlwiLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiI3RpbWVBcmNcIi5jb25jYXQoZC5pZCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC50ZXh0KFwiVGltZVwiKTtcbiAgICAgICAgXG5cbiAgICAgICAgXG4gICAgICAgIGcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICByZXR1cm4gXCJjc0FyY1wiLmNvbmNhdChkLmlkKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzIpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgY3NDb2xvcilcbiAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC4zKVxuICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNjc1RleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjkpXG4gICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNjc1RleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgIHNldENvbG9ycyhkLCBjc0NvbG9yKTtcbiAgICAgICAgICAgIGxlZ2VuZChjc0NvbG9yKTtcbiAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY3NUZXh0XCIuY29uY2F0KGQuaWQpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInhcIiwgNilcbiAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAuYXBwZW5kKFwidGV4dFBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICByZXR1cm4gXCIjY3NBcmNcIi5jb25jYXQoZC5pZCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC50ZXh0KFwiQ3Jvc3MgU2VjXCIpO1xuKi9cbiAgICAgICAgXG4gICAgICAgIGcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICByZXR1cm4gXCJkdkFyY1wiLmNvbmNhdChkLmlkKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzMpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZHZDb2xvcilcbiAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC4zKVxuICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNkdlRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKSAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjkpXG4gICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKSAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNkdlRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKSAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgIHNldENvbG9ycyhkLCBkdkNvbG9yKTtcbiAgICAgICAgICAgIGxlZ2VuZChkdkNvbG9yKTtcbiAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiZHZUZXh0XCIuY29uY2F0KGQuaWQpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInhcIiwgNilcbiAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAuYXBwZW5kKFwidGV4dFBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICByZXR1cm4gXCIjZHZBcmNcIi5jb25jYXQoZC5pZCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC50ZXh0KFwiRGVwIFZhclwiKTtcbiAgICAgICAgXG4gICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICAgIHJldHVybiBcIm5vbUFyY1wiLmNvbmNhdChkLmlkKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzQpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgbm9tQ29sb3IpXG4gICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICBpZihkLmRlZmF1bHROdW1jaGFyPT1cImNoYXJhY3RlclwiKSB7cmV0dXJuO31cbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC4zKVxuICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNub21UZXh0XCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKCkgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC45KVxuICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgIGlmKGQuZGVmYXVsdE51bWNoYXI9PVwiY2hhcmFjdGVyXCIpIHtyZXR1cm47fVxuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKSAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNub21UZXh0XCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKCkgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDUwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICBpZihkLmRlZmF1bHROdW1jaGFyPT1cImNoYXJhY3RlclwiKSB7cmV0dXJuO31cbiAgICAgICAgICAgIHNldENvbG9ycyhkLCBub21Db2xvcik7XG4gICAgICAgICAgICBsZWdlbmQobm9tQ29sb3IpO1xuICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICByZXR1cm4gXCJub21UZXh0XCIuY29uY2F0KGQuaWQpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInhcIiwgNilcbiAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAuYXBwZW5kKFwidGV4dFBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICByZXR1cm4gXCIjbm9tQXJjXCIuY29uY2F0KGQuaWQpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAudGV4dChcIk5vbWluYWxcIik7XG5cbiAgICAgICAgZy5hcHBlbmQoJ3N2ZzpjaXJjbGUnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbm9kZScpXG4gICAgICAgIC5hdHRyKCdyJywgYWxsUilcbiAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdpbmhlcml0JylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgLy8gICAgICByZXR1cm4gKGQgPT09IHNlbGVjdGVkX25vZGUpID8gZDMucmdiKGQubm9kZUNvbCkuYnJpZ2h0ZXIoKS50b1N0cmluZygpIDogZC5ub2RlQ29sOyB9KVxuICAgICAgICAgICAgICAgcmV0dXJuIGQubm9kZUNvbDsgfSlcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgXCIwLjVcIilcbiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gZDMucmdiKGQuc3Ryb2tlQ29sb3IpLnRvU3RyaW5nKCk7IH0pXG4gICAgICAgIC5jbGFzc2VkKCdyZWZsZXhpdmUnLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnJlZmxleGl2ZTsgfSlcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgLy8gICAgIGlmKCFtb3VzZWRvd25fbm9kZSB8fCBkID09PSBtb3VzZWRvd25fbm9kZSkgcmV0dXJuO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgLy8gICAgaWYoIW1vdXNlZG93bl9ub2RlIHx8IGQgPT09IG1vdXNlZG93bl9ub2RlKSByZXR1cm47XG4gICAgICAgICAgICAvLyB1bmVubGFyZ2UgdGFyZ2V0IG5vZGVcbiAgICAgICAgICAgIC8vdG9vbHRpcC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgIC8vICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgICAgICB9KVxuICAvLyAgICAgIC5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZCkge1xuICAgLy8gICAgICAgICB9KVxuICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3RvcCBjbGljayBmcm9tIGJ1YmJsaW5nXG4gICAgICAgICAgICBzdW1tYXJ5SG9sZCA9IHRydWU7XG4vLyAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cmFuc2Zvcm1hdGlvbnMnKS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6YmxvY2tcIik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAub24oJ2NvbnRleHRtZW51JywgZnVuY3Rpb24oZCkgeyAvLyByaWdodCBjbGljayBvbiBub2RlXG4gICAgICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIHN0b3AgcmlnaHQgY2xpY2sgZnJvbSBidWJibGluZ1xuICAgICAgICAgICAgcmlnaHRDbGlja0xhc3Q9dHJ1ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbW91c2Vkb3duX25vZGUgPSBkO1xuICAgICAgICAgICAgaWYobW91c2Vkb3duX25vZGUgPT09IHNlbGVjdGVkX25vZGUpIHNlbGVjdGVkX25vZGUgPSBudWxsO1xuICAgICAgICAgICAgZWxzZSBzZWxlY3RlZF9ub2RlID0gbW91c2Vkb3duX25vZGU7XG4gICAgICAgICAgICBzZWxlY3RlZF9saW5rID0gbnVsbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gcmVwb3NpdGlvbiBkcmFnIGxpbmVcbiAgICAgICAgICAgIGRyYWdfbGluZVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJ3VybCgjZW5kLWFycm93KScpXG4gICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgZmFsc2UpXG4gICAgICAgICAgICAuYXR0cignZCcsICdNJyArIG1vdXNlZG93bl9ub2RlLnggKyAnLCcgKyBtb3VzZWRvd25fbm9kZS55ICsgJ0wnICsgbW91c2Vkb3duX25vZGUueCArICcsJyArIG1vdXNlZG93bl9ub2RlLnkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdmcub24oJ21vdXNlbW92ZScsIG1vdXNlbW92ZSk7XG4gICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAub24oJ21vdXNldXAnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3RvcCBtb3VzZXVwIGZyb20gYnViYmxpbmdcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYocmlnaHRDbGlja0xhc3QpIHtcbiAgICAgICAgICAgICAgICByaWdodENsaWNrTGFzdD1mYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIW1vdXNlZG93bl9ub2RlKSByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIG5lZWRlZCBieSBGRlxuICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgdHJ1ZSlcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsICcnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGRyYWctdG8tc2VsZlxuICAgICAgICAgICAgbW91c2V1cF9ub2RlID0gZDtcbiAgICAgICAgICAgIGlmKG1vdXNldXBfbm9kZSA9PT0gbW91c2Vkb3duX25vZGUpIHsgcmVzZXRNb3VzZVZhcnMoKTsgcmV0dXJuOyB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHVuZW5sYXJnZSB0YXJnZXQgbm9kZVxuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYWRkIGxpbmsgdG8gZ3JhcGggKHVwZGF0ZSBpZiBleGlzdHMpXG4gICAgICAgICAgICAvLyBOQjogbGlua3MgYXJlIHN0cmljdGx5IHNvdXJjZSA8IHRhcmdldDsgYXJyb3dzIHNlcGFyYXRlbHkgc3BlY2lmaWVkIGJ5IGJvb2xlYW5zXG4gICAgICAgICAgICB2YXIgc291cmNlLCB0YXJnZXQsIGRpcmVjdGlvbjtcbiAgICAgICAgICAgIGlmKG1vdXNlZG93bl9ub2RlLmlkIDwgbW91c2V1cF9ub2RlLmlkKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBtb3VzZWRvd25fbm9kZTtcbiAgICAgICAgICAgIHRhcmdldCA9IG1vdXNldXBfbm9kZTtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlID0gbW91c2V1cF9ub2RlO1xuICAgICAgICAgICAgdGFyZ2V0ID0gbW91c2Vkb3duX25vZGU7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBsaW5rO1xuICAgICAgICAgICAgbGluayA9IGxpbmtzLmZpbHRlcihmdW5jdGlvbihsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobC5zb3VyY2UgPT09IHNvdXJjZSAmJiBsLnRhcmdldCA9PT0gdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICBpZihsaW5rKSB7XG4gICAgICAgICAgICBsaW5rW2RpcmVjdGlvbl0gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmsgPSB7c291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCBsZWZ0OiBmYWxzZSwgcmlnaHQ6IGZhbHNlfTtcbiAgICAgICAgICAgIGxpbmtbZGlyZWN0aW9uXSA9IHRydWU7XG4gICAgICAgICAgICBsaW5rcy5wdXNoKGxpbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBzZWxlY3QgbmV3IGxpbmtcbiAgICAgICAgICAgIHNlbGVjdGVkX2xpbmsgPSBsaW5rO1xuICAgICAgICAgICAgc2VsZWN0ZWRfbm9kZSA9IG51bGw7XG4gICAgICAgICAgICBzdmcub24oJ21vdXNlbW92ZScsIG51bGwpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXNldE1vdXNlVmFycygpO1xuICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgIFxuICAgICAgICAvLyBzaG93IG5vZGUgTmFtZXNcbiAgICAgICAgZy5hcHBlbmQoJ3N2Zzp0ZXh0JylcbiAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAuYXR0cigneScsIDE1KVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnaWQnKVxuICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7cmV0dXJuIGQubmFtZTsgfSk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy8gc2hvdyBzdW1tYXJ5IHN0YXRzIG9uIG1vdXNlb3ZlclxuICAgICAgICAvLyBTVkcgZG9lc24ndCBzdXBwb3J0IHRleHQgd3JhcHBpbmcsIHVzZSBodG1sIGluc3RlYWRcbiAgICAgICAgZy5zZWxlY3RBbGwoXCJjaXJjbGUubm9kZVwiKVxuICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdGFiTGVmdChcInRhYjNcIik7XG4gICAgICAgICAgICB2YXJTdW1tYXJ5KGQpO1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RyYW5zZm9ybWF0aW9ucycpLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZGlzcGxheTpibG9ja1wiKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRyYW5zU2VsXCIpO1xuICAgICAgICAgICAgc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBkLmlkO1xuICAgICAgICAgICAgdHJhbnNmb3JtVmFyID0gdmFsdWVLZXlbZC5pZF07XG4gICAgICAgICAgXG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjZHZBcmNcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKSAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjEpXG4gICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI2R2VGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAuNSlcbiAgICAgICAgICAgIC5kZWxheSgwKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICBpZihkLmRlZmF1bHROdW1jaGFyPT1cIm51bWVyaWNcIikge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNub21BcmNcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKSAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjEpXG4gICAgICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI25vbVRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKSAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjUpXG4gICAgICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjY3NBcmNcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKSAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjEpXG4gICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI2NzVGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAuNSlcbiAgICAgICAgICAgIC5kZWxheSgwKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjdGltZUFyY1wiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAuMSlcbiAgICAgICAgICAgIC5kZWxheSgwKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjdGltZVRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKSAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjUpXG4gICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvLyBwb3B1cChkLCB4UG9zLCB5UG9zKTtcbiAgICAgICAgXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGlmKHN1bW1hcnlIb2xkPT09ZmFsc2UpIHsgdGFiTGVmdChsZWZ0dGFiKTsgfVxuXG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjY3NBcmNcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNjc1RleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiN0aW1lQXJjXCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDUwMCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjdGltZVRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNkdkFyY1wiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmRlbGF5KDEwMClcbiAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI2R2VGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmRlbGF5KDEwMClcbiAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI25vbUFyY1wiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmRlbGF5KDEwMClcbiAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI25vbVRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcblxuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIHBvcHVsYXRpbmcgdHJhbnNmb3JtYXRpb24gZHJvcGRvd25cbiAgICAgICAgdmFyIHQgPSBbXTtcbiAgICAgICAgZm9yKHZhciBqID0wOyBqIDwgbm9kZXMubGVuZ3RoOyBqKysgKSB7XG4gICAgICAgICAgICB0LnB1c2gobm9kZXNbal0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHRoZSB0cmFuc2Zvcm1hdGlvbiB2YXJpYWJsZSBsaXN0IGlzIHNpbGVudGx5IHVwZGF0ZWQgYXMgcGViYmxlcyBhcmUgYWRkZWQvcmVtb3ZlZFxuICAgICAgICBkMy5zZWxlY3QoXCIjdHJhbnNTZWxcIilcbiAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgIFxuICAgICAgICBkMy5zZWxlY3QoXCIjdHJhbnNTZWxcIilcbiAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAuZGF0YSh0KSAvL3NldCB0byB2YXJpYWJsZXMgaW4gbW9kZWwgc3BhY2UgYXMgdGhleSdyZSBhZGRlZFxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwibGlcIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge3JldHVybiBkOyB9KTtcbiAgICAgICAgXG4gICAgICAgICQoJyN0cmFuc1NlbCBsaScpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAnaW50ZXJhY3Rpb24nIGlzIHRoZSBzZWxlY3RlZCBmdW5jdGlvbiwgZG9uJ3Qgc2hvdyB0aGUgZnVuY3Rpb24gbGlzdCBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzZWxJbnRlcmFjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSAkKCcjdElucHV0JykudmFsKCkuY29uY2F0KCQodGhpcykudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyN0SW5wdXQnKS52YWwobik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdHJhbnNQYXJzZShuPW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodCA9PT0gbnVsbCkge3JldHVybjt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuPXQuc2xpY2UoMCwgdC5sZW5ndGgtMSksIHQ9dFt0Lmxlbmd0aC0xXSwgdHlwZVRyYW5zZm9ybT1mYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjdElucHV0JykudmFsKCQodGhpcykudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyN0cmFuc0xpc3QnKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlbW92ZSBvbGQgbm9kZXNcbiAgICAgICAgY2lyY2xlLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgZm9yY2Uuc3RhcnQoKTtcbiAgICB9ICAvL2VuZCByZXN0YXJ0IGZ1bmN0aW9uXG4gICAgXG4gICAgXG4gICAgZnVuY3Rpb24gbW91c2Vkb3duKGQpIHtcbiAgICAgICAgLy8gcHJldmVudCBJLWJhciBvbiBkcmFnXG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBiZWNhdXNlIDphY3RpdmUgb25seSB3b3JrcyBpbiBXZWJLaXQ/XG4gICAgICAgIHN2Zy5jbGFzc2VkKCdhY3RpdmUnLCB0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIGlmKGQzLmV2ZW50LmN0cmxLZXkgfHwgbW91c2Vkb3duX25vZGUgfHwgbW91c2Vkb3duX2xpbmspIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmVzdGFydCgpO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBtb3VzZW1vdmUoZCkge1xuICAgICAgICBpZighbW91c2Vkb3duX25vZGUpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIC8vIHVwZGF0ZSBkcmFnIGxpbmVcbiAgICAgICAgZHJhZ19saW5lLmF0dHIoJ2QnLCAnTScgKyBtb3VzZWRvd25fbm9kZS54ICsgJywnICsgbW91c2Vkb3duX25vZGUueSArICdMJyArIGQzLm1vdXNlKHRoaXMpWzBdICsgJywnICsgZDMubW91c2UodGhpcylbMV0pO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBtb3VzZXVwKGQpIHtcbiAgICAgICAgaWYobW91c2Vkb3duX25vZGUpIHtcbiAgICAgICAgICAgIC8vIGhpZGUgZHJhZyBsaW5lXG4gICAgICAgICAgICBkcmFnX2xpbmVcbiAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCB0cnVlKVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJlY2F1c2UgOmFjdGl2ZSBvbmx5IHdvcmtzIGluIFdlYktpdD9cbiAgICAgICAgc3ZnLmNsYXNzZWQoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICBcbiAgICAgICAgLy8gY2xlYXIgbW91c2UgZXZlbnQgdmFyc1xuICAgICAgICByZXNldE1vdXNlVmFycygpO1xuICAgIH1cbiAgICBcbiAgICAvLyBhcHAgc3RhcnRzIGhlcmVcbiAgIFxuICAgIHN2Zy5hdHRyKCdpZCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgcmV0dXJuIFwid2hpdGVzcGFjZVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICAgICAgICAgICB9KVxuICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpXG4gICAgLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgbW91c2Vkb3duKHRoaXMpO1xuICAgICAgICAgICB9KVxuICAgIC5vbignbW91c2V1cCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBtb3VzZXVwKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICBcbiAgICBkMy5zZWxlY3Qod2luZG93KVxuICAgIC5vbignY2xpY2snLGZ1bmN0aW9uKCl7ICAvL05PVEU6IGFsbCBjbGlja3Mgd2lsbCBidWJibGUgaGVyZSB1bmxlc3MgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgJCgnI3RyYW5zTGlzdCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZU91dCgxMDApO1xuICAgICAgICB9KTtcbiAgICBcbiAgICByZXN0YXJ0KCk7IC8vIHRoaXMgaXMgdGhlIGNhbGwgdGhlIHJlc3RhcnQgdGhhdCBpbml0aWFsaXplcyB0aGUgZm9yY2UubGF5b3V0KClcbiAgICBmYWtlQ2xpY2soKTtcbn0gLy8gZW5kIGxheW91dFxuXG5cbi8vIHJldHVybnMgaWRcbnZhciBmaW5kTm9kZUluZGV4ID0gZnVuY3Rpb24obm9kZU5hbWUpIHtcbiAgICBmb3IgKHZhciBpIGluIGFsbE5vZGVzKSB7XG4gICAgICAgIGlmKGFsbE5vZGVzW2ldW1wibmFtZVwiXSA9PT0gbm9kZU5hbWUpIHtyZXR1cm4gYWxsTm9kZXNbaV1bXCJpZFwiXTt9XG4gICAgfTtcbn1cblxudmFyIG5vZGVJbmRleCA9IGZ1bmN0aW9uKG5vZGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSBpbiBub2Rlcykge1xuICAgICAgICBpZihub2Rlc1tpXVtcIm5hbWVcIl0gPT09IG5vZGVOYW1lKSB7cmV0dXJuIGk7fVxuICAgIH1cbn1cblxudmFyIGZpbmROb2RlID0gZnVuY3Rpb24obm9kZU5hbWUpIHtcbiAgICBmb3IgKHZhciBpIGluIGFsbE5vZGVzKSB7aWYgKGFsbE5vZGVzW2ldW1wibmFtZVwiXSA9PT0gbm9kZU5hbWUpIHJldHVybiBhbGxOb2Rlc1tpXX07XG59XG5cblxuLy8gZnVuY3Rpb24gY2FsbGVkIGJ5IGZvcmNlIGJ1dHRvblxuZnVuY3Rpb24gZm9yY2VTd2l0Y2goKSB7XG4gICAgaWYoZm9yY2V0b2dnbGVbMF09PT1cInRydWVcIikgeyBmb3JjZXRvZ2dsZSA9IFtcImZhbHNlXCJdO31cbiAgICBlbHNlIHtmb3JjZXRvZ2dsZSA9IFtcInRydWVcIl19XG5cbiAgICBpZihmb3JjZXRvZ2dsZVswXT09PVwiZmFsc2VcIikge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuRm9yY2UnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBhY3RpdmVcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuRm9yY2UnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgZmFrZUNsaWNrKCk7XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIHNwbGljZUxpbmtzRm9yTm9kZShub2RlKSB7XG4gICAgdmFyIHRvU3BsaWNlID0gbGlua3MuZmlsdGVyKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChsLnNvdXJjZSA9PT0gbm9kZSB8fCBsLnRhcmdldCA9PT0gbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIHRvU3BsaWNlLm1hcChmdW5jdGlvbihsKSB7XG4gICAgICAgICAgICAgICAgIGxpbmtzLnNwbGljZShsaW5rcy5pbmRleE9mKGwpLCAxKTtcbiAgICAgICAgICAgICAgICAgfSk7XG59XG5cbmZ1bmN0aW9uIHpQb3AoKSB7XG4gICAgaWYgKGRhdGF1cmwpIHtcblx0enBhcmFtcy56ZGF0YXVybCA9IGRhdGF1cmw7XG4gICAgfSBcblxuICAgIHpwYXJhbXMuem1vZGVsY291bnQgPSBtb2RlbENvdW50O1xuICAgIFxuICAgIHpwYXJhbXMuemVkZ2VzID0gW107XG4gICAgenBhcmFtcy56dmFycyA9IFtdO1xuICAgIFxuICAgIGZvcih2YXIgaiA9MDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrICkgeyAvL3BvcHVsYXRlIHp2YXJzIGFycmF5XG4gICAgICAgIHpwYXJhbXMuenZhcnMucHVzaChub2Rlc1tqXS5uYW1lKTtcbiAgICAgICAgdmFyIHRlbXAgPSBub2Rlc1tqXS5pZDtcbiAgICAgICAgLy92YXIgdGVtcCA9IGZpbmROb2RlSW5kZXgobm9kZXNbal0ubmFtZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJub2RlIFwiLG5vZGVzW2pdLmlkKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInRlbXAgXCIsIHRlbXApO1xuICAgICAgICBcbiAgICAgICAgenBhcmFtcy56c2V0eFtqXSA9IGFsbE5vZGVzW3RlbXBdLnNldHh2YWxzO1xuICAgICAgICB6cGFyYW1zLnpzdWJzZXRbal0gPSBhbGxOb2Rlc1t0ZW1wXS5zdWJzZXRyYW5nZTtcbiAgICB9XG4gICAgXG4gICAgZm9yKHZhciBqID0wOyBqIDwgbGlua3MubGVuZ3RoOyBqKysgKSB7IC8vcG9wdWxhdGUgemVkZ2VzIGFycmF5XG4gICAgICAgIHZhciBzcmN0Z3QgPSBbXTtcbiAgICAgICAgLy9jb3JyZWN0IHRoZSBzb3VyY2UgdGFyZ2V0IG9yZGVyaW5nIGZvciBaZWxpZ1xuICAgICAgICBpZihsaW5rc1tqXS5sZWZ0PT09ZmFsc2UpIHtcbiAgICAgICAgICAgIHNyY3RndCA9IFtsaW5rc1tqXS5zb3VyY2UubmFtZSwgbGlua3Nbal0udGFyZ2V0Lm5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3JjdGd0ID0gW2xpbmtzW2pdLnRhcmdldC5uYW1lLCBsaW5rc1tqXS5zb3VyY2UubmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgenBhcmFtcy56ZWRnZXMucHVzaChzcmN0Z3QpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZXN0aW1hdGUoYnRuKSB7XG4gICAgXG4gICAgaWYocHJvZHVjdGlvbiAmJiB6cGFyYW1zLnpzZXNzaW9uaWQ9PVwiXCIpIHtcbiAgICAgICAgYWxlcnQoXCJXYXJuaW5nOiBEYXRhIGRvd25sb2FkIGlzIG5vdCBjb21wbGV0ZS4gVHJ5IGFnYWluIHNvb24uXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgelBvcCgpO1xuICAgIC8vIHdyaXRlIGxpbmtzIHRvIGZpbGUgJiBydW4gUiBDTURcbiAgICBcbiAgICAvL3BhY2thZ2UgdGhlIG91dHB1dCBhcyBKU09OXG4gICAgLy8gYWRkIGNhbGwgaGlzdG9yeSBhbmQgcGFja2FnZSB0aGUgenBhcmFtcyBvYmplY3QgYXMgSlNPTlxuICAgIHpwYXJhbXMuY2FsbEhpc3Rvcnk9Y2FsbEhpc3Rvcnk7XG4gICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh6cGFyYW1zKTtcbiAgICBcbiAgICAvL3ZhciBiYXNlID0gcmFwcFVSTCtcInplbGlnYXBwP3NvbGFKU09OPVwiXG4gICAgdXJsY2FsbCA9IHJhcHBVUkwrXCJ6ZWxpZ2FwcFwiOyAvL2Jhc2UuY29uY2F0KGpzb25vdXQpO1xuICAgIHZhciBzb2xhanNvbm91dCA9IFwic29sYUpTT049XCIranNvbm91dDtcbiAgICBjb25zb2xlLmxvZyhcInVybGNhbGwgb3V0OiBcIiwgdXJsY2FsbCk7XG4gICAgY29uc29sZS5sb2coXCJQT1NUIG91dDogXCIsIHNvbGFqc29ub3V0KTtcblxuICBcbiAgICB6cGFyYW1zLmFsbFZhcnMgPSB2YWx1ZUtleS5zbGljZSgxMCwyNSk7IC8vIHRoaXMgaXMgYmVjYXVzZSB0aGUgVVJMIGlzIHRvbyBsb25nLi4uXG4gICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh6cGFyYW1zKTtcbiAgICAvL3ZhciBzZWxlY3RvckJhc2UgPSByYXBwVVJMK1wic2VsZWN0b3JhcHA/c29sYUpTT049XCI7XG4gICAgdmFyIHNlbGVjdG9ydXJsY2FsbCA9IHJhcHBVUkwrXCJzZWxlY3RvcmFwcFwiOyAvLy5jb25jYXQoanNvbm91dCk7XG4gICAgXG4gICAgZnVuY3Rpb24gZXN0aW1hdGVTdWNjZXNzKGJ0bixqc29uKSB7XG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpOyAgLy8gc3RvcCBzcGlubmVyXG4gICAgICAgIGFsbFJlc3VsdHMucHVzaChqc29uKTtcbiAgICAgICAgY29uc29sZS5sb2coYWxsUmVzdWx0cyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwianNvbiBpbjogXCIsIGpzb24pO1xuICAgICAgICBcbiAgICAgICAgdmFyIG15cGFyZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXN1bHRzXCIpO1xuICAgICAgICBpZihlc3RpbWF0ZWQ9PWZhbHNlKSB7XG4gICAgICAgICAgICBteXBhcmVudC5yZW1vdmVDaGlsZChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlc3VsdHNIb2xkZXJcIikpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBlc3RpbWF0ZWQ9dHJ1ZTtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgICAgICBcbiAgICAgICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3XCIpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcbiAgICAgICAgXG4gICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG4gICAgICAgIFxuICAgICAgICAvLyBwcm9ncmFtbWF0aWMgY2xpY2sgb24gUmVzdWx0cyBidXR0b25cbiAgICAgICAgJChcIiNidG5SZXN1bHRzXCIpLnRyaWdnZXIoXCJjbGlja1wiKTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBtb2RlbENvdW50ID0gbW9kZWxDb3VudCsxO1xuICAgICAgICB2YXIgbW9kZWwgPSBcIk1vZGVsXCIuY29uY2F0KG1vZGVsQ291bnQpO1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gbW9kQ29sKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAgICAgLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGhleFRvUmdiYSh2YXJDb2xvcikpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBtb2RDb2woKTtcbiAgICAgICAgXG4gICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgLmluc2VydChcInBcIixcIjpmaXJzdC1jaGlsZFwiKSAvLyB0b3Agc3RhY2sgZm9yIHJlc3VsdHNcbiAgICAgICAgLmF0dHIoXCJpZFwiLG1vZGVsKVxuICAgICAgICAudGV4dChtb2RlbClcbiAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHNlbFZhckNvbG9yKSlcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IucmVwbGFjZSgvXFxzKi9nLCBcIlwiKTtcbiAgICAgICAgICAgIHZhciBiID0gaGV4VG9SZ2JhKHNlbFZhckNvbG9yKS5yZXBsYWNlKC9cXHMqL2csIFwiXCIpO1xuICAgICAgICAgICAgaWYoYS5zdWJzdHIoMCwxNyk9PT1iLnN1YnN0cigwLDE3KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy9lc2NhcGVzIHRoZSBmdW5jdGlvbiBlYXJseSBpZiB0aGUgZGlzcGxheWVkIG1vZGVsIGlzIGNsaWNrZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZENvbCgpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpKTtcbiAgICAgICAgICAgIHZpeih0aGlzLmlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdmFyIHJDYWxsID0gW107XG4gICAgICAgIHJDYWxsWzBdID0ganNvbi5jYWxsO1xuICAgICAgICBsb2dBcnJheS5wdXNoKFwiZXN0aW1hdGU6IFwiLmNvbmNhdChyQ2FsbFswXSkpO1xuICAgICAgICBzaG93TG9nKCk7XG4gICAgICAgIFxuICAgICAgICB2aXoobW9kZWwpO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBlc3RpbWF0ZUZhaWwoYnRuKSB7XG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpOyAgLy8gc3RvcCBzcGlubmVyXG4gICAgICBlc3RpbWF0ZWQ9dHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gc2VsZWN0b3JTdWNjZXNzKGJ0biwganNvbikge1xuICAgICAgICBkMy5zZWxlY3QoXCIjdGlja2VyXCIpXG4gICAgICAgIC50ZXh0KFwiU3VnZ2VzdGVkIHZhcmlhYmxlcyBhbmQgcGVyY2VudCBpbXByb3ZlbWVudCBvbiBSTVNFOiBcIiArIGpzb24udmFycyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic2VsZWN0b3JTdWNjZXNzOiBcIiwganNvbik7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIHNlbGVjdG9yRmFpbChidG4pIHtcbiAgICAgICAgYWxlcnQoXCJTZWxlY3RvciBGYWlsXCIpO1xuICAgIH1cblxuICAgIGVzdGltYXRlTGFkZGEuc3RhcnQoKTsgIC8vIHN0YXJ0IHNwaW5uZXJcbiAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCxidG4sIGVzdGltYXRlU3VjY2VzcywgZXN0aW1hdGVGYWlsLCBzb2xhanNvbm91dCk7IFxuICAgIC8vbWFrZUNvcnNSZXF1ZXN0KHNlbGVjdG9ydXJsY2FsbCwgYnRuLCBzZWxlY3RvclN1Y2Nlc3MsIHNlbGVjdG9yRmFpbCwgc29sYWpzb25vdXQpO1xuXG4gICAgXG59XG5cblxuZnVuY3Rpb24gZGF0YURvd25sb2FkKCkge1xuICAgIHpQb3AoKTtcbiAgICAvLyB3cml0ZSBsaW5rcyB0byBmaWxlICYgcnVuIFIgQ01EXG4gICAgXG4gICAgLy9wYWNrYWdlIHRoZSBvdXRwdXQgYXMgSlNPTlxuICAgIC8vIGFkZCBjYWxsIGhpc3RvcnkgYW5kIHBhY2thZ2UgdGhlIHpwYXJhbXMgb2JqZWN0IGFzIEpTT05cbiAgICB2YXIganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KHpwYXJhbXMpO1xuICAgIHZhciBidG49XCJub2J1dHRvblwiO1xuICAgIFxuICAgIC8vdmFyIGJhc2UgPSByYXBwVVJMK1wiemVsaWdhcHA/c29sYUpTT049XCJcbiAgICB1cmxjYWxsID0gcmFwcFVSTCtcImRhdGFhcHBcIjsgLy9iYXNlLmNvbmNhdChqc29ub3V0KTtcbiAgICB2YXIgc29sYWpzb25vdXQgPSBcInNvbGFKU09OPVwiK2pzb25vdXQ7XG4gICAgY29uc29sZS5sb2coXCJ1cmxjYWxsIG91dDogXCIsIHVybGNhbGwpO1xuICAgIGNvbnNvbGUubG9nKFwiUE9TVCBvdXQ6IFwiLCBzb2xhanNvbm91dCk7XG4gICAgXG4gICAgZnVuY3Rpb24gZG93bmxvYWRTdWNjZXNzKGJ0biwganNvbikge1xuICAgICAgICBjb25zb2xlLmxvZyhcImRhdGFEb3dubG9hZCBqc29uIGluOiBcIiwganNvbik7XG4gICAgICAgIHpwYXJhbXMuenNlc3Npb25pZD1qc29uLnNlc3Npb25pZFswXTtcbiAgICAgICAgXG4gICAgICAgIC8vIHNldCB0aGUgbGluayBVUkxcbiAgICAgICAgaWYocHJvZHVjdGlvbil7XG4gICAgICAgICAgICB2YXIgbG9nVVJMPXJhcHBVUkwrXCJsb2dfZGlyL2xvZ19cIit6cGFyYW1zLnpzZXNzaW9uaWQrXCIudHh0XCI7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxvZ0lEXCIpLmhyZWY9bG9nVVJMO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB2YXIgbG9nVVJMPVwicm9vay9sb2dfXCIrenBhcmFtcy56c2Vzc2lvbmlkK1wiLnR4dFwiO1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsb2dJRFwiKS5ocmVmPWxvZ1VSTDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZG93bmxvYWRGYWlsKGJ0bikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkRhdGEgaGF2ZSBub3QgYmVlbiBkb3dubG9hZGVkXCIpO1xuICAgIH1cbiAgICBcbiAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCxidG4sIGRvd25sb2FkU3VjY2VzcywgZG93bmxvYWRGYWlsLCBzb2xhanNvbm91dCk7XG59XG5cblxuXG5mdW5jdGlvbiB2aXoobSkge1xuICAgIHZhciBteW0gPSArbS5zdWJzdHIoNSw1KSAtIDE7XG4gICAgXG4gICAgZnVuY3Rpb24gcmVtb3ZlS2lkcyhwYXJlbnQpIHtcbiAgICAgICAgd2hpbGUgKHBhcmVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQocGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHZhciBteXBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVzdWx0c1ZpZXdcIik7XG4gICAgcmVtb3ZlS2lkcyhteXBhcmVudCk7XG5cbiAgICB2YXIganNvbiA9IGFsbFJlc3VsdHNbbXltXTtcbiAgICBcbiAgICAvLyBwaXBlIGluIGZpZ3VyZXMgdG8gcmlnaHQgcGFuZWxcbiAgICB2YXIgZmlsZWxpc3QgPSBuZXcgQXJyYXk7XG4gICAgZm9yKHZhciBpIGluIGpzb24uaW1hZ2VzKSB7XG4gICAgICAgIHZhciB6ZmlnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgemZpZy5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwganNvbi5pbWFnZXNbaV0pO1xuICAgICAgICB6ZmlnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAyMDApO1xuICAgICAgICB6ZmlnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMjAwKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXN1bHRzVmlld1wiKS5hcHBlbmRDaGlsZCh6ZmlnKTtcbiAgICB9XG4gICAgXG4gICAvLyB2YXIgckNhbGwgPSBbXTtcbiAgIC8vIHJDYWxsWzBdID0ganNvbi5jYWxsO1xuICAgLy8gbG9nQXJyYXkucHVzaChcImVzdGltYXRlOiBcIi5jb25jYXQockNhbGxbMF0pKTtcbiAgIC8vIHNob3dMb2coKTtcbiAgICBcbiAgICBcbiAgICAvLyB3cml0ZSB0aGUgcmVzdWx0cyB0YWJsZVxuICAgIHZhciByZXN1bHRzQXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4ganNvbi5zdW1JbmZvKSB7XG4gICAgICAgIGlmKGtleT09XCJjb2xuYW1lc1wiKSB7Y29udGludWU7fVxuICAgICAgICBcbiAgICAgICAgdmFyIG9iaiA9IGpzb24uc3VtSW5mb1trZXldO1xuICAgICAgICByZXN1bHRzQXJyYXkucHVzaChvYmopO1xuICAgICAgICAvKiBTTyBzYXlzIHRoaXMgaXMgaW1wb3J0YW50IGNoZWNrLCBidXQgSSBkb24ndCBzZWUgaG93IGl0IGhlbHBzIGhlcmUuLi5cbiAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAvLyBpbXBvcnRhbnQgY2hlY2sgdGhhdCB0aGlzIGlzIG9iamVjdHMgb3duIHByb3BlcnR5XG4gICAgICAgICAvLyBub3QgZnJvbSBwcm90b3R5cGUgcHJvcCBpbmhlcml0ZWRcbiAgICAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSl7XG4gICAgICAgICBhbGVydChwcm9wICsgXCIgPSBcIiArIG9ialtwcm9wXSk7XG4gICAgICAgICB9XG4gICAgICAgICB9ICAqL1xuICAgIH1cbiAgICBcbiAgICB2YXIgdGFibGUgPSBkMy5zZWxlY3QoXCIjcmVzdWx0c1ZpZXdcIilcbiAgICAuYXBwZW5kKFwicFwiKVxuLy8gICAgLmh0bWwoXCI8Y2VudGVyPjxiPlJlc3VsdHM8L2I+PC9jZW50ZXI+XCIpXG4gICAgLmFwcGVuZChcInRhYmxlXCIpO1xuICAgIFxuICAgIHZhciB0aGVhZCA9IHRhYmxlLmFwcGVuZChcInRoZWFkXCIpO1xuICAgIHRoZWFkLmFwcGVuZChcInRyXCIpXG4gICAgLnNlbGVjdEFsbChcInRoXCIpXG4gICAgLmRhdGEoanNvbi5zdW1JbmZvLmNvbG5hbWVzKVxuICAgIC5lbnRlcigpXG4gICAgLmFwcGVuZChcInRoXCIpXG4gICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZDt9KTtcbiAgICBcbiAgICB2YXIgdGJvZHkgPSB0YWJsZS5hcHBlbmQoXCJ0Ym9keVwiKTtcbiAgICB0Ym9keS5zZWxlY3RBbGwoXCJ0clwiKVxuICAgIC5kYXRhKHJlc3VsdHNBcnJheSlcbiAgICAuZW50ZXIoKS5hcHBlbmQoXCJ0clwiKVxuICAgIC5zZWxlY3RBbGwoXCJ0ZFwiKVxuICAgIC5kYXRhKGZ1bmN0aW9uKGQpe3JldHVybiBkO30pXG4gICAgLmVudGVyKCkuYXBwZW5kKFwidGRcIilcbiAgICAudGV4dChmdW5jdGlvbihkKXtcbiAgICAgICAgICB2YXIgbXlOdW0gPSBOdW1iZXIoZCk7XG4gICAgICAgICAgaWYoaXNOYU4obXlOdW0pKSB7IHJldHVybiBkO31cbiAgICAgICAgICByZXR1cm4gbXlOdW0udG9QcmVjaXNpb24oMyk7XG4gICAgICAgICAgfSlcbiAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKXtkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiYWxpY2VibHVlXCIpfSkgLy8gZm9yIG5vIGRpc2Nlcm5hYmxlIHJlYXNvblxuICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCl7ZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiNGOUY5RjlcIil9KSA7ICAvLyhidXQgbWF5YmUgd2UnbGwgdGhpbmsgb2Ygb25lKVxuICAgIFxuICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld1wiKVxuICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgLmh0bWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIFwiPGI+Rm9ybXVsYTogPC9iPlwiLmNvbmNhdChqc29uLmNhbGxbMF0pO1xuICAgICAgICAgIH0pO1xufVxuXG4vLyB0aGlzIGZ1bmN0aW9uIHBhcnNlcyB0aGUgdHJhbnNmb3JtYXRpb24gaW5wdXQuIHZhcmlhYmxlIG5hbWVzIGFyZSBvZnRlbiBuZXN0ZWQgaW5zaWRlIG9uZSBhbm90aGVyLCBlLmcuLCBldGh3YXIsIHdhciwgd2FycywgYW5kIHNvIHRoaXMgaXMgaGFuZGxlZFxuZnVuY3Rpb24gdHJhbnNQYXJzZShuKSB7XG4gICAgXG4gICAgdmFyIG91dDIgPSBbXTtcbiAgICB2YXIgdDI9bjtcbiAgICB2YXIgazI9MDtcbiAgICB2YXIgc3ViTWUyID0gXCJfdHJhbnN2YXJcIi5jb25jYXQoazIpO1xuICAgIHZhciBpbmRleGVkID0gW107XG4gICAgXG4gICAgLy8gb3V0MiBpcyBhbGwgbWF0Y2hlZCB2YXJpYWJsZXMsIGluZGV4ZWQgaXMgYW4gYXJyYXksIGVhY2ggZWxlbWVudCBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbWF0Y2hlZCB2YXJpYWJsZXMgc3RhcnRpbmcgaW5kZXggYW5kIGZpbmlzaGluZyBpbmRleC4gIGUuZy4sIG49XCJ3YXJzKzJcIiwgb3V0Mj1bd2FyLCB3YXJzXSwgaW5kZXhlZD1bezAsMn0sezAsM31dXG4gICAgZm9yKHZhciBpIGluIHZhbHVlS2V5KSB7XG4gICAgICAgIHZhciBtMiA9IG4ubWF0Y2godmFsdWVLZXlbaV0pO1xuICAgICAgICBpZihtMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb3V0Mi5wdXNoKG0yWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cCh2YWx1ZUtleVtpXSwgXCJnXCIpXG4gICAgICAgIHZhciBzID0gbi5zZWFyY2gocmUpO1xuICAgICAgICBpZihzICE9IC0xKSB7XG4gICAgICAgICAgICBpbmRleGVkLnB1c2goe2Zyb206cywgdG86cyt2YWx1ZUtleVtpXS5sZW5ndGh9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBuZXN0ZWQgbG9vcCBub3QgZ29vZCwgYnV0IGluZGV4ZWQgaXMgbm90IGxpa2VseSB0byBiZSB2ZXJ5IGxhcmdlLlxuICAgIC8vIGlmIGEgdmFyaWFibGUgaXMgbmVzdGVkLCBpdCBpcyByZW1vdmVkIGZyb20gb3V0MlxuICAgIC8vIG5vdGljZSwgbG9vcCBpcyBiYWNrd2FyZHMgc28gdGhhdCBpbmRleCBjaGFuZ2VzIGRvbid0IGFmZmVjdCB0aGUgc3BsaWNlXG4gICAgY29uc29sZS5sb2coXCJpbmRleGVkIFwiLCBpbmRleGVkKTtcbiAgICBmb3IodmFyIGk9aW5kZXhlZC5sZW5ndGgtMTsgaT4tMTsgaS0tKSB7XG4gICAgICAgIGZvcih2YXIgaj1pbmRleGVkLmxlbmd0aC0xOyBqPi0xOyBqLS0pIHtcbiAgICAgICAgICAgIGlmKGk9PT1qKSB7Y29udGludWU7fVxuICAgICAgICAgICAgaWYoKGluZGV4ZWRbaV0uZnJvbSA+PSBpbmRleGVkW2pdLmZyb20pICYgKGluZGV4ZWRbaV0udG8gPD0gaW5kZXhlZFtqXS50bykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpLCBcIiBpcyBuZXN0ZWQgaW4gXCIsIGopO1xuICAgICAgICAgICAgICAgIG91dDIuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yKHZhciBpIGluIG91dDIpIHtcbiAgICAgICAgdDIgPSB0Mi5yZXBsYWNlKG91dDJbaV0sIHN1Yk1lMik7IC8vc29tZXRoaW5nIHRoYXQnbGwgbmV2ZXIgYmUgYSB2YXJpYWJsZSBuYW1lXG4gICAgICAgIGsyID0gazIrMTtcbiAgICAgICAgc3ViTWUyID0gXCJfdHJhbnN2YXJcIi5jb25jYXQoazIpO1xuICAgIH1cbiAgICBcbiAgICBpZihvdXQyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3V0Mi5wdXNoKHQyKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJuZXcgb3V0IFwiLCBvdXQyKTtcbiAgICAgICAgcmV0dXJuKG91dDIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWxlcnQoXCJObyB2YXJpYWJsZSBuYW1lIGZvdW5kLiBQZXJoYXBzIGNoZWNrIHlvdXIgc3BlbGxpbmc/XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShuLHQsIHR5cGVUcmFuc2Zvcm0pIHtcbiAgICBcbiAgICBpZihwcm9kdWN0aW9uICYmIHpwYXJhbXMuenNlc3Npb25pZD09XCJcIikge1xuICAgICAgICBhbGVydChcIldhcm5pbmc6IERhdGEgZG93bmxvYWQgaXMgbm90IGNvbXBsZXRlLiBUcnkgYWdhaW4gc29vbi5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgaWYoIXR5cGVUcmFuc2Zvcm0pe1xuICAgICAgICB0ID0gdC5yZXBsYWNlKFwiK1wiLCBcIl9wbHVzX1wiKTsgLy8gY2FuJ3Qgc2VuZCB0aGUgcGx1cyBvcGVyYXRvclxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhuKTtcbiAgICBjb25zb2xlLmxvZyh0KTtcbiAgICBcbiAgICB2YXIgYnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bkVzdGltYXRlJyk7XG4gICAgXG4gICAgXG4gICAgdmFyIG15biA9IGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgoblswXSldO1xuICAgIGlmKHR5cGVvZiBteW49PT1cInVuZGVmaW5lZFwiKSB7dmFyIG15biA9IGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgobildO31cbiAgICBcbiAgICB2YXIgb3V0dHlwZXMgPSB7dmFybmFtZXNUeXBlczpuLCBpbnRlcnZhbDpteW4uaW50ZXJ2YWwsIG51bWNoYXI6bXluLm51bWNoYXIsIG5hdHVyZTpteW4ubmF0dXJlLCBiaW5hcnk6bXluLmJpbmFyeX07XG4gICAgXG4gICAgY29uc29sZS5sb2cobXluKTtcbiAgICAvLyBpZiB0eXBlVHJhbnNmb3JtIGJ1dCB3ZSBhbHJlYWR5IGhhdmUgdGhlIG1ldGFkYXRhXG4gICAgaWYodHlwZVRyYW5zZm9ybSkge1xuICAgICAgICBpZihteW4ubmF0dXJlPT1cIm5vbWluYWxcIiAmIHR5cGVvZiBteW4ucGxvdHZhbHVlcyAhPT1cInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBteW4ucGxvdHR5cGU9XCJiYXJcIjtcbiAgICAgICAgICAgIGJhcnNOb2RlKG15bik7XG4gICAgICAgICAgICBwb3B1bGF0ZVBvcG92ZXIoKTtcbiAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChteW4ubmF0dXJlIT1cIm5vbWluYWxcIiAmIHR5cGVvZiBteW4ucGxvdHggIT09XCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbXluLnBsb3R0eXBlPVwiY29udGludW91c1wiO1xuICAgICAgICAgICAgZGVuc2l0eU5vZGUobXluKTtcbiAgICAgICAgICAgIHBvcHVsYXRlUG9wb3ZlcigpO1xuICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgICBcbiAgICBcbiAgICAvL3BhY2thZ2UgdGhlIG91dHB1dCBhcyBKU09OXG4gICAgdmFyIHRyYW5zZm9ybXN0dWZmID0ge3pkYXRhdXJsOmRhdGF1cmwsIHp2YXJzOm4sIHpzZXNzaW9uaWQ6enBhcmFtcy56c2Vzc2lvbmlkLCB0cmFuc2Zvcm06dCwgY2FsbEhpc3Rvcnk6Y2FsbEhpc3RvcnksIHR5cGVUcmFuc2Zvcm06dHlwZVRyYW5zZm9ybSwgdHlwZVN0dWZmOm91dHR5cGVzfTtcbiAgICB2YXIganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KHRyYW5zZm9ybXN0dWZmKTtcbiAgICAvL3ZhciBiYXNlID0gcmFwcFVSTCtcInRyYW5zZm9ybWFwcD9zb2xhSlNPTj1cIlxuICAgIFxuICAgIHVybGNhbGwgPSByYXBwVVJMK1widHJhbnNmb3JtYXBwXCI7IC8vYmFzZS5jb25jYXQoanNvbm91dCk7XG4gICAgdmFyIHNvbGFqc29ub3V0ID0gXCJzb2xhSlNPTj1cIitqc29ub3V0O1xuICAgIGNvbnNvbGUubG9nKFwidXJsY2FsbCBvdXQ6IFwiLCB1cmxjYWxsKTtcbiAgICBjb25zb2xlLmxvZyhcIlBPU1Qgb3V0OiBcIiwgc29sYWpzb25vdXQpO1xuXG5cbiAgICBcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1TdWNjZXNzKGJ0biwganNvbikge1xuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0b3AoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJqc29uIGluOiBcIiwganNvbik7XG4gICAgICAgIFxuICAgICAgICBpZihqc29uLnR5cGVUcmFuc2Zvcm1bMF0pIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZDMuanNvbihqc29uLnVybCwgZnVuY3Rpb24oZXJyb3IsIGpzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIganNvbmRhdGEgPSBqc29uO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIga2V5IGluIGpzb25kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG15SW5kZXggPSBmaW5kTm9kZUluZGV4KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBhbGxOb2Rlc1tteUluZGV4XSwganNvbmRhdGFba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGFsbE5vZGVzW215SW5kZXhdLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW5zaXR5Tm9kZShhbGxOb2Rlc1tteUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFsbE5vZGVzW215SW5kZXhdLnBsb3R0eXBlID09PSBcImJhclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhcnNOb2RlKGFsbE5vZGVzW215SW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFrZUNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3B1bGF0ZVBvcG92ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYWxsTm9kZXNbbXlJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgXG4gICAgICAgICAgICBjYWxsSGlzdG9yeS5wdXNoKHtmdW5jOlwidHJhbnNmb3JtXCIsIHp2YXJzOm4sIHRyYW5zZm9ybTp0fSk7XG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIHN1YnNldGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgckNhbGwgPSBbXTtcbiAgICAgICAgICAgIHJDYWxsWzBdID0ganNvbi5jYWxsO1xuICAgICAgICAgICAgdmFyIG5ld1ZhciA9IHJDYWxsWzBdWzBdO1xuICAgICAgICAgICAgdHJhbnMucHVzaChuZXdWYXIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBkMy5qc29uKGpzb24udXJsLCBmdW5jdGlvbihlcnJvciwganNvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB2YXIganNvbmRhdGEgPSBqc29uO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4ganNvbmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBteUluZGV4ID0gZmluZE5vZGVJbmRleChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgbXlJbmRleCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJJbnZhbGlkIHRyYW5zZm9ybWF0aW9uOiB0aGlzIHZhcmlhYmxlIG5hbWUgYWxyZWFkeSBleGlzdHMuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0cmFuc2Zvcm1lZCB2YXJpYWJsZSB0byB0aGUgY3VycmVudCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFsbE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iajEgPSB7aWQ6aSwgcmVmbGV4aXZlOiBmYWxzZSwgXCJuYW1lXCI6IGtleSwgXCJsYWJsXCI6IFwidHJhbnNmb3JtbGFiZWxcIiwgZGF0YTogWzUsMTUsMjAsMCw1LDE1LDIwXSwgY291bnQ6IFsuNiwgLjIsIC45LCAuOCwgLjEsIC4zLCAuNF0sIFwibm9kZUNvbFwiOmNvbG9ycyhpKSwgXCJiYXNlQ29sXCI6Y29sb3JzKGkpLCBcInN0cm9rZUNvbG9yXCI6c2VsVmFyQ29sb3IsIFwic3Ryb2tlV2lkdGhcIjpcIjFcIiwgXCJzdWJzZXRwbG90XCI6ZmFsc2UsIFwic3Vic2V0cmFuZ2VcIjpbXCJcIiwgXCJcIl0sXCJzZXR4cGxvdFwiOmZhbHNlLCBcInNldHh2YWxzXCI6W1wiXCIsIFwiXCJdLCBcImdyYXlvdXRcIjpmYWxzZSwgXCJkZWZhdWx0SW50ZXJ2YWxcIjpqc29uZGF0YVtrZXldW1wiaW50ZXJ2YWxcIl0sIFwiZGVmYXVsdE51bWNoYXJcIjpqc29uZGF0YVtrZXldW1wibnVtY2hhclwiXSwgXCJkZWZhdWx0TmF0dXJlXCI6anNvbmRhdGFba2V5XVtcIm5hdHVyZVwiXSwgXCJkZWZhdWx0QmluYXJ5XCI6anNvbmRhdGFba2V5XVtcImJpbmFyeVwiXX07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIG9iajEsIGpzb25kYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICBhbGxOb2Rlcy5wdXNoKG9iajEpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNjYWZmb2xkaW5nUHVzaChyQ2FsbFswXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlS2V5LnB1c2gobmV3VmFyKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChhbGxOb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGZha2VDbGljaygpO1xuICAgICAgICAgICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZihhbGxOb2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbnNpdHlOb2RlKGFsbE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxsTm9kZXNbaV0ucGxvdHR5cGUgPT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcnNOb2RlKGFsbE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfS8vZm9yXG4gICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgbG9nXG4gICAgICAgICAgICBsb2dBcnJheS5wdXNoKFwidHJhbnNmb3JtOiBcIi5jb25jYXQockNhbGxbMF0pKTtcbiAgICAgICAgICAgIHNob3dMb2coKTtcbiAgICAgICAgXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBiZWxvdyBpcyB0aGUgY2Fyb3VzZWwgcG9ydGlvbiB0aGF0IG5lZWRzIHRvIGJlIHJldmlzZWQgYXMgb2YgTWF5IDI5IDIwMTVcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYWRkIHRyYW5zZm9ybWVkIHZhcmlhYmxlIHRvIGFsbCBzcGFjZXNcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG15c3BhY2UgY2FsbEhpc3RvcnkgY29udGFpbnMgYSBzdWJzZXRcbiAgICAgICAgICAgIGZvcih2YXIgazA9MDsgazA8Y2FsbEhpc3RvcnkubGVuZ3RoOyBrMCsrKSB7XG4gICAgICAgICAgICAgICAgaWYoY2FsbEhpc3RvcnlbazBdLmZ1bmM9PT1cInN1YnNldFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJzZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbG9vcEo6XG4gICAgICAgICAgICBmb3IodmFyIGogaW4gc3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgaWYoaj09PW15c3BhY2UpIHtjb250aW51ZTt9XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBzcGFjZXNbal0uYWxsTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmKHN1YnNldGVkPT09dHJ1ZSkgeyAvLyBteXNwYWNlIGhhcyBiZWVuIHN1YnNldGVkXG4gICAgICAgICAgICAgICAgICAgIG9mZnNwYWNlVHJhbnNmb3JtKGopO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wSjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBsb29wSzpcbiAgICAgICAgICAgICAgICBmb3IodmFyIGs9MDsgazxzcGFjZXNbal0uY2FsbEhpc3RvcnkubGVuZ3RoOyBrKyspIHsgLy8gZ2V0cyBoZXJlIGlmIG15c3BhY2UgaGFzIG5vdCBiZWVuIHN1YnNldGVkXG4gICAgICAgICAgICAgICAgICAgIGlmKHNwYWNlc1tqXS5jYWxsSGlzdG9yeVtrXS5mdW5jPT09XCJzdWJzZXRcIikgeyAvLyBjaGVjayBpZiBzcGFjZSBqIGhhcyBiZWVuIHN1YnNldGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzcGFjZVRyYW5zZm9ybShqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGxvb3BKO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc3Vic2V0IGluIHRoZSBjYWxsSGlzdG9yeSBvZiB0aGUgY3VycmVudCBzcGFjZSwgdHJhbnNmb3JtYXRpb24gaXMgZGlmZmVyZW50XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gb2Zmc3BhY2VUcmFuc2Zvcm0oaikge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zdHVmZiA9IHt6ZGF0YXVybDpkYXRhdXJsLCB6dmFyczpuLCB6c2Vzc2lvbmlkOnpwYXJhbXMuenNlc3Npb25pZCwgdHJhbnNmb3JtOnQsIGNhbGxIaXN0b3J5OnNwYWNlc1tqXS5jYWxsSGlzdG9yeX07XG4gICAgICAgICAgICAgICAgICAgIHZhciBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkodHJhbnNmb3Jtc3R1ZmYpO1xuICAgICAgICAgICAgICAgICAgICAvL3ZhciBiYXNlID0gcmFwcFVSTCtcInRyYW5zZm9ybWFwcD9zb2xhSlNPTj1cIlxuICAgICAgICAgICAgICAgICAgICB1cmxjYWxsID0gcmFwcFVSTCtcInRyYW5zZm9ybWFwcFwiOyAvL2Jhc2UuY29uY2F0KGpzb25vdXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc29sYWpzb25vdXQgPSBcInNvbGFKU09OPVwiK2pzb25vdXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidXJsY2FsbCBvdXQ6IFwiLCB1cmxjYWxsKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJQT1NUIG91dDogXCIsIHNvbGFqc29ub3V0KTtcblxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvZmZzcGFjZVN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFjZXNbal0uY2FsbEhpc3RvcnkucHVzaCh7ZnVuYzpcInRyYW5zZm9ybVwiLCB6dmFyczpuLCB0cmFuc2Zvcm06dH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2VzW2pdLmxvZ0FycmF5LnB1c2goXCJ0cmFuc2Zvcm06IFwiLmNvbmNhdChyQ2FsbFswXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZFByZXByb2Nlc3MoanNvbi51cmwsIHA9c3BhY2VzW2pdLnByZXByb2Nlc3MsIHY9bmV3VmFyLCBjYWxsYmFjaz1udWxsKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFjZXNbal0uYWxsTm9kZXMucHVzaCh7aWQ6aSwgcmVmbGV4aXZlOiBmYWxzZSwgXCJuYW1lXCI6IHJDYWxsWzBdWzBdLCBcImxhYmxcIjogXCJ0cmFuc2Zvcm1sYWJlbFwiLCBkYXRhOiBbNSwxNSwyMCwwLDUsMTUsMjBdLCBjb3VudDogaG9sZCwgXCJub2RlQ29sXCI6Y29sb3JzKGkpLCBcImJhc2VDb2xcIjpjb2xvcnMoaSksIFwic3Ryb2tlQ29sb3JcIjpzZWxWYXJDb2xvciwgXCJzdHJva2VXaWR0aFwiOlwiMVwiLCBcImludGVydmFsXCI6anNvbi50eXBlcy5pbnRlcnZhbFswXSwgXCJudW1jaGFyXCI6anNvbi50eXBlcy5udW1jaGFyWzBdLCBcIm5hdHVyZVwiOmpzb24udHlwZXMubmF0dXJlWzBdLCBcImJpbmFyeVwiOmpzb24udHlwZXMuYmluYXJ5WzBdLCBcImRlZmF1bHRJbnRlcnZhbFwiOmpzb24udHlwZXMuaW50ZXJ2YWxbMF0sIFwiZGVmYXVsdE51bWNoYXJcIjpqc29uLnR5cGVzLm51bWNoYXJbMF0sIFwiZGVmYXVsdE5hdHVyZVwiOmpzb24udHlwZXMubmF0dXJlWzBdLCBcImRlZmF1bHRCaW5hcnlcIjpqc29uLnR5cGVzLmJpbmFyeVswXSwgXCJtaW5cIjpqc29uLnN1bVN0YXRzLm1pblswXSwgXCJtZWRpYW5cIjpqc29uLnN1bVN0YXRzLm1lZGlhblswXSwgXCJzZFwiOmpzb24uc3VtU3RhdHMuc2RbMF0sIFwibW9kZVwiOihqc29uLnN1bVN0YXRzLm1vZGVbMF0pLnRvU3RyaW5nKCksIFwiZnJlcW1vZGVcIjpqc29uLnN1bVN0YXRzLmZyZXFtb2RlWzBdLFwiZmV3ZXN0XCI6KGpzb24uc3VtU3RhdHMuZmV3ZXN0WzBdKS50b1N0cmluZygpLCBcImZyZXFmZXdlc3RcIjpqc29uLnN1bVN0YXRzLmZyZXFmZXdlc3RbMF0sIFwibWlkXCI6KGpzb24uc3VtU3RhdHMubWlkWzBdKS50b1N0cmluZygpLCBcImZyZXFtaWRcIjpqc29uLnN1bVN0YXRzLmZyZXFtaWRbMF0sIFwidW5pcXVlc1wiOmpzb24uc3VtU3RhdHMudW5pcXVlc1swXSwgXCJoZXJmaW5kYWhsXCI6anNvbi5zdW1TdGF0cy5oZXJmaW5kYWhsWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWxpZFwiOmpzb24uc3VtU3RhdHMudmFsaWRbMF0sIFwibWVhblwiOmpzb24uc3VtU3RhdHMubWVhblswXSwgXCJtYXhcIjpqc29uLnN1bVN0YXRzLm1heFswXSwgXCJpbnZhbGlkXCI6anNvbi5zdW1TdGF0cy5pbnZhbGlkWzBdLCBcInN1YnNldHBsb3RcIjpmYWxzZSwgXCJzdWJzZXRyYW5nZVwiOltcIlwiLCBcIlwiXSxcInNldHhwbG90XCI6ZmFsc2UsIFwic2V0eHZhbHNcIjpbXCJcIiwgXCJcIl0sIFwiZ3JheW91dFwiOmZhbHNlfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb2Zmc3BhY2VGYWlsKGJ0bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJ0cmFuc2Zvcm0gZmFpbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCxidG4sIG9mZnNwYWNlU3VjY2Vzcywgb2Zmc3BhY2VGYWlsLCBzb2xhanNvbm91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gaWYgbXlzcGFjZSBhbmQgc3BhY2UgaiBoYXZlIG5vdCBiZWVuIHN1YnNldGVkLCBhcHBlbmQgdGhlIHNhbWUgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgICAgICBzcGFjZXNbal0uY2FsbEhpc3RvcnkucHVzaCh7ZnVuYzpcInRyYW5zZm9ybVwiLCB6dmFyczpuLCB0cmFuc2Zvcm06dH0pO1xuICAgICAgICAgICAgICAgIHNwYWNlc1tqXS5sb2dBcnJheS5wdXNoKFwidHJhbnNmb3JtOiBcIi5jb25jYXQockNhbGxbMF0pKTtcblxuICAgICAgICAgICAgICAgIHNwYWNlc1tqXS5hbGxOb2Rlcy5wdXNoKHtpZDppLCByZWZsZXhpdmU6IGZhbHNlLCBcIm5hbWVcIjogckNhbGxbMF1bMF0sIFwibGFibFwiOiBcInRyYW5zZm9ybWxhYmVsXCIsIGRhdGE6IFs1LDE1LDIwLDAsNSwxNSwyMF0sIGNvdW50OiBob2xkLCBcIm5vZGVDb2xcIjpjb2xvcnMoaSksIFwiYmFzZUNvbFwiOmNvbG9ycyhpKSwgXCJzdHJva2VDb2xvclwiOnNlbFZhckNvbG9yLCBcInN0cm9rZVdpZHRoXCI6XCIxXCIsIFwiaW50ZXJ2YWxcIjpqc29uLnR5cGVzLmludGVydmFsWzBdLCBcIm51bWNoYXJcIjpqc29uLnR5cGVzLm51bWNoYXJbMF0sIFwibmF0dXJlXCI6anNvbi50eXBlcy5uYXR1cmVbMF0sIFwiYmluYXJ5XCI6anNvbi50eXBlcy5iaW5hcnlbMF0sIFwiZGVmYXVsdEludGVydmFsXCI6anNvbi50eXBlcy5pbnRlcnZhbFswXSwgXCJkZWZhdWx0TnVtY2hhclwiOmpzb24udHlwZXMubnVtY2hhclswXSwgXCJkZWZhdWx0TmF0dXJlXCI6anNvbi50eXBlcy5uYXR1cmVbMF0sIFwiZGVmYXVsdEJpbmFyeVwiOmpzb24udHlwZXMuYmluYXJ5WzBdLCBcIm1pblwiOmpzb24uc3VtU3RhdHMubWluWzBdLCBcIm1lZGlhblwiOmpzb24uc3VtU3RhdHMubWVkaWFuWzBdLCBcInNkXCI6anNvbi5zdW1TdGF0cy5zZFswXSwgXCJtb2RlXCI6KGpzb24uc3VtU3RhdHMubW9kZVswXSkudG9TdHJpbmcoKSwgXCJmcmVxbW9kZVwiOmpzb24uc3VtU3RhdHMuZnJlcW1vZGVbMF0sXCJmZXdlc3RcIjooanNvbi5zdW1TdGF0cy5mZXdlc3RbMF0pLnRvU3RyaW5nKCksIFwiZnJlcWZld2VzdFwiOmpzb24uc3VtU3RhdHMuZnJlcWZld2VzdFswXSwgXCJtaWRcIjooanNvbi5zdW1TdGF0cy5taWRbMF0pLnRvU3RyaW5nKCksIFwiZnJlcW1pZFwiOmpzb24uc3VtU3RhdHMuZnJlcW1pZFswXSwgXCJ1bmlxdWVzXCI6anNvbi5zdW1TdGF0cy51bmlxdWVzWzBdLCBcImhlcmZpbmRhaGxcIjpqc29uLnN1bVN0YXRzLmhlcmZpbmRhaGxbMF0sXG4gICAgICAgICAgICAgICAgXCJ2YWxpZFwiOmpzb24uc3VtU3RhdHMudmFsaWRbMF0sIFwibWVhblwiOmpzb24uc3VtU3RhdHMubWVhblswXSwgXCJtYXhcIjpqc29uLnN1bVN0YXRzLm1heFswXSwgXCJpbnZhbGlkXCI6anNvbi5zdW1TdGF0cy5pbnZhbGlkWzBdLCBcInN1YnNldHBsb3RcIjpmYWxzZSwgXCJzdWJzZXRyYW5nZVwiOltcIlwiLCBcIlwiXSxcInNldHhwbG90XCI6ZmFsc2UsIFwic2V0eHZhbHNcIjpbXCJcIiwgXCJcIl0sIFwiZ3JheW91dFwiOmZhbHNlfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZWFkUHJlcHJvY2Vzcyhqc29uLnVybCwgcD1zcGFjZXNbal0ucHJlcHJvY2Vzcywgdj1uZXdWYXIsIGNhbGxiYWNrPW51bGwpO1xuICAgICAgICAgICAgfSAgICovXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtRmFpbChidG4pIHtcbiAgICAgICAgYWxlcnQoXCJ0cmFuc2Zvcm0gZmFpbFwiKTtcbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgfVxuICAgIFxuICAgIGVzdGltYXRlTGFkZGEuc3RhcnQoKTsgIC8vIHN0YXJ0IHNwaW5uZXJcbiAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCxidG4sIHRyYW5zZm9ybVN1Y2Nlc3MsIHRyYW5zZm9ybUZhaWwsIHNvbGFqc29ub3V0KTtcbiAgICBcbn1cblxuZnVuY3Rpb24gc2NhZmZvbGRpbmdQdXNoKHYpIHsgLy8gYWRkaW5nIGEgdmFyaWFibGUgdG8gdGhlIHZhcmlhYmxlIGxpc3QgYWZ0ZXIgYSB0cmFuc2Zvcm1hdGlvblxuICAgIFxuICAgICAgICBkMy5zZWxlY3QoXCIjdGFiMVwiKVxuICAgICAgICAuZGF0YSh2KVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgcmV0dXJuIHZbMF0ucmVwbGFjZSgvXFxXL2csIFwiX1wiKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLnRleHQodlswXSlcbiAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHNlbFZhckNvbG9yKSlcbiAgICAgICAgLmF0dHIoXCJkYXRhLWNvbnRhaW5lclwiLCBcImJvZHlcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXRvZ2dsZVwiLCBcInBvcG92ZXJcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXRyaWdnZXJcIiwgXCJob3ZlclwiKVxuICAgICAgICAuYXR0cihcImRhdGEtcGxhY2VtZW50XCIsIFwicmlnaHRcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWh0bWxcIiwgXCJ0cnVlXCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW92ZXJcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcIm9ubW91c2VvdXRcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIiwgXCJTdW1tYXJ5IFN0YXRpc3RpY3NcIilcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gdmFyQ2xpY2soKXsgLy8gd2UndmUgYWRkZWQgYSBuZXcgdmFyaWFibGUsIHNvIHdlIG5lZWQgdG8gYWRkIHRoZSBsaXN0ZW5lclxuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgbXlUZXh0ID0gZDMuc2VsZWN0KHRoaXMpLnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICB2YXIgbXlDb2xvciA9IGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgICAgICAgICAgICAgIHZhciBteVNDID0gYWxsTm9kZXNbZmluZE5vZGVJbmRleChteVRleHQpXS5zdHJva2VDb2xvcjtcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnp2YXJzID0gW107IC8vZW1wdHkgdGhlIHp2YXJzIGFycmF5XG4gICAgICAgICAgICAgICAgICAgaWYoZDMucmdiKG15Q29sb3IpLnRvU3RyaW5nKCkgPT09IHZhckNvbG9yLnRvU3RyaW5nKCkpIHsgLy8gd2UgYXJlIGFkZGluZyBhIHZhclxuICAgICAgICAgICAgICAgICAgICBpZihub2Rlcy5sZW5ndGg9PTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goZmluZE5vZGUobXlUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1swXS5yZWZsZXhpdmU9dHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtub2Rlcy5wdXNoKGZpbmROb2RlKG15VGV4dCkpO31cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleFRvUmdiYShzZWxWYXJDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBkcm9wcGluZyBhIHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShmaW5kTm9kZShteVRleHQpW1wiaW5kZXhcIl0sIDEpO1xuICAgICAgICAgICAgICAgICAgICBzcGxpY2VMaW5rc0Zvck5vZGUoZmluZE5vZGUobXlUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKG15U0M9PWR2Q29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdkluZGV4ID0genBhcmFtcy56ZHYuaW5kZXhPZihteVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR2SW5kZXggPiAtMSkgeyB6cGFyYW1zLnpkdi5zcGxpY2UoZHZJbmRleCwgMSk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKG15U0M9PWNzQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjc0luZGV4ID0genBhcmFtcy56Y3Jvc3MuaW5kZXhPZihteVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzSW5kZXggPiAtMSkgeyB6cGFyYW1zLnpjcm9zcy5zcGxpY2UoY3NJbmRleCwgMSk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKG15U0M9PXRpbWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVJbmRleCA9IHpwYXJhbXMuenRpbWUuaW5kZXhPZihteVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVJbmRleCA+IC0xKSB7IHpwYXJhbXMuenRpbWUuc3BsaWNlKGR2SW5kZXgsIDEpOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihteVNDPT1ub21Db2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vbUluZGV4ID0genBhcmFtcy56bm9tLmluZGV4T2YobXlUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub21JbmRleCA+IC0xKSB7IHpwYXJhbXMuem5vbS5zcGxpY2UoZHZJbmRleCwgMSk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBub2RlUmVzZXQoYWxsTm9kZXNbZmluZE5vZGVJbmRleChteVRleHQpXSk7XG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YXJDb2xvcjtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmYWtlQ2xpY2soKTtcbiAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBwb3B1bGF0ZVBvcG92ZXIoKTsgLy8gcGlwZXMgaW4gdGhlIHN1bW1hcnkgc3RhdHNcbiAgICAgICAgXG4gICAgICAgIC8vIGRyb3AgZG93biBtZW51IGZvciB0cmFuZm9ybWF0aW9uIHRvb2xiYXJcbiAgICAgICAgZDMuc2VsZWN0KFwiI3RyYW5zU2VsXCIpXG4gICAgICAgIC5kYXRhKHYpXG4gICAgICAgIC5hcHBlbmQoXCJvcHRpb25cIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge3JldHVybiBkOyB9KTtcbn1cblxuLy8gYmVsb3cgZnJvbSBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9jb3JzLyBmb3IgY3Jvc3Mtb3JpZ2luIHJlc291cmNlIHNoYXJpbmdcbi8vIENyZWF0ZSB0aGUgWEhSIG9iamVjdC5cbmZ1bmN0aW9uIGNyZWF0ZUNPUlNSZXF1ZXN0KG1ldGhvZCwgdXJsLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBpZiAoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHIpIHtcbiAgICAgICAgLy8gWEhSIGZvciBDaHJvbWUvRmlyZWZveC9PcGVyYS9TYWZhcmkuXG4gICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIFhEb21haW5SZXF1ZXN0IGZvciBJRS5cbiAgICAgICAgeGhyID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDT1JTIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgIHhociA9IG51bGw7XG4gICAgfVxuLy8gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3BsYWluJyk7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICByZXR1cm4geGhyO1xuICAgIFxufVxuXG5cbi8vIE1ha2UgdGhlIGFjdHVhbCBDT1JTIHJlcXVlc3QuXG5mdW5jdGlvbiBtYWtlQ29yc1JlcXVlc3QodXJsLGJ0bixjYWxsYmFjaywgd2FybmluZ2NhbGxiYWNrLCBqc29uc3RyaW5nKSB7XG4gICAgdmFyIHhociA9IGNyZWF0ZUNPUlNSZXF1ZXN0KCdQT1NUJywgdXJsKTtcbiAgICBpZiAoIXhocikge1xuICAgICAgICBhbGVydCgnQ09SUyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVzcG9uc2UgaGFuZGxlcnMgZm9yIGFzeW5jaHJvbm91cyBsb2FkXG4gICAgLy8gb25sb2FkIG9yIG9ucmVhZHlzdGF0ZWNoYW5nZT9cbiAgICBcbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFxuICAgICAgdmFyIHRleHQgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgY29uc29sZS5sb2coXCJ0ZXh0IFwiLCB0ZXh0KTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIganNvbiA9IEpTT04ucGFyc2UodGV4dCk7ICAgLy8gc2hvdWxkIHdyYXAgaW4gdHJ5IC8gY2F0Y2hcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGVycikge1xuICAgICAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgICAgICAgICBzZWxlY3RMYWRkYS5zdG9wKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgYWxlcnQoJ0Vycm9yOiBDb3VsZCBub3QgcGFyc2UgaW5jb21pbmcgSlNPTi4nKTtcbiAgICAgICAgfVxuXG4gICAgICBpZiAobmFtZXNbMF0gPT0gXCJ3YXJuaW5nXCIpe1xuICAgICAgICB3YXJuaW5nY2FsbGJhY2soYnRuKTtcbiAgICAgICAgYWxlcnQoXCJXYXJuaW5nOiBcIiArIGpzb24ud2FybmluZyk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgY2FsbGJhY2soYnRuLCBqc29uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG5vdGU6IHhoci5yZWFkeXN0YXRlIHNob3VsZCBiZSA0LCBhbmQgc3RhdHVzIHNob3VsZCBiZSAyMDAuICBhIHN0YXR1cyBvZiAwIG9jY3VycyB3aGVuIHRoZSB1cmwgYmVjb21lcyB0b28gbGFyZ2VcbiAgICAgICAgaWYoeGhyLnN0YXR1cz09MCkge1xuICAgICAgICAgICAgYWxlcnQoJ1RoZXJlIHdhcyBhbiBlcnJvciBtYWtpbmcgdGhlIHJlcXVlc3QuIHhtbGh0dHByZXF1ZXN0IHN0YXR1cyBpcyAwLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoeGhyLnJlYWR5U3RhdGUhPTQpIHtcbiAgICAgICAgICAgIGFsZXJ0KCdUaGVyZSB3YXMgYW4gZXJyb3IgbWFraW5nIHRoZSByZXF1ZXN0LiB4bWxodHRwcmVxdWVzdCByZWFkeXN0YXRlIGlzIG5vdCA0LicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWxlcnQoJ1dvb3BzLCB0aGVyZSB3YXMgYW4gZXJyb3IgbWFraW5nIHRoZSByZXF1ZXN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKHhocik7XG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpO1xuICAgICAgICBzZWxlY3RMYWRkYS5zdG9wKCk7XG4gICAgfTtcbiAgICB4aHIuc2VuZChqc29uc3RyaW5nKTtcbn1cblxuXG5mdW5jdGlvbiBsZWdlbmQoYykgeyAvLyB0aGlzIGNvdWxkIGJlIG1hZGUgc21hcnRlclxuICAgIGlmICh6cGFyYW1zLnp0aW1lLmxlbmd0aCE9MCB8IHpwYXJhbXMuemNyb3NzLmxlbmd0aCE9MCB8IHpwYXJhbXMuemR2Lmxlbmd0aCE9MCB8IHpwYXJhbXMuem5vbS5sZW5ndGghPTApIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsZWdlbmRcIikuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJkaXNwbGF5OmJsb2NrXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsZWdlbmRcIikuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJkaXNwbGF5Om5vbmVcIik7XG4gICAgfVxuICAgIFxuICAgIFxuICAgIGlmKHpwYXJhbXMuenRpbWUubGVuZ3RoPT0wKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGltZUJ1dHRvblwiKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImNsZWFyZml4IGhpZGVcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRpbWVCdXR0b25cIikuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJjbGVhcmZpeCBzaG93XCIpO1xuICAgIH1cbiAgICBpZih6cGFyYW1zLnpjcm9zcy5sZW5ndGg9PTApIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjc0J1dHRvblwiKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImNsZWFyZml4IGhpZGVcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNzQnV0dG9uXCIpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiY2xlYXJmaXggc2hvd1wiKTtcbiAgICB9XG4gICAgaWYoenBhcmFtcy56ZHYubGVuZ3RoPT0wKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHZCdXR0b25cIikuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJjbGVhcmZpeCBoaWRlXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkdkJ1dHRvblwiKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImNsZWFyZml4IHNob3dcIik7XG4gICAgfVxuICAgIGlmKHpwYXJhbXMuem5vbS5sZW5ndGg9PTApIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJub21CdXR0b25cIikuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJjbGVhcmZpeCBoaWRlXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJub21CdXR0b25cIikuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJjbGVhcmZpeCBzaG93XCIpO1xuICAgIH1cbiAgICBcbiAgICBib3JkZXJTdGF0ZSgpO1xufVxuXG5cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xufVxuXG4vLyBwcm9ncmFtbWF0aWNhbGx5IGRlc2VsZWN0aW5nIGV2ZXJ5IHNlbGVjdGVkIHZhcmlhYmxlLi4uXG5mdW5jdGlvbiBlcmFzZSgpIHtcbiAgICBsZWZ0cGFuZWxNZWRpdW0oKTtcbiAgICByaWdodHBhbmVsTWVkaXVtKCk7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsZWdlbmRcIikuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJkaXNwbGF5Om5vbmVcIik7XG4gICAgXG4gICAgdGFiTGVmdCgndGFiMScpO1xuICAgIFxuICAgIGpRdWVyeS5mbi5kM0NsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXljb2wgPSBkMy5yZ2IodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBpZihteWNvbC50b1N0cmluZygpPT09dmFyQ29sb3IudG9TdHJpbmcoKSkge3JldHVybjt9XG4gICAgICAgICAgICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcbiAgICAgICAgICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChcImNsaWNrXCIsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH07XG4gICAgJChcIiN0YWIxXCIpLmQzQ2xpY2soKTtcbn1cblxuXG5mdW5jdGlvbiBkZXNlbGVjdChkKSB7XG4gICAgY29uc29sZS5sb2coZCk7XG59XG5cbi8vIGh0dHA6Ly93d3cudHV0b3JpYWxzMmxlYXJuLmNvbS90dXRvcmlhbHMvc2NyaXB0cy9qYXZhc2NyaXB0L3htbC1wYXJzZXItamF2YXNjcmlwdC5odG1sXG5mdW5jdGlvbiBsb2FkWE1MRG9jKFhNTG5hbWUpXG57XG4gICAgdmFyIHhtbERvYztcbiAgICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KVxuICAgIHtcbiAgICAgICAgeG1sRG9jPW5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeG1sRG9jLm9wZW4oXCJHRVRcIixYTUxuYW1lLGZhbHNlKTtcbiAgICAgICAgeG1sRG9jLnNlbmQoXCJcIik7XG4gICAgICAgIHJldHVybiB4bWxEb2MucmVzcG9uc2VYTUw7XG4gICAgfVxuICAgIC8vIElFIDUgYW5kIElFIDZcbiAgICBlbHNlIGlmIChBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTERPTVwiKSlcbiAgICB7XG4gICAgICAgIHhtbERvYz1uZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XG4gICAgICAgIHhtbERvYy5hc3luYz1mYWxzZTtcbiAgICAgICAgeG1sRG9jLmxvYWQoWE1MbmFtZSk7XG4gICAgICAgIHJldHVybiB4bWxEb2M7XG4gICAgfVxuICAgIGFsZXJ0KFwiRXJyb3IgbG9hZGluZyBkb2N1bWVudCFcIik7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cblxuZnVuY3Rpb24gdGFiTGVmdCh0YWIpIHtcbiAgICBcbiAgICBpZih0YWIhPVwidGFiM1wiKSB7bGVmdHRhYj10YWI7fVxuICAgIHZhciB0YWJpID0gdGFiLnN1YnN0cmluZygzKTtcbiAgICBcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGFiMScpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RhYjInKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0YWIzJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgIGlmKHRhYj09PVwidGFiMVwiKSB7XG4gICAgICAgIHN1bW1hcnlIb2xkID0gZmFsc2U7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5TdWJzZXQnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0blZhcmlhYmxlcycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGFjdGl2ZVwiKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJidG5TZWxlY3RcIikuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgXG4gICAgICAgIGQzLnNlbGVjdChcIiNsZWZ0cGFuZWxcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRhYj09PVwidGFiMlwiKSB7XG4gICAgICAgIHN1bW1hcnlIb2xkID0gZmFsc2U7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5WYXJpYWJsZXMnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0blN1YnNldCcpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGFjdGl2ZVwiKTtcbiAgICAgICAgXG4gICAgICAgIGQzLnNlbGVjdChcIiNsZWZ0cGFuZWxcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgaWYodGhpcy5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKT09PVwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeCBleHBhbmRwYW5lbFwiKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJidG5TZWxlY3RcIikuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJidG5TZWxlY3RcIikuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeCBleHBhbmRwYW5lbFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0blN1YnNldCcpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuVmFyaWFibGVzJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICAgIFxuICAgICAgICBkMy5zZWxlY3QoXCIjbGVmdHBhbmVsXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCIpO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhYikuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG59XG5cbmZ1bmN0aW9uIHRhYlJpZ2h0KHRhYmlkKSB7XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kZWxzJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0eCcpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlc3VsdHMnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIFxuICAgIGlmKHRhYmlkPT1cImJ0bk1vZGVsc1wiKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuU2V0eCcpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0blJlc3VsdHMnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5Nb2RlbHMnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBhY3RpdmVcIik7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kZWxzJykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIFxuICAgICAgICBkMy5zZWxlY3QoXCIjcmlnaHRwYW5lbFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFiaWQ9PVwiYnRuU2V0eFwiKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuTW9kZWxzJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuUmVzdWx0cycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0blNldHgnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBhY3RpdmVcIik7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0eCcpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICBcbiAgICAgICAgaWYocmlnaHR0YWI9PVwiYnRuU2V0eFwiICB8IGQzLnNlbGVjdChcIiNyaWdodHBhbmVsXCIpLmF0dHIoXCJjbGFzc1wiKT09XCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCIpIHt0b2dnbGVSKCl9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0YWJpZD09XCJidG5SZXN1bHRzXCIpIHtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5Nb2RlbHMnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5TZXR4Jykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuUmVzdWx0cycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGFjdGl2ZVwiKTtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXN1bHRzJykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIFxuICAgICAgICBpZihlc3RpbWF0ZWQ9PT1mYWxzZSkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3JpZ2h0cGFuZWxcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYocmlnaHR0YWI9PVwiYnRuUmVzdWx0c1wiIHwgZDMuc2VsZWN0KFwiI3JpZ2h0cGFuZWxcIikuYXR0cihcImNsYXNzXCIpPT1cInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIikge3RvZ2dsZVIoKX07XG4gICAgfVxuICAgIFxuICAgIHJpZ2h0dGFiPXRhYmlkOyAvLyBhIGdsb2JhbCB0aGF0IG1heSBiZSBvZiB1c2VcblxuICAgIGZ1bmN0aW9uIHRvZ2dsZVIoKSB7XG4gICAgICAgIGQzLnNlbGVjdChcIiNyaWdodHBhbmVsXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICAgIGlmKHRoaXMuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik9PT1cInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXggZXhwYW5kcGFuZWxcIikge1xuICAgICAgICAgICAgICByZXR1cm4gXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXggZXhwYW5kcGFuZWxcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gdmFyU3VtbWFyeShkKSB7XG5cbiAgICB2YXIgcmludCA9IGQzLmZvcm1hdChcInJcIik7XG5cbiAgICAgICAgdmFyIHN1bW1hcnlkYXRhID0gW10sXG4gICAgICAgIHRtcERhdGFzZXQgPSBbXSwgdDEgPSBbXCJNZWFuOlwiLFwiTWVkaWFuOlwiLFwiTW9zdCBGcmVxOlwiLFwiT2NjdXJyZW5jZXM6XCIsIFwiTWVkaWFuIEZyZXE6XCIsIFwiT2NjdXJyZW5jZXM6XCIsIFwiTGVhc3QgRnJlcTpcIiwgXCJPY2N1cnJlbmNlczpcIiwgIFwiU3RhbmQuRGV2OlwiLFwiTWluaW11bTpcIixcIk1heGltdW06XCIsXCJJbnZhbGlkOlwiLFwiVmFsaWQ6XCIsXCJVbmlxdWVzOlwiLFwiSGVyZmluZGFobDpcIl0sXG4gICAgICAgIHQyID0gWygrZC5tZWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpICwoK2QubWVkaWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpLGQubW9kZSxyaW50KGQuZnJlcW1vZGUpLGQubWlkLCByaW50KGQuZnJlcW1pZCksIGQuZmV3ZXN0LCByaW50KGQuZnJlcWZld2VzdCksKCtkLnNkKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpLCgrZC5taW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCksKCtkLm1heCkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSxyaW50KGQuaW52YWxpZCkscmludChkLnZhbGlkKSxyaW50KGQudW5pcXVlcyksKCtkLmhlcmZpbmRhaGwpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCldLFxuICAgICAgICBpLCBqO1xuICAgICAgICBpZiAocHJpdikge1xuICAgICAgICAgIGlmIChkLm1lYW5DSSkge1xuICAgICAgICAgICAgdDEgPSBbXCJNZWFuOlwiLCBcIk1lZGlhbjpcIixcIk1vc3QgRnJlcTpcIixcIk9jY3VycmVuY2VzOlwiLCBcIk1lZGlhbiBGcmVxOlwiLCBcIk9jY3VycmVuY2VzOlwiLCBcIkxlYXN0IEZyZXE6XCIsIFwiT2NjdXJyZW5jZXM6XCIsICBcIlN0YW5kLkRldjpcIixcIk1pbmltdW06XCIsXCJNYXhpbXVtOlwiLFwiSW52YWxpZDpcIixcIlZhbGlkOlwiLFwiVW5pcXVlczpcIixcIkhlcmZpbmRhaGw6XCJdLFxuICAgICAgICAgIHQyID0gWygrZC5tZWFuKS50b1ByZWNpc2lvbigyKS50b1N0cmluZygpICsgXCIgKFwiICsgKCtkLm1lYW5DSS5sb3dlckJvdW5kKS50b1ByZWNpc2lvbigyKS50b1N0cmluZygpICsgXCIgLSBcIiArICgrZC5tZWFuQ0kudXBwZXJCb3VuZCkudG9QcmVjaXNpb24oMikudG9TdHJpbmcoKSArIFwiKVwiICwoK2QubWVkaWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpLGQubW9kZSxyaW50KGQuZnJlcW1vZGUpLGQubWlkLCByaW50KGQuZnJlcW1pZCksIGQuZmV3ZXN0LCByaW50KGQuZnJlcWZld2VzdCksKCtkLnNkKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpLCgrZC5taW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCksKCtkLm1heCkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSxyaW50KGQuaW52YWxpZCkscmludChkLnZhbGlkKSxyaW50KGQudW5pcXVlcyksKCtkLmhlcmZpbmRhaGwpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCldLFxuICAgICAgICBpLCBqO1xuICAgICAgfSBcbiAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdDEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmKHQyW2ldLmluZGV4T2YoXCJOYU5cIikgPiAtMSB8IHQyW2ldPT1cIk5BXCIgfCB0MltpXT09XCJcIikgY29udGludWU7XG4gICAgICAgICAgICB0bXBEYXRhc2V0PVtdO1xuICAgICAgICAgICAgdG1wRGF0YXNldC5wdXNoKHQxW2ldKTtcbiAgICAgICAgICAgIHRtcERhdGFzZXQucHVzaCh0MltpXSk7XG4gICAgICAgICAgICBzdW1tYXJ5ZGF0YS5wdXNoKHRtcERhdGFzZXQpO1xuICAgICAgICB9O1xuXG4gIC8vICBjb25zb2xlLmxvZyhzdW1tYXJ5ZGF0YSk7XG4gICAgZDMuc2VsZWN0KFwiI3RhYjNcIikgLy90YWIgd2hlbiB5b3UgbW91c2VvdmVyIGEgcGViYmxlXG4gICAgLnNlbGVjdChcInBcIilcbiAgICAuaHRtbChcIjxjZW50ZXI+PGI+XCIgK2QubmFtZSsgXCI8L2I+PGJyPjxpPlwiICtkLmxhYmwrIFwiPC9pPjwvY2VudGVyPlwiKVxuICAgIC5hcHBlbmQoXCJ0YWJsZVwiKVxuICAgIC5zZWxlY3RBbGwoXCJ0clwiKVxuICAgIC5kYXRhKHN1bW1hcnlkYXRhKVxuICAgIC5lbnRlcigpLmFwcGVuZChcInRyXCIpXG4gICAgLnNlbGVjdEFsbChcInRkXCIpXG4gICAgLmRhdGEoZnVuY3Rpb24oZCl7cmV0dXJuIGQ7fSlcbiAgICAuZW50ZXIoKS5hcHBlbmQoXCJ0ZFwiKVxuICAgIC50ZXh0KGZ1bmN0aW9uKGQpe3JldHVybiBkO30pXG4gICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKCl7ZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcImFsaWNlYmx1ZVwiKX0pIC8vIGZvciBubyBkaXNjZXJuYWJsZSByZWFzb25cbiAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpe2QzLnNlbGVjdCh0aGlzKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgXCIjRjlGOUY5XCIpfSkgOyAgLy8oYnV0IG1heWJlIHdlJ2xsIHRoaW5rIG9mIG9uZSlcbi8vICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIik7XG5cbiAgICBcbiAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChcIiN0YWIzXCIpXG4gICAgLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgIC5yZW1vdmUoKTtcbiAgICBcbiAgICBpZih0eXBlb2YgZC5wbG90dHlwZSA9PT0gXCJ1bmRlZmluZWRcIikgeyAvLyAucHJvcGVydGllcyBpcyB1bmRlZmluZWQgZm9yIHNvbWUgdmFyc1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGQucGxvdHR5cGUgPT09IFwiY29udGludW91c1wiKSB7XG4gICAgICAgIGRlbnNpdHkoZCwgZGl2PVwidmFyU3VtbWFyeVwiLCBwcml2KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZC5wbG90dHlwZSA9PT0gXCJiYXJcIikge1xuICAgICAgICBiYXJzKGQsIGRpdj1cInZhclN1bW1hcnlcIiwgcHJpdik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChcIiN0YWIzXCIpICAgICAgLy8gbm8gZ3JhcGggdG8gZHJhdywgYnV0IHN0aWxsIG5lZWQgdG8gcmVtb3ZlIHByZXZpb3VzIGdyYXBoXG4gICAgICAgIC5zZWxlY3RBbGwoXCJzdmdcIilcbiAgICAgICAgLnJlbW92ZSgpO1xuICAgIH07XG5cbn1cblxuZnVuY3Rpb24gcG9wdWxhdGVQb3BvdmVyICgpIHtcbiAgICBcbiAgICBkMy5zZWxlY3QoXCIjdGFiMVwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgLmF0dHIoXCJkYXRhLWNvbnRlbnRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHZhciBvbk5vZGUgPSBmaW5kTm9kZUluZGV4KGQpO1xuICAgICAgICAgIHJldHVybiBwb3BvdmVyQ29udGVudChhbGxOb2Rlc1tvbk5vZGVdKTtcbiAgICAgICAgICB9KTtcbn1cblxuZnVuY3Rpb24gcG9wb3ZlckNvbnRlbnQoZCkge1xuICAgIFxuICAgIHZhciByaW50ID0gZDMuZm9ybWF0KFwiclwiKTtcbiAgICBcbiAgICB2YXIgb3V0dGV4dCA9IFwiXCI7XG5cbiAgICBpZihkLmxhYmwgIT0gXCJcIikgeyBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5MYWJlbDwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz48aT5cIiArIGQubGFibCArIFwiPC9pPjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG4gICAgXG4gICAgaWYgKGQubWVhbiAhPSBcIk5BXCIpIHsgXG4gICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NZWFuPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICBcbiAgICAgIGlmIChwcml2ICYmIGQubWVhbkNJKSB7XG4gICAgICAgIG91dHRleHQgKz0gKCtkLm1lYW4pLnRvUHJlY2lzaW9uKDIpLnRvU3RyaW5nKCkgKyBcIiAoXCIgKyAoK2QubWVhbkNJLmxvd2VyQm91bmQpLnRvUHJlY2lzaW9uKDIpLnRvU3RyaW5nKCkgKyBcIiAtIFwiICsgKCtkLm1lYW5DSS51cHBlckJvdW5kKS50b1ByZWNpc2lvbigyKS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgIH0gZWxzZSB7XG4gICAgICBvdXR0ZXh0ICs9ICgrZC5tZWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpXG4gICAgfVxuICAgICAgb3V0dGV4dCArPSBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG4gICAgXG4gICAgaWYgKGQubWVkaWFuICE9IFwiTkFcIikgeyBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NZWRpYW48L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyAoK2QubWVkaWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIFxuICAgIGlmIChkLm1vZGUgIT0gXCJOQVwiKSB7IG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1vc3QgRnJlcTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIGQubW9kZSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZC5mcmVxbW9kZSAhPSBcIk5BXCIpIHsgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+T2NjdXJyZW5jZXM8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyByaW50KGQuZnJlcW1vZGUpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIFxuICAgIGlmIChkLm1pZCAhPSBcIk5BXCIpIHsgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWVkaWFuIEZyZXE8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyBkLm1pZCArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZC5mcmVxbWlkICE9IFwiTkFcIikgeyBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5PY2N1cnJlbmNlczwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHJpbnQoZC5mcmVxbWlkKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cbiAgICBpZiAoZC5mZXdlc3QgIT0gXCJOQVwiKSB7IG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPkxlYXN0IEZyZXE8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyBkLmZld2VzdCArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZC5mcmVxZmV3ZXN0ICE9IFwiTkFcIikgeyBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5PY2N1cnJlbmNlczwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHJpbnQoZC5mcmVxZmV3ZXN0KSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZC5zZCAhPSBcIk5BXCIpIHsgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+U3RhbmQgRGV2PC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgKCtkLnNkKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIFxuICAgIGlmIChkLm1heCAhPSBcIk5BXCIpIHsgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWF4aW11bTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArICgrZC5tYXgpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG4gICAgXG4gICAgaWYgKGQubWluICE9IFwiTkFcIikgeyBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NaW5pbXVtPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgKCtkLm1pbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cbiAgICBpZiAoZC5pbnZhbGlkICE9IFwiTkFcIikgeyBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5JbnZhbGlkPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgcmludChkLmludmFsaWQpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIGlmIChkLnZhbGlkICE9IFwiTkFcIikgeyBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5WYWxpZDwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHJpbnQoZC52YWxpZCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiA7XG4gICAgfVxuICAgIFxuICAgIGlmIChkLnVuaXF1ZXMgIT0gXCJOQVwiKSB7IG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPlVuaXF1ZXM8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyByaW50KGQudW5pcXVlcykgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG4gICAgaWYgKGQuaGVyZmluZGFobCAhPSBcIk5BXCIpIHsgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+SGVyZmluZGFobDwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArICgrZC5oZXJmaW5kYWhsKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXR0ZXh0O1xufVxuXG5mdW5jdGlvbiBwb3B1cFgoZCkge1xuXG4gICAgdmFyIHRzZiA9IGQzLmZvcm1hdChcIi40clwiKTtcbiAgICB2YXIgcmludCA9IGQzLmZvcm1hdChcInJcIik7XG5cbiAgICAvL0NyZWF0ZSB0aGUgdG9vbHRpcCBsYWJlbFxuICAgIGQzLnNlbGVjdChcIiN0b29sdGlwXCIpXG4gICAgLnN0eWxlKFwibGVmdFwiLCB0ZW1wWCArIFwicHhcIilcbiAgICAuc3R5bGUoXCJ0b3BcIiwgdGVtcFkgKyBcInB4XCIpXG4gICAgLnNlbGVjdChcIiN0b29sdGlwdGV4dFwiKVxuICAgIC5odG1sKFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NZWFuPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgdHNmKGQubWVhbikgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgXG4gICAgICAgICAgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1lZGlhbjwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1lZGlhbikgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgXG4gICAgICAgICAgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1vZGU8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyBkLm1vZGUgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+U3RhbmQgRGV2PC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgdHNmKGQuc2QpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCIgK1xuICBcbiAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWF4aW11bTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1heCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgXG4gICAgICAgICAgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1pbmltdW08L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyB0c2YoZC5taW4pICsgXCI8L3A+PC9kaXY+PC9kaXY+XCIgK1xuICAgICAgICAgIFxuICAgICAgICAgIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5WYWxpZDwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHJpbnQoZC52YWxpZCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG5cbiAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+SW52YWxpZDwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHJpbnQoZC5pbnZhbGlkKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiIFxuICAgICAgICAgICk7XG4gICAgXG4gICAgLyouaHRtbChcIk1lZGlhbjogXCIgKyBkLm1lZGlhbiArIFwiPGJyPk1vZGU6IFwiICsgZC5tb2RlICsgXCI8YnI+TWF4aW11bTogXCIgKyBkLm1heCArIFwiPGJyPk1pbmltdW06IFwiICsgZC5taW4gKyBcIjxicj5NZWFuOiBcIiArIGQubWVhbiArIFwiPGJyPkludmFsaWQ6IFwiICsgZC5pbnZhbGlkICsgXCI8YnI+VmFsaWQ6IFwiICsgZC52YWxpZCArIFwiPGJyPlN0YW5kIERldjogXCIgKyBkLnNkKTsqL1xuICAgIFxuICAgIC8vZDMuc2VsZWN0KFwiI3Rvb2x0aXBcIilcbiAgICAvLy5zdHlsZShcImRpc3BsYXlcIiwgXCJpbmxpbmVcIilcbiAgICAvLy5zZWxlY3QoXCIjdG9vbHRpcCBoMy5wb3BvdmVyLXRpdGxlXCIpXG4gICAgLy8uaHRtbChcIlN1bW1hcnkgU3RhdGlzdGljc1wiKTtcblxufVxuXG5cbmZ1bmN0aW9uIHBhbmVsUGxvdHMoKSB7XG5cbiAgICAvLyBidWlsZCBhcnJheXMgZnJvbSBub2RlcyBpbiBtYWluXG4gICAgdmFyIHZhckFycmF5ID0gW107XG4gICAgdmFyIGlkQXJyYXkgPSBbXTtcbiAgICBcbiAgICBmb3IodmFyIGo9MDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrICkge1xuICAgICAgICB2YXJBcnJheS5wdXNoKG5vZGVzW2pdLm5hbWUucmVwbGFjZSgvXFwofFxcKS9nLCBcIlwiKSk7XG4gICAgICAgIGlkQXJyYXkucHVzaChub2Rlc1tqXS5pZCk7XG4gICAgfVxuICAgIFxuICAgIC8vcmVtb3ZlIGFsbCBwbG90cywgY291bGQgYmUgc21hcnRlciBoZXJlXG4gICAgZDMuc2VsZWN0KFwiI3NldHhcIikuc2VsZWN0QWxsKFwic3ZnXCIpLnJlbW92ZSgpO1xuICAgIGQzLnNlbGVjdChcIiN0YWIyXCIpLnNlbGVjdEFsbChcInN2Z1wiKS5yZW1vdmUoKTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhckFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFsbE5vZGVzW2lkQXJyYXlbaV1dLnNldHhwbG90PWZhbHNlO1xuICAgICAgICBhbGxOb2Rlc1tpZEFycmF5W2ldXS5zdWJzZXRwbG90PWZhbHNlO1xuICAgICAgICAgICAgaWYgKGFsbE5vZGVzW2lkQXJyYXlbaV1dLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIiAmIGFsbE5vZGVzW2lkQXJyYXlbaV1dLnNldHhwbG90PT1mYWxzZSkge1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW2lkQXJyYXlbaV1dLnNldHhwbG90PXRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocHJpdik7XG4gICAgICAgICAgICAgICAgZGVuc2l0eShhbGxOb2Rlc1tpZEFycmF5W2ldXSwgZGl2PVwic2V0eFwiLCBwcml2KTtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tpZEFycmF5W2ldXS5zdWJzZXRwbG90PXRydWU7XG4gICAgICAgICAgICAgICAgZGVuc2l0eShhbGxOb2Rlc1tpZEFycmF5W2ldXSwgZGl2PVwic3Vic2V0XCIsIHByaXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWxsTm9kZXNbaWRBcnJheVtpXV0ucGxvdHR5cGUgPT09IFwiYmFyXCIgJiBhbGxOb2Rlc1tpZEFycmF5W2ldXS5zZXR4cGxvdD09ZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tpZEFycmF5W2ldXS5zZXR4cGxvdD10cnVlO1xuICAgICAgICAgICAgICAgIGJhcnMoYWxsTm9kZXNbaWRBcnJheVtpXV0sIGRpdj1cInNldHhcIiwgcHJpdik7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbaWRBcnJheVtpXV0uc3Vic2V0cGxvdD10cnVlO1xuICAgICAgICAgICAgICAgIGJhcnNTdWJzZXQoYWxsTm9kZXNbaWRBcnJheVtpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgXG4gICAgZDMuc2VsZWN0KFwiI3NldHhcIikuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgdmFyIHJlZ3N0ciA9IC8oLispX3NldHhfKFxcZCspLztcbiAgICAgICAgICB2YXIgbXluYW1lID0gcmVnc3RyLmV4ZWModGhpcy5pZCk7XG4gICAgICAgICAgdmFyIG5vZGVpZCA9IG15bmFtZVsyXTtcbiAgICAgICAgICBteW5hbWUgPSBteW5hbWVbMV07XG4gICAgICAgICAgdmFyIGogPSB2YXJBcnJheS5pbmRleE9mKG15bmFtZSk7XG4gICAgICAgICAgXG4gICAgICAgIGlmKGogPT0gLTEpIHtcbiAgICAgICAgICBhbGxOb2Rlc1tub2RlaWRdLnNldHhwbG90PWZhbHNlO1xuICAgICAgICAgICB2YXIgdGVtcCA9IFwiI1wiLmNvbmNhdChteW5hbWUsXCJfc2V0eF9cIixub2RlaWQpO1xuICAgICAgICAgICBkMy5zZWxlY3QodGVtcClcbiAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICAgICBcbiAgICAgICAgICAgYWxsTm9kZXNbbm9kZWlkXS5zdWJzZXRwbG90PWZhbHNlO1xuICAgICAgICAgICB2YXIgdGVtcCA9IFwiI1wiLmNvbmNhdChteW5hbWUsXCJfdGFiMl9cIixub2RlaWQpO1xuICAgICAgICAgICBkMy5zZWxlY3QodGVtcClcbiAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgICAgfSk7XG59XG5cbi8vIGVhc3kgZnVuY3Rpb25zIHRvIGNvbGxhcHNlIHBhbmVscyB0byBiYXNlXG5mdW5jdGlvbiByaWdodHBhbmVsTWVkaXVtKCkge1xuICAgIGQzLnNlbGVjdChcIiNyaWdodHBhbmVsXCIpXG4gICAgLmF0dHIoXCJjbGFzc1wiLCBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIik7XG59XG5mdW5jdGlvbiBsZWZ0cGFuZWxNZWRpdW0oKSB7XG4gICAgZDMuc2VsZWN0KFwiI2xlZnRwYW5lbFwiKVxuICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCIpO1xufVxuXG4vLyBmdW5jdGlvbiB0byBjb252ZXJ0IGNvbG9yIGNvZGVzXG5mdW5jdGlvbiBoZXhUb1JnYmEoaGV4KSB7XG4gICAgdmFyIGg9aGV4LnJlcGxhY2UoJyMnLCAnJyk7XG4gICAgXG4gICAgdmFyIGJpZ2ludCA9IHBhcnNlSW50KGgsIDE2KTtcbiAgICB2YXIgciA9IChiaWdpbnQgPj4gMTYpICYgMjU1O1xuICAgIHZhciBnID0gKGJpZ2ludCA+PiA4KSAmIDI1NTtcbiAgICB2YXIgYiA9IGJpZ2ludCAmIDI1NTtcbiAgICB2YXIgYSA9ICcwLjUnO1xuICAgIFxuICAgIHJldHVybiBcInJnYmEoXCIgKyByICsgXCIsXCIgKyBnICsgXCIsXCIgKyBiICsgXCIsXCIgKyBhICsgXCIpXCI7XG59XG5cbi8vIGZ1bmN0aW9uIHRha2VzIGEgbm9kZSBhbmQgYSBjb2xvciBhbmQgdXBkYXRlcyB6cGFyYW1zXG5mdW5jdGlvbiBzZXRDb2xvcnMgKG4sIGMpIHtcbiAgICBcbiAgICBpZihuLnN0cm9rZVdpZHRoPT0nMScpIHsgLy8gYWRkaW5nIHRpbWUsIGNzLCBkdiwgbm9tIHRvIGEgbm9kZSB3aXRoIG5vIHN0cm9rZVxuICAgICAgICBuLnN0cm9rZVdpZHRoID0gJzQnO1xuICAgICAgICBuLnN0cm9rZUNvbG9yID0gYztcbiAgICAgICAgbi5ub2RlQ29sID0gdGFnZ2VkQ29sb3I7XG4gICAgICAgIGlmKGR2Q29sb3I9PWMpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFycmF5LCBpZiBub3QsIG1ha2UgaXQgYW4gYXJyYXlcbiAgICAgICAgICAvLyAgY29uc29sZS5sb2coT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHpwYXJhbXMuemR2KSk7XG4gICAgICAgICAgICB6cGFyYW1zLnpkdiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh6cGFyYW1zLnpkdikgPT0gXCJbb2JqZWN0IEFycmF5XVwiID8genBhcmFtcy56ZHYgOiBbXTtcbiAgICAgICAgICAgIHpwYXJhbXMuemR2LnB1c2gobi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGNzQ29sb3I9PWMpIHtcbiAgICAgICAgICAgIHpwYXJhbXMuemNyb3NzID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHpwYXJhbXMuemNyb3NzKSA9PSBcIltvYmplY3QgQXJyYXldXCIgPyB6cGFyYW1zLnpjcm9zcyA6IFtdO1xuICAgICAgICAgICAgenBhcmFtcy56Y3Jvc3MucHVzaChuLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodGltZUNvbG9yPT1jKSB7XG4gICAgICAgICAgICB6cGFyYW1zLnp0aW1lID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHpwYXJhbXMuenRpbWUpID09IFwiW29iamVjdCBBcnJheV1cIiA/IHpwYXJhbXMuenRpbWUgOiBbXTtcbiAgICAgICAgICAgIHpwYXJhbXMuenRpbWUucHVzaChuLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYobm9tQ29sb3I9PWMpIHtcbiAgICAgICAgICAgIHpwYXJhbXMuem5vbSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh6cGFyYW1zLnpub20pID09IFwiW29iamVjdCBBcnJheV1cIiA/IHpwYXJhbXMuem5vbSA6IFtdO1xuICAgICAgICAgICAgenBhcmFtcy56bm9tLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgIGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgobi5uYW1lKV0ubmF0dXJlPVwibm9taW5hbFwiO1xuICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdD1udWxsLCB0eXBlVHJhbnNmb3JtPXRydWUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBkMy5zZWxlY3QoXCIjdGFiMVwiKS5zZWxlY3QoXCJwI1wiLmNvbmNhdChuLm5hbWUpKVxuICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEoYykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuLnN0cm9rZVdpZHRoPT0nNCcpIHtcbiAgICAgICAgaWYoYz09bi5zdHJva2VDb2xvcikgeyAvLyBkZXNlbGVjdGluZyB0aW1lLCBjcywgZHYsIG5vbVxuICAgICAgICAgICAgbi5zdHJva2VXaWR0aCA9ICcxJztcbiAgICAgICAgICAgIG4uc3Ryb2tlQ29sb3IgPSBzZWxWYXJDb2xvcjtcbiAgICAgICAgICAgIG4ubm9kZUNvbD1jb2xvcnMobi5pZCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjdGFiMVwiKS5zZWxlY3QoXCJwI1wiLmNvbmNhdChuLm5hbWUpKVxuICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHNlbFZhckNvbG9yKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGR2Q29sb3I9PWMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHZJbmRleCA9IHpwYXJhbXMuemR2LmluZGV4T2Yobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZHZJbmRleCA+IC0xKSB7IHpwYXJhbXMuemR2LnNwbGljZShkdkluZGV4LCAxKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihjc0NvbG9yPT1jKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNzSW5kZXggPSB6cGFyYW1zLnpjcm9zcy5pbmRleE9mKG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNzSW5kZXggPiAtMSkgeyB6cGFyYW1zLnpjcm9zcy5zcGxpY2UoY3NJbmRleCwgMSk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYodGltZUNvbG9yPT1jKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVJbmRleCA9IHpwYXJhbXMuenRpbWUuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lSW5kZXggPiAtMSkgeyB6cGFyYW1zLnp0aW1lLnNwbGljZSh0aW1lSW5kZXgsIDEpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKG5vbUNvbG9yPT1jKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vbUluZGV4ID0genBhcmFtcy56bm9tLmluZGV4T2Yobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAobm9tSW5kZXggPiAtMSkgeyB6cGFyYW1zLnpub20uc3BsaWNlKG5vbUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXNbZmluZE5vZGVJbmRleChuLm5hbWUpXS5uYXR1cmU9YWxsTm9kZXNbZmluZE5vZGVJbmRleChuLm5hbWUpXS5kZWZhdWx0TmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obi5uYW1lLCB0PW51bGwsIHR5cGVUcmFuc2Zvcm09dHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBkZXNlbGVjdGluZyB0aW1lLCBjcywgZHYsIG5vbSBBTkQgY2hhbmdpbmcgaXQgdG8gdGltZSwgY3MsIGR2LCBub21cbiAgICAgICAgICAgIGlmKGR2Q29sb3I9PW4uc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHZJbmRleCA9IHpwYXJhbXMuemR2LmluZGV4T2Yobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZHZJbmRleCA+IC0xKSB7IHpwYXJhbXMuemR2LnNwbGljZShkdkluZGV4LCAxKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihjc0NvbG9yPT1uLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNzSW5kZXggPSB6cGFyYW1zLnpjcm9zcy5pbmRleE9mKG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNzSW5kZXggPiAtMSkgeyB6cGFyYW1zLnpjcm9zcy5zcGxpY2UoY3NJbmRleCwgMSk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYodGltZUNvbG9yPT1uLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVJbmRleCA9IHpwYXJhbXMuenRpbWUuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lSW5kZXggPiAtMSkgeyB6cGFyYW1zLnp0aW1lLnNwbGljZSh0aW1lSW5kZXgsIDEpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKG5vbUNvbG9yPT1uLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vbUluZGV4ID0genBhcmFtcy56bm9tLmluZGV4T2Yobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAobm9tSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpub20uc3BsaWNlKG5vbUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXNbZmluZE5vZGVJbmRleChuLm5hbWUpXS5uYXR1cmU9YWxsTm9kZXNbZmluZE5vZGVJbmRleChuLm5hbWUpXS5kZWZhdWx0TmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obi5uYW1lLCB0PW51bGwsIHR5cGVUcmFuc2Zvcm09dHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbi5zdHJva2VDb2xvciA9IGM7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjdGFiMVwiKS5zZWxlY3QoXCJwI1wiLmNvbmNhdChuLm5hbWUpKVxuICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKGMpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoZHZDb2xvcj09Yykge3pwYXJhbXMuemR2LnB1c2gobi5uYW1lKTt9XG4gICAgICAgICAgICBlbHNlIGlmKGNzQ29sb3I9PWMpIHt6cGFyYW1zLnpjcm9zcy5wdXNoKG4ubmFtZSk7fVxuICAgICAgICAgICAgZWxzZSBpZih0aW1lQ29sb3I9PWMpIHt6cGFyYW1zLnp0aW1lLnB1c2gobi5uYW1lKTt9XG4gICAgICAgICAgICBlbHNlIGlmKG5vbUNvbG9yPT1jKSB7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56bm9tLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KG4ubmFtZSldLm5hdHVyZT1cIm5vbWluYWxcIjtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obi5uYW1lLCB0PW51bGwsIHR5cGVUcmFuc2Zvcm09dHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZnVuY3Rpb24gYm9yZGVyU3RhdGUgKCkge1xuICAgIGlmKHpwYXJhbXMuemR2Lmxlbmd0aD4wKSB7JCgnI2R2QnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIGR2Q29sb3IpO31cbiAgICBlbHNlIHskKCcjZHZCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7fVxuICAgIGlmKHpwYXJhbXMuemNyb3NzLmxlbmd0aD4wKSB7JCgnI2NzQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIGNzQ29sb3IpO31cbiAgICBlbHNlIHskKCcjY3NCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7fVxuICAgIGlmKHpwYXJhbXMuenRpbWUubGVuZ3RoPjApIHskKCcjdGltZUJ1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCB0aW1lQ29sb3IpO31cbiAgICBlbHNlIHskKCcjdGltZUJ1dHRvbicpLmNzcygnYm9yZGVyLWNvbG9yJywgJyNjY2MnKTt9XG4gICAgaWYoenBhcmFtcy56bm9tLmxlbmd0aD4wKSB7JCgnI25vbUJ1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCBub21Db2xvcik7fVxuICAgIGVsc2UgeyQoJyNub21CdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7fVxufVxuXG4vLyBzbWFsbCBhcHBlYXJhbmNlIHJlc2V0cywgYnV0IHBlcmhhcHMgdGhpcyB3aWxsIGJlY29tZSBhIGhhcmQgcmVzZXQgYmFjayB0byBhbGwgb3JpZ2luYWwgYWxsTm9kZSB2YWx1ZXM/XG5mdW5jdGlvbiBub2RlUmVzZXQgKG4pIHtcbiAgICBuLnN0cm9rZUNvbG9yPXNlbFZhckNvbG9yO1xuICAgIG4uc3Ryb2tlV2lkdGg9XCIxXCI7XG4gICAgbi5ub2RlQ29sPW4uYmFzZUNvbDtcbn1cblxuZnVuY3Rpb24gc3Vic2V0U2VsZWN0KGJ0bikge1xuXG4gICAgaWYgKGRhdGF1cmwpIHtcblx0enBhcmFtcy56ZGF0YXVybCA9IGRhdGF1cmw7XG4gICAgfVxuICAgIFxuICAgIGlmKHByb2R1Y3Rpb24gJiYgenBhcmFtcy56c2Vzc2lvbmlkPT1cIlwiKSB7XG4gICAgICAgIGFsZXJ0KFwiV2FybmluZzogRGF0YSBkb3dubG9hZCBpcyBub3QgY29tcGxldGUuIFRyeSBhZ2FpbiBzb29uLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB6cGFyYW1zLnp2YXJzID0gW107XG4gICAgenBhcmFtcy56cGxvdCA9IFtdO1xuICAgIFxuICAgIHZhciBzdWJzZXRFbXB0eSA9IHRydWU7XG4gICAgXG4gICAgLy8gaXMgdGhpcyB0aGUgc2FtZSBhcyB6UG9wKCk/XG4gICAgZm9yKHZhciBqID0wOyBqIDwgbm9kZXMubGVuZ3RoOyBqKysgKSB7IC8vcG9wdWxhdGUgenZhcnMgYW5kIHpzdWJzZXQgYXJyYXlzXG4gICAgICAgIHpwYXJhbXMuenZhcnMucHVzaChub2Rlc1tqXS5uYW1lKTtcbiAgICAgICAgdmFyIHRlbXAgPSBub2Rlc1tqXS5pZDtcbiAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdID0gYWxsTm9kZXNbdGVtcF0uc3Vic2V0cmFuZ2U7XG4gICAgICAgIGlmKHpwYXJhbXMuenN1YnNldFtqXS5sZW5ndGg+MCkge1xuICAgICAgICAgICAgaWYoenBhcmFtcy56c3Vic2V0W2pdWzBdIT1cIlwiKSB7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdWzBdID0gTnVtYmVyKHpwYXJhbXMuenN1YnNldFtqXVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih6cGFyYW1zLnpzdWJzZXRbal1bMV0hPVwiXCIpIHtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpzdWJzZXRbal1bMV0gPSBOdW1iZXIoenBhcmFtcy56c3Vic2V0W2pdWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB6cGFyYW1zLnpwbG90LnB1c2goYWxsTm9kZXNbdGVtcF0ucGxvdHR5cGUpO1xuICAgICAgICBpZih6cGFyYW1zLnpzdWJzZXRbal1bMV0gIT0gXCJcIikge3N1YnNldEVtcHR5PWZhbHNlO30gLy9vbmx5IG5lZWQgdG8gY2hlY2sgb25lXG4gICAgfVxuICAgIFxuICAgIGlmKHN1YnNldEVtcHR5PT10cnVlKSB7XG4gICAgICAgIGFsZXJ0KFwiV2FybmluZzogTm8gbmV3IHN1YnNldCBzZWxlY3RlZC5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdmFyIG91dHR5cGVzID0gW107XG4gICAgZm9yKHZhciBqPTA7IGogPCBhbGxOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBvdXR0eXBlcy5wdXNoKHt2YXJuYW1lc1R5cGVzOmFsbE5vZGVzW2pdLm5hbWUsIG5hdHVyZTphbGxOb2Rlc1tqXS5uYXR1cmUsIG51bWNoYXI6YWxsTm9kZXNbal0ubnVtY2hhciwgYmluYXJ5OmFsbE5vZGVzW2pdLmJpbmFyeSwgaW50ZXJ2YWw6YWxsTm9kZXNbal0uaW50ZXJ2YWx9KTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHN1YnNldHN0dWZmID0ge3pkYXRhdXJsOnpwYXJhbXMuemRhdGF1cmwsIHp2YXJzOnpwYXJhbXMuenZhcnMsIHpzdWJzZXQ6enBhcmFtcy56c3Vic2V0LCB6c2Vzc2lvbmlkOnpwYXJhbXMuenNlc3Npb25pZCwgenBsb3Q6enBhcmFtcy56cGxvdCwgY2FsbEhpc3Rvcnk6Y2FsbEhpc3RvcnksIHR5cGVTdHVmZjpvdXR0eXBlc307XG4gICAgXG4gICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeShzdWJzZXRzdHVmZik7XG4gICAgLy92YXIgYmFzZSA9IHJhcHBVUkwrXCJzdWJzZXRhcHA/c29sYUpTT049XCJcbiAgICB1cmxjYWxsID0gcmFwcFVSTCtcInN1YnNldGFwcFwiOyAvL2Jhc2UuY29uY2F0KGpzb25vdXQpO1xuICAgIHZhciBzb2xhanNvbm91dCA9IFwic29sYUpTT049XCIranNvbm91dDtcbiAgICBjb25zb2xlLmxvZyhcInVybGNhbGwgb3V0OiBcIiwgdXJsY2FsbCk7XG4gICAgY29uc29sZS5sb2coXCJQT1NUIG91dDogXCIsIHNvbGFqc29ub3V0KTtcbiAgICBcblxuICAgIGZ1bmN0aW9uIHN1YnNldFNlbGVjdFN1Y2Nlc3MoYnRuLGpzb24pIHtcbiAgICAgICAgXG4gICAgICAgIHNlbGVjdExhZGRhLnN0b3AoKTsgLy8gc3RvcCBtb3Rpb25cbiAgICAgICAgJChcIiNidG5WYXJpYWJsZXNcIikudHJpZ2dlcihcImNsaWNrXCIpOyAvLyBwcm9ncmFtbWF0aWMgY2xpY2tzXG4gICAgICAgICQoXCIjYnRuTW9kZWxzXCIpLnRyaWdnZXIoXCJjbGlja1wiKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBncmF5T3V0cyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgdmFyIHJDYWxsID0gW107XG4gICAgICAgIHJDYWxsWzBdID0ganNvbi5jYWxsO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8vIHN0b3JlIGNvbnRlbnRzIG9mIHRoZSBwcmUtc3Vic2V0IHNwYWNlXG4gICAgICAgIHpQb3AoKTtcbiAgICAgICAgdmFyIG15Tm9kZXMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBhbGxOb2Rlcyk7XG4gICAgICAgIHZhciBteVBhcmFtcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwge30sIHpwYXJhbXMpO1xuICAgICAgICB2YXIgbXlUcmFucyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHRyYW5zKTtcbiAgICAgICAgdmFyIG15Rm9yY2UgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBmb3JjZXRvZ2dsZSk7XG4gICAgICAgIHZhciBteVByZXByb2Nlc3MgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCBwcmVwcm9jZXNzKTtcbiAgICAgICAgdmFyIG15TG9nID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgbG9nQXJyYXkpO1xuICAgICAgICB2YXIgbXlIaXN0b3J5ID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgY2FsbEhpc3RvcnkpO1xuICAgICAgICBcbiAgICAgICAgc3BhY2VzW215c3BhY2VdID0ge1wiYWxsTm9kZXNcIjpteU5vZGVzLCBcInpwYXJhbXNcIjpteVBhcmFtcywgXCJ0cmFuc1wiOm15VHJhbnMsIFwiZm9yY2VcIjpteUZvcmNlLCBcInByZXByb2Nlc3NcIjpteVByZXByb2Nlc3MsIFwibG9nQXJyYXlcIjpteUxvZywgXCJjYWxsSGlzdG9yeVwiOm15SGlzdG9yeX07XG4gICAgICAgIFxuICAgICAgICAvLyByZW1vdmUgcHJlLXN1YnNldCBzdmdcbiAgICAgICAgdmFyIHNlbGVjdE1lID0gXCIjbVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5hdHRyKCdjbGFzcycsICdpdGVtJyk7XG4gICAgICAgIHNlbGVjdE1lID0gXCIjd2hpdGVzcGFjZVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5yZW1vdmUoKTtcbiAgICAgICAgXG4gICAgICAgLy8gc2VsZWN0TWUgPSBcIm5hdmRvdFwiLmNvbmNhdChteXNwYWNlKTtcbiAgICAgICAvLyB2YXIgbXluYXZkb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3RNZSk7XG4gICAgICAgLy8gbXluYXZkb3QucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgICAgIFxuICAgICAgICBteXNwYWNlID0gc3BhY2VzLmxlbmd0aDtcbiAgICAgICAgY2FsbEhpc3RvcnkucHVzaCh7ZnVuYzpcInN1YnNldFwiLCB6dmFyczpqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLHpwYXJhbXMuenZhcnMpLCB6c3Vic2V0OmpRdWVyeS5leHRlbmQodHJ1ZSwgW10senBhcmFtcy56c3Vic2V0KSwgenBsb3Q6alF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSx6cGFyYW1zLnpwbG90KX0pO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAvLyAgc2VsZWN0TWUgPSBcIm5hdmRvdFwiLmNvbmNhdChteXNwYWNlLTEpO1xuICAgICAgLy8gIG15bmF2ZG90ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZWN0TWUpO1xuICAgICAgICBcbiAgICAgLy8gICB2YXIgbmV3bmF2ZG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuICAgICAvLyAgIG5ld25hdmRvdC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImFjdGl2ZVwiKTtcbiAgICAvLyAgICBzZWxlY3RNZSA9IFwibmF2ZG90XCIuY29uY2F0KG15c3BhY2UpO1xuICAgIC8vICAgIG5ld25hdmRvdC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBzZWxlY3RNZSk7XG4gICAgLy8gICAgbXluYXZkb3QucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3bmF2ZG90LCBteW5hdmRvdC5uZXh0U2libGluZyk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy8gdGhpcyBpcyB0byBiZSB1c2VkIHRvIGdyYXkgb3V0IGFuZCByZW1vdmUgbGlzdGVuZXJzIGZvciB2YXJpYWJsZXMgdGhhdCBoYXZlIGJlZW4gc3Vic2V0dGVkIG91dCBvZiB0aGUgZGF0YVxuICAgICAgICBmdW5jdGlvbiB2YXJPdXQodikge1xuICAgICAgICAgICAgLy8gaWYgaW4gbm9kZXMsIHJlbW92ZVxuICAgICAgICAgICAgLy8gZ3JheSBvdXQgaW4gbGVmdCBwYW5lbFxuICAgICAgICAgICAgLy8gbWFrZSB1bmNsaWNrYWJsZSBpbiBsZWZ0IHBhbmVsXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0TWU9dltpXS5yZXBsYWNlKC9cXFcvZywgXCJfXCIpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGVjdE1lKS5zdHlsZS5jb2xvcj1oZXhUb1JnYmEoZ3JheUNvbG9yKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RNZSA9IFwicCNcIi5jb25jYXQoc2VsZWN0TWUpO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSlcbiAgICAgICAgICAgICAgICAub24oXCJjbGlja1wiLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbG9nQXJyYXkucHVzaChcInN1YnNldDogXCIuY29uY2F0KHJDYWxsWzBdKSk7XG4gICAgICAgIHNob3dMb2coKTtcbiAgICAgICAgcmVXcml0ZUxvZygpO1xuICAgICAgICBcbiAgICAgICAgZDMuc2VsZWN0KFwiI2lubmVyY2Fyb3VzZWxcIilcbiAgICAgICAgLmFwcGVuZCgnZGl2JylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0gYWN0aXZlJylcbiAgICAgICAgLmF0dHIoJ2lkJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgcmV0dXJuIFwibVwiLmNvbmNhdChteXNwYWNlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXBwZW5kKCdzdmcnKVxuICAgICAgICAuYXR0cignaWQnLCAnd2hpdGVzcGFjZScpO1xuICAgICAgICBzdmcgPSBkMy5zZWxlY3QoXCIjd2hpdGVzcGFjZVwiKTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBkMy5qc29uKGpzb24udXJsLCBmdW5jdGlvbihlcnJvciwganNvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgICAgICAgICAgdmFyIGpzb25kYXRhID0ganNvbjtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmb3IodmFyIGtleSBpbiBqc29uZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXlJbmRleCA9IGZpbmROb2RlSW5kZXgoa2V5KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHg9dW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5wbG90eT11bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R2YWx1ZXM9dW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5wbG90dHlwZT1cIlwiO1xuXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgYWxsTm9kZXNbbXlJbmRleF0sIGpzb25kYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zdWJzZXRwbG90PWZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zdWJzZXRyYW5nZT1bXCJcIixcIlwiXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0uc2V0eHBsb3Q9ZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnNldHh2YWxzPVtcIlwiLFwiXCJdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZihhbGxOb2Rlc1tteUluZGV4XS52YWxpZD09MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JheU91dHMucHVzaChhbGxOb2Rlc1tteUluZGV4XS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLmdyYXlvdXQ9dHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJlUGxvdCgpO1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlUG9wb3ZlcigpO1xuICAgICAgICAgICAgICAgIGxheW91dCh2PVwiYWRkXCIpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICB2YXJPdXQoZ3JheU91dHMpO1xuICAgIH1cbiAgICBcbiAgICBcbiAgICBmdW5jdGlvbiBzdWJzZXRTZWxlY3RGYWlsKGJ0bikge1xuICAgICAgICBzZWxlY3RMYWRkYS5zdG9wKCk7IC8vc3RvcCBtb3Rpb25cbiAgICB9XG4gICAgXG4gICAgc2VsZWN0TGFkZGEuc3RhcnQoKTsgLy9zdGFydCBidXR0b24gbW90aW9uXG4gICAgbWFrZUNvcnNSZXF1ZXN0KHVybGNhbGwsYnRuLCBzdWJzZXRTZWxlY3RTdWNjZXNzLCBzdWJzZXRTZWxlY3RGYWlsLCBzb2xhanNvbm91dCk7XG4gICAgXG59XG5cbmZ1bmN0aW9uIHJlYWRQcmVwcm9jZXNzKHVybCwgcCwgdiwgY2FsbGJhY2spIHtcbiAgICBjb25zb2xlLmxvZyh1cmwpO1xuICAgIGQzLmpzb24odXJsLCBmdW5jdGlvbihlcnJvciwganNvbikge1xuICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgICAgICAgIHZhciBqc29uZGF0YSA9IGpzb247XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW5zaWRlIHJlYWRQcmVwcm9jZXNzIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coanNvbmRhdGEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coanNvbmRhdGFbXCJ2YXJpYWJsZXNcIl0pO1xuXG4gICAgICAgICAgICBpZihqc29uZGF0YS5kYXRhc2V0LnByaXYpe1xuICAgICAgICAgICAgICBwcml2ID0ganNvbmRhdGFbXCJkYXRhc2V0XCJdW1wicHJpdlwiXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vY29weWluZyB0aGUgb2JqZWN0XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBqc29uZGF0YVtcInZhcmlhYmxlc1wiXSkge1xuICAgICAgICAgICAgICAgIHBba2V5XSA9IGpzb25kYXRhW1widmFyaWFibGVzXCJdW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIndlJ3JlIGhlcmVcIilcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbn1cblxuLypcbmZ1bmN0aW9uIGRlbFNwYWNlKCkge1xuICAgIGlmIChzcGFjZXMubGVuZ3RoPT09MCB8IChzcGFjZXMubGVuZ3RoPT09MSAmIG15c3BhY2U9PT0wKSkge3JldHVybjt9XG4gICAgdmFyIGxhc3RTcGFjZSA9IGZhbHNlO1xuICAgIGlmKG15c3BhY2UgPj0gc3BhY2VzLmxlbmd0aC0xKSB7IGxhc3RTcGFjZT10cnVlOyB9XG4gICAgc3BhY2VzLnNwbGljZShteXNwYWNlLCAxKTtcbiAgICBcbiAgICAvLyByZW1vdmUgY3VycmVudCB3aGl0ZXNwYWNlXG4gICAgdmFyIHNlbGVjdE1lID0gXCIjbVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpLmF0dHIoJ2NsYXNzJywgJ2l0ZW0nKTtcbiAgICBzZWxlY3RNZSA9IFwiI3doaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5yZW1vdmUoKTtcbiAgICBcbiAgICAvLyByZW1vdmUgbGFzdCBuYXZkb3RcbiAgICBzZWxlY3RNZSA9IFwibmF2ZG90XCIuY29uY2F0KHNwYWNlcy5sZW5ndGgpO1xuICAgIHZhciBteW5hdmRvdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGVjdE1lKTtcbiAgICBteW5hdmRvdC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKG15bmF2ZG90KTsgLy8gcmVtb3ZlIGZyb20gcGFyZW50IHRvIHJlbW92ZSB0aGUgcG9pbnRlciB0byB0aGUgY2hpbGRcbiAgICBcbiAgICAvLyByZW1vdmUgbGFzdCBpbm5lciBjYXJvdXNlbCBtXG4gICAgc2VsZWN0TWUgPSBcIm1cIi5jb25jYXQoc3BhY2VzLmxlbmd0aCk7XG4gICAgdmFyIG15bmF2ZG90ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZWN0TWUpO1xuICAgIG15bmF2ZG90LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQobXluYXZkb3QpO1xuICAgIFxuICAgIGlmKGxhc3RTcGFjZSkgeyBteXNwYWNlID0gbXlzcGFjZS0xOyB9XG4gICAgXG4gICAgc2VsZWN0TWUgPSBcIm5hdmRvdFwiLmNvbmNhdChteXNwYWNlKTtcbiAgICBuZXduYXZkb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3RNZSk7XG4gICAgbmV3bmF2ZG90LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYWN0aXZlXCIpO1xuICAgIFxuICAgIC8vIGFkZCB3aGl0ZXNwYWNlIGJhY2sgaW4gdG8gY3VycmVudCBpbm5lciBjYXJvdXNlbCBtXG4gICAgc2VsZWN0TWUgPSBcIiNtXCIuY29uY2F0KG15c3BhY2UpO1xuICAgIGQzLnNlbGVjdChzZWxlY3RNZSkuYXR0cignY2xhc3MnLCAnaXRlbSBhY3RpdmUnKVxuICAgIC5hcHBlbmQoJ3N2ZycpLmF0dHIoJ2lkJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIndoaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICBhbGxOb2RlcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHNwYWNlc1tteXNwYWNlXS5hbGxOb2Rlcyk7XG4gICAgenBhcmFtcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwge30sIHNwYWNlc1tteXNwYWNlXS56cGFyYW1zKTtcbiAgICB0cmFucyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHNwYWNlc1tteXNwYWNlXS50cmFucyk7XG4gICAgZm9yY2V0b2dnbGUgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBzcGFjZXNbbXlzcGFjZV0uZm9yY2UpO1xuICAgIHByZXByb2Nlc3MgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCBzcGFjZXNbbXlzcGFjZV0ucHJlcHJvY2Vzcyk7XG4gICAgXG4gICAgc2VsZWN0TWUgPSBcIiN3aGl0ZXNwYWNlXCIuY29uY2F0KG15c3BhY2UpO1xuICAgIHN2ZyA9IGQzLnNlbGVjdChzZWxlY3RNZSk7XG4gICAgXG4gICAgbGF5b3V0KHY9XCJtb3ZlXCIpO1xufVxuXG5cbi8vIGZvciB0aGUgZm9sbG93aW5nIHRocmVlIGZ1bmN0aW9ucywgdGhlIGdlbmVyYWwgaWRlYSBpcyB0byBzdG9yZSB0aGUgbmV3IGluZm9ybWF0aW9uIGZvciB0aGUgY3VycmVudCBzcGFjZSwgYW5kIHRoZW4gbW92ZSBteXNwYWNlIGFjY29yZGluZyAocmlnaHQ6ICsxLCBsZWZ0OiAtMSwgYWRkU3BhY2U6IHNwYWNlcy5sZW5ndGgpXG5mdW5jdGlvbiBhZGRTcGFjZSgpIHtcblxuICAgIHpQb3AoKTtcbiAgICBcbiAgICAvLyBldmVyeXRoaW5nIHdlIG5lZWQgdG8gc2F2ZSB0aGUgaW1hZ2Ugb2YgdGhlIGN1cnJlbnQgc3BhY2UuXG4gICAgdmFyIG15Tm9kZXMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBhbGxOb2Rlcyk7IC8vIHZlcnkgaW1wb3J0YW50LiB0aGlzIGNsb25lcyB0aGUgYWxsTm9kZXMgb2JqZWN0LCBhbmQgbWF5IHNsb3cgdXMgZG93biBpbiB0aGUgZnV0dXJlLiAgaWYgdXNlciBoaXRzIHBsdXMgNCB0aW1lcywgd2UnbGwgaGF2ZSBmb3VyIGNvcGllcyBvZiB0aGUgc2FtZSBzcGFjZSBpbiBtZW1vcnkuICBjZXJ0YWlubHkgYSB3YXkgdG8gb3B0aW1pemUgdGhpc1xuICAgIHZhciBteVBhcmFtcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwge30sIHpwYXJhbXMpO1xuICAgIHZhciBteVRyYW5zID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgdHJhbnMpO1xuICAgIHZhciBteUZvcmNlID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgZm9yY2V0b2dnbGUpO1xuICAgIHZhciBteVByZXByb2Nlc3MgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCBwcmVwcm9jZXNzKTtcbiAgICB2YXIgbXlMb2cgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBsb2dBcnJheSk7XG4gICAgdmFyIG15SGlzdG9yeSA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGNhbGxIaXN0b3J5KTtcblxuICBcbiAgICBzcGFjZXNbbXlzcGFjZV0gPSB7XCJhbGxOb2Rlc1wiOm15Tm9kZXMsIFwienBhcmFtc1wiOm15UGFyYW1zLCBcInRyYW5zXCI6bXlUcmFucywgXCJmb3JjZVwiOm15Rm9yY2UsIFwicHJlcHJvY2Vzc1wiOm15UHJlcHJvY2VzcywgXCJsb2dBcnJheVwiOm15TG9nLCBcImNhbGxIaXN0b3J5XCI6bXlIaXN0b3J5fTtcbiAgICBcbiAgICB2YXIgc2VsZWN0TWUgPSBcIiNtXCIuY29uY2F0KG15c3BhY2UpO1xuICAgIGQzLnNlbGVjdChzZWxlY3RNZSkuYXR0cignY2xhc3MnLCAnaXRlbScpO1xuICAgIHNlbGVjdE1lID0gXCIjd2hpdGVzcGFjZVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpLnJlbW92ZSgpO1xuICAgIFxuICAgIHNlbGVjdE1lID0gXCJuYXZkb3RcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgdmFyIG15bmF2ZG90ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZWN0TWUpO1xuICAgIG15bmF2ZG90LnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgIFxuICAgIG15c3BhY2UgPSBzcGFjZXMubGVuZ3RoO1xuICAgIFxuICAgIHNlbGVjdE1lID0gXCJuYXZkb3RcIi5jb25jYXQobXlzcGFjZS0xKTtcbiAgICBteW5hdmRvdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGVjdE1lKTtcbiAgICBcbiAgICB2YXIgbmV3bmF2ZG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuICAgIG5ld25hdmRvdC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImFjdGl2ZVwiKTtcbiAgICBzZWxlY3RNZSA9IFwibmF2ZG90XCIuY29uY2F0KG15c3BhY2UpO1xuICAgIG5ld25hdmRvdC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBzZWxlY3RNZSk7XG4gICAgbXluYXZkb3QucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3bmF2ZG90LCBteW5hdmRvdC5uZXh0U2libGluZyk7XG4gICAgXG4gICAgZDMuc2VsZWN0KFwiI2lubmVyY2Fyb3VzZWxcIilcbiAgICAuYXBwZW5kKCdkaXYnKVxuICAgIC5hdHRyKCdjbGFzcycsICdpdGVtIGFjdGl2ZScpXG4gICAgLmF0dHIoJ2lkJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gXCJtXCIuY29uY2F0KG15c3BhY2UudG9TdHJpbmcoKSk7XG4gICAgICAgICAgfSlcbiAgICAuYXBwZW5kKCdzdmcnKVxuICAgIC5hdHRyKCdpZCcsICd3aGl0ZXNwYWNlJyk7XG4gICAgc3ZnID0gZDMuc2VsZWN0KFwiI3doaXRlc3BhY2VcIik7XG5cbiAgICBsYXlvdXQodj1cImFkZFwiKTtcblxufVxuXG5mdW5jdGlvbiBsZWZ0KCkge1xuICAgIFxuICAgIHpQb3AoKTtcbiAgICBcbiAgICB2YXIgbXlOb2RlcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGFsbE5vZGVzKTsgLy8gdmVyeSBpbXBvcnRhbnQuIHRoaXMgY2xvbmVzIHRoZSBhbGxOb2RlcyBvYmplY3QsIGFuZCBtYXkgc2xvdyB1cyBkb3duIGluIHRoZSBmdXR1cmUuICBpZiB1c2VyIGhpdHMgcGx1cyA0IHRpbWVzLCB3ZSdsbCBoYXZlIGZvdXIgY29waWVzIG9mIHRoZSBzYW1lIHNwYWNlIGluIG1lbW9yeS4gIGNlcnRhaW5seSBhIHdheSB0byBvcHRpbWl6ZSB0aGlzXG4gICAgdmFyIG15UGFyYW1zID0galF1ZXJ5LmV4dGVuZCh0cnVlLCB7fSwgenBhcmFtcyk7XG4gICAgdmFyIG15VHJhbnMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCB0cmFucyk7XG4gICAgdmFyIG15Rm9yY2UgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBmb3JjZXRvZ2dsZSk7XG4gICAgdmFyIG15UHJlcHJvY2VzcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwge30sIHByZXByb2Nlc3MpO1xuICAgIHZhciBteUxvZyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGxvZ0FycmF5KTtcbiAgICB2YXIgbXlIaXN0b3J5ID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgY2FsbEhpc3RvcnkpO1xuICAgIFxuICAgIGlmKHR5cGVvZiBzcGFjZXNbbXlzcGFjZV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc3BhY2VzLnB1c2goe1wiYWxsTm9kZXNcIjpteU5vZGVzLCBcInpwYXJhbXNcIjpteVBhcmFtcywgXCJ0cmFuc1wiOm15VHJhbnMsIFwiZm9yY2VcIjpteUZvcmNlLCBcInByZXByb2Nlc3NcIjpteVByZXByb2Nlc3MsIFwibG9nQXJyYXlcIjpteUxvZywgXCJjYWxsSGlzdG9yeVwiOm15SGlzdG9yeX0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3BhY2VzW215c3BhY2VdID0ge1wiYWxsTm9kZXNcIjpteU5vZGVzLCBcInpwYXJhbXNcIjpteVBhcmFtcywgXCJ0cmFuc1wiOm15VHJhbnMsIFwiZm9yY2VcIjpteUZvcmNlLCBcInByZXByb2Nlc3NcIjpteVByZXByb2Nlc3MsIFwibG9nQXJyYXlcIjpteUxvZywgXCJjYWxsSGlzdG9yeVwiOm15SGlzdG9yeX07XG4gICAgfVxuICAgIFxuICAgIGlmKG15c3BhY2U9PT0wKSB7XG4gICAgICAgIG15c3BhY2U9c3BhY2VzLmxlbmd0aC0xOyAvLyBtb3ZlIHRvIGxhc3Qgd2hlbiBsZWZ0IGlzIGNsaWNrIGF0IDBcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG15c3BhY2UgPSBteXNwYWNlLTE7XG4gICAgfVxuICAgIFxuICAgIHNlbGVjdE1lID0gXCIjbVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpXG4gICAgLmFwcGVuZCgnc3ZnJykuYXR0cignaWQnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwid2hpdGVzcGFjZVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgYWxsTm9kZXMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBzcGFjZXNbbXlzcGFjZV0uYWxsTm9kZXMpO1xuICAgIHpwYXJhbXMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCBzcGFjZXNbbXlzcGFjZV0uenBhcmFtcyk7XG4gICAgdHJhbnMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBzcGFjZXNbbXlzcGFjZV0udHJhbnMpO1xuICAgIGZvcmNldG9nZ2xlID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgc3BhY2VzW215c3BhY2VdLmZvcmNlKTtcbiAgICBwcmVwcm9jZXNzID0galF1ZXJ5LmV4dGVuZCh0cnVlLCB7fSwgc3BhY2VzW215c3BhY2VdLnByZXByb2Nlc3MpO1xuICAgIGxvZ0FycmF5ID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgc3BhY2VzW215c3BhY2VdLmxvZ0FycmF5KTtcbiAgICBjYWxsSGlzdG9yeSA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHNwYWNlc1tteXNwYWNlXS5jYWxsSGlzdG9yeSk7XG5cbiAgICBzZWxlY3RNZSA9IFwiI3doaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgc3ZnID0gZDMuc2VsZWN0KHNlbGVjdE1lKTtcbiAgICBcbiAgICByZVBsb3QoKTtcbiAgICBsYXlvdXQodj1cIm1vdmVcIik7XG4gICAgXG4gICAgc2VsZWN0TWUgPSBcIm5hdmRvdFwiLmNvbmNhdChteXNwYWNlKTtcbiAgICBuZXduYXZkb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3RNZSk7XG4gICAgbmV3bmF2ZG90LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYWN0aXZlXCIpO1xuICBcbiAgICBpZihteXNwYWNlPT09c3BhY2VzLmxlbmd0aC0xKSB7XG4gICAgICAgIG15c3BhY2U9MDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG15c3BhY2UgPSBteXNwYWNlKzE7XG4gICAgfVxuXG4gICAgc2VsZWN0TWUgPSBcIm5hdmRvdFwiLmNvbmNhdChteXNwYWNlKTtcbiAgICB2YXIgbXluYXZkb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3RNZSk7XG4gICAgbXluYXZkb3QucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIiwgXCJhY3RpdmVcIik7XG4gICAgXG4gICAgc2VsZWN0TWUgPSBcIiN3aGl0ZXNwYWNlXCIuY29uY2F0KG15c3BhY2UpO1xuICAgIGQzLnNlbGVjdChzZWxlY3RNZSkucmVtb3ZlKCk7XG5cbiAgICBpZihteXNwYWNlPT09MCkge1xuICAgICAgICBteXNwYWNlPXNwYWNlcy5sZW5ndGgtMTsgLy8gbW92ZSB0byBsYXN0IHdoZW4gbGVmdCBpcyBjbGljayBhdCAwXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBteXNwYWNlID0gbXlzcGFjZS0xO1xuICAgIH1cblxuXG4gICAgaWYoZm9yY2V0b2dnbGVbMF09PT1cImZhbHNlXCIpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bkZvcmNlJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYWN0aXZlXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bkZvcmNlJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgfVxuXG4gICAgZDMuc2VsZWN0KFwiI21vZGVsc1wiKS5zZWxlY3RBbGwoXCJwXCIpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCB2YXJDb2xvcik7XG4gICAgc2VsZWN0TWUgPSBcIiNfbW9kZWxfXCIuY29uY2F0KHpwYXJhbXMuem1vZGVsKTtcbiAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpKTtcbiAgICBcbiAgICBzZWxlY3RNZSA9IFwiI3doaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgc3ZnID0gZDMuc2VsZWN0KHNlbGVjdE1lKTtcblxuICAgIGxlZ2VuZCgpO1xuICAgIHNob3dMb2coKTtcbiAgICByZVdyaXRlTG9nKCk7XG4gICAgXG4gLy8gICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG59XG5cbmZ1bmN0aW9uIHJpZ2h0KCkge1xuICAgIHpQb3AoKTtcbiAgICB2YXIgbXlOb2RlcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGFsbE5vZGVzKTtcbiAgICB2YXIgbXlQYXJhbXMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCB6cGFyYW1zKTtcbiAgICB2YXIgbXlUcmFucyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHRyYW5zKTtcbiAgICB2YXIgbXlGb3JjZSA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGZvcmNldG9nZ2xlKTtcbiAgICB2YXIgbXlQcmVwcm9jZXNzID0galF1ZXJ5LmV4dGVuZCh0cnVlLCB7fSwgcHJlcHJvY2Vzcyk7XG4gICAgdmFyIG15TG9nID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgbG9nQXJyYXkpO1xuICAgIHZhciBteUhpc3RvcnkgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBjYWxsSGlzdG9yeSk7XG4gICAgXG4gICAgc3BhY2VzW215c3BhY2VdID0ge1wiYWxsTm9kZXNcIjpteU5vZGVzLCBcInpwYXJhbXNcIjpteVBhcmFtcywgXCJ0cmFuc1wiOm15VHJhbnMsIFwiZm9yY2VcIjpteUZvcmNlLCBcInByZXByb2Nlc3NcIjpteVByZXByb2Nlc3MsIFwibG9nQXJyYXlcIjpteUxvZyxcImNhbGxIaXN0b3J5XCI6bXlIaXN0b3J5fTtcbiAgICBcbiAgXG4gICAgaWYobXlzcGFjZT09PXNwYWNlcy5sZW5ndGgtMSkge1xuICAgICAgICBteXNwYWNlPTA7IC8vIG1vdmUgdG8gbGFzdCB3aGVuIGxlZnQgaXMgY2xpY2sgYXQgMFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbXlzcGFjZSA9IG15c3BhY2UrMTtcbiAgICB9XG5cbiAgICBzZWxlY3RNZSA9IFwiI21cIi5jb25jYXQobXlzcGFjZSk7XG4gICAgZDMuc2VsZWN0KHNlbGVjdE1lKVxuICAgIC5hcHBlbmQoJ3N2ZycpLmF0dHIoJ2lkJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIndoaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgIGFsbE5vZGVzID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgc3BhY2VzW215c3BhY2VdLmFsbE5vZGVzKTtcbiAgICB6cGFyYW1zID0galF1ZXJ5LmV4dGVuZCh0cnVlLCB7fSwgc3BhY2VzW215c3BhY2VdLnpwYXJhbXMpO1xuICAgIHRyYW5zID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgc3BhY2VzW215c3BhY2VdLnRyYW5zKTtcbiAgICBmb3JjZXRvZ2dsZSA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHNwYWNlc1tteXNwYWNlXS5mb3JjZSk7XG4gICAgcHJlcHJvY2VzcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwge30sIHNwYWNlc1tteXNwYWNlXS5wcmVwcm9jZXNzKTtcbiAgICBsb2dBcnJheSA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHNwYWNlc1tteXNwYWNlXS5sb2dBcnJheSk7XG4gICAgY2FsbEhpc3RvcnkgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBzcGFjZXNbbXlzcGFjZV0uY2FsbEhpc3RvcnkpO1xuXG4gICAgc2VsZWN0TWUgPSBcIiN3aGl0ZXNwYWNlXCIuY29uY2F0KG15c3BhY2UpO1xuICAgIHN2ZyA9IGQzLnNlbGVjdChzZWxlY3RNZSk7XG4gICAgXG4gICAgcmVQbG90KCk7XG4gICAgbGF5b3V0KHY9XCJtb3ZlXCIpO1xuXG4gICAgaWYobXlzcGFjZT09PTApIHtcbiAgICAgICAgbXlzcGFjZT1zcGFjZXMubGVuZ3RoLTE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBteXNwYWNlID0gbXlzcGFjZS0xO1xuICAgIH1cbiAgICBcbiAgICBzZWxlY3RNZSA9IFwibmF2ZG90XCIuY29uY2F0KG15c3BhY2UpO1xuICAgIHZhciBteW5hdmRvdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGVjdE1lKTtcbiAgICBteW5hdmRvdC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImFjdGl2ZVwiKTtcbiAgICBcbiAgICBzZWxlY3RNZSA9IFwiI3doaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5yZW1vdmUoKTtcbiAgICBcbiAgICBpZihteXNwYWNlPT09c3BhY2VzLmxlbmd0aC0xKSB7XG4gICAgICAgIG15c3BhY2U9MDsgLy8gbW92ZSB0byBsYXN0IHdoZW4gbGVmdCBpcyBjbGljayBhdCAwXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBteXNwYWNlID0gbXlzcGFjZSsxO1xuICAgIH1cbiAgICBcbiAgICBzZWxlY3RNZSA9IFwibmF2ZG90XCIuY29uY2F0KG15c3BhY2UpO1xuICAgIHZhciBuZXduYXZkb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3RNZSk7XG4gICAgbmV3bmF2ZG90LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYWN0aXZlXCIpO1xuICAgXG4gICAgaWYoZm9yY2V0b2dnbGVbMF09PT1cImZhbHNlXCIpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bkZvcmNlJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYWN0aXZlXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bkZvcmNlJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgfVxuXG4gICAgZDMuc2VsZWN0KFwiI21vZGVsc1wiKS5zZWxlY3RBbGwoXCJwXCIpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCB2YXJDb2xvcik7XG4gICAgc2VsZWN0TWUgPSBcIiNfbW9kZWxfXCIuY29uY2F0KHpwYXJhbXMuem1vZGVsKTtcbiAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpKTtcbiAgICBcbiAgICBzZWxlY3RNZSA9IFwiI3doaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgc3ZnID0gZDMuc2VsZWN0KHNlbGVjdE1lKTtcbiAgICBcbiAgICBsZWdlbmQoKTtcbiAgICBzaG93TG9nKCk7XG4gICAgcmVXcml0ZUxvZygpO1xuICAgIFxuICAvLyAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuKi9cblxuZnVuY3Rpb24gYWJvdXQoKSB7XG4gICAgJCgnI2Fib3V0Jykuc2hvdygpO1xufVxuXG5mdW5jdGlvbiBjbG9zZWFib3V0KCkge1xuICAgICQoJyNhYm91dCcpLmhpZGUoKTtcbn1cblxuZnVuY3Rpb24gb3BlbmNpdGUoKSB7XG4gICAgJCgnI2NpdGUnKS5zaG93KCk7XG59XG5cbmZ1bmN0aW9uIGNsb3NlY2l0ZSh0b2dnbGUpIHtcbiAgICBpZih0b2dnbGU9PWZhbHNlKSB7XG4gICAgICAgICQoJyNjaXRlJykuaGlkZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2xpY2tjaXRlKHRvZ2dsZSkge1xuICAgIGlmKHRvZ2dsZT09ZmFsc2UpIHtcbiAgICAgICAgJCgnI2NpdGUnKS5zaG93KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1lbHNlIHtcbiAgICAgICAgJCgnI2NpdGUnKS5oaWRlKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyBmdW5jdGlvbiB0byByZW1vdmUgYWxsIHRoZSBjaGlsZHJlbiBzdmdzIGluc2lkZSBzdWJzZXQgYW5kIHNldHggZGl2c1xuZnVuY3Rpb24gcmVQbG90KCkge1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiN0YWIyXCIpXG4gICAgICAgIC5zZWxlY3RBbGwoXCJzdmdcIilcbiAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICBcbiAgICAgICAgZDMuc2VsZWN0KFwiI3NldHhcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAucmVtb3ZlKCk7XG4gICAgXG4gICAgLy8gbWFrZSB0aGlzIHNtYXJ0ZXJcbiAgICBmb3IodmFyIGkgPSAwOyBpPGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFsbE5vZGVzW2ldLnNldHhwbG90PWZhbHNlO1xuICAgICAgICBhbGxOb2Rlc1tpXS5zdWJzZXRwbG90PWZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2hvd0xvZygpIHtcbiAgICBpZihsb2dBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2dkaXYnKS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6YmxvY2tcIik7XG4gICAgICAgIGQzLnNlbGVjdChcIiNjb2xsYXBzZUxvZyBkaXYucGFuZWwtYm9keVwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgICAgICAgICAgICAgICAuZGF0YShsb2dBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZ2RpdicpLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZGlzcGxheTpub25lXCIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVXcml0ZUxvZygpIHtcbiAgICBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgIC5yZW1vdmUoKTtcbiAgICBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgIC5kYXRhKGxvZ0FycmF5KVxuICAgIC5lbnRlcigpXG4gICAgLmFwcGVuZChcInBcIilcbiAgICAudGV4dChmdW5jdGlvbihkKXtcbiAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICB9KTtcbn1cblxuXG4vLyBhY3RzIGFzIGlmIHRoZSB1c2VyIGNsaWNrZWQgaW4gd2hpdGVzcGFjZS4gdXNlZnVsIHdoZW4gcmVzdGFydCgpIGlzIG91dHNpZGUgb2Ygc2NvcGVcbmZ1bmN0aW9uIGZha2VDbGljaygpIHtcbiAgICB2YXIgbXl3cyA9IFwiI3doaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgLy8gZDMgYW5kIHByb2dyYW1tYXRpYyBldmVudHMgZG9uJ3QgbWVzaCB3ZWxsLCBoZXJlJ3MgYSBTTyB3b3JrYXJvdW5kIHRoYXQgbG9va3MgZ29vZCBidXQgdXNlcyBqcXVlcnkuLi5cbiAgICBqUXVlcnkuZm4uZDNDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcbiAgICAgICAgICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChcIm1vdXNlZG93blwiLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICB9O1xuICAgICQobXl3cykuZDNDbGljaygpO1xuICAgIFxuICAgIGQzLnNlbGVjdChteXdzKVxuICAgIC5jbGFzc2VkKCdhY3RpdmUnLCBmYWxzZSk7IC8vIHJlbW92ZSBhY3RpdmUgY2xhc3Ncbn1cblxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYXBwX2RkaS5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUFBO0FBU0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBTkE7QUFPQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUZBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZGQTtBQUVBO0FBQ0E7QUFLQTtBQUdBO0FBR0E7QUFFQTtBQUdBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUtBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFHQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFHQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFyQ0E7QUF1Q0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFJQTtBQUlBO0FBSUE7QUFJQTtBQUlBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFLQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBS0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBWEE7QUFZQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQVdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBWEE7QUFZQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!***********************!*\
  !*** ./src/script.js ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n$('#leftpanel span').click(function () {\n    closeLeftPanel();\n});\n$('#rightpanel span').click(function () {\n    closeRightPanel();\n});\n\nfunction closeLeftPanel() {\n    if ($('#leftpanel').hasClass('forceclosepanel')) {\n        // do nothing\n    } else {\n        /*$('#leftpanel .btn-toolbar').hide();*/\n        $('#leftpanel').removeClass('expandpanel');\n        $('#leftpanel > div.row-fluid').toggleClass('closepanel');\n        $('#leftpanel').toggleClass('closepanel');\n        $('#main').toggleClass('svg-leftpanel');\n        $('#btnSelect').css('display', 'none');\n    }\n};\n\nfunction closeRightPanel() {\n    if ($('#leftpanel').hasClass('forceclosepanel')) {\n        // do nothing\n    } else {\n        /*$('#rightpanel .nav-tabs').hide();*/\n        $('#rightpanel').removeClass('expandpanel');\n        $('#rightpanel > div.row-fluid').toggleClass('closepanel');\n        $('#rightpanel').toggleClass('closepanel');\n        $('#main').toggleClass('svg-rightpanel');\n    }\n};\n\nvar myurl = window.location.toString();\nvar fileid = \"\";\nvar cindex = 0;\nif (myurl.indexOf(\"dfId=\") > 0) {\n    fileid = myurl.substring(myurl.indexOf(\"dfId=\") + 5);\n    cindex = fileid.indexOf(\"&\");\n    if (cindex > 0) {\n        fileid = fileid.substring(0, cindex);\n    };\n};\nvar hostname = \"\";\nif (myurl.indexOf(\"host=\") > 0) {\n    hostname = myurl.substring(myurl.indexOf(\"host=\") + 5);\n    cindex = hostname.indexOf(\"&\");\n    if (cindex > 0) {\n        hostname = hostname.substring(0, cindex);\n    };\n};\nvar apikey = \"\";\nif (myurl.indexOf(\"key=\") > 0) {\n    apikey = myurl.substring(myurl.indexOf(\"key=\") + 4);\n    cindex = apikey.indexOf(\"&\");\n    if (cindex > 0) {\n        apikey = apikey.substring(0, cindex);\n    };\n};\nvar ddiurl = \"\";\nif (myurl.indexOf(\"ddiurl=\") > 0) {\n    ddiurl = myurl.substring(myurl.indexOf(\"ddiurl=\") + 7);\n    ddiurl = ddiurl.replace(/%25/g, \"%\");\n    ddiurl = ddiurl.replace(/%3A/g, \":\");\n    ddiurl = ddiurl.replace(/%2F/g, \"/\");\n    cindex = ddiurl.indexOf(\"&\");\n    if (cindex > 0) {\n        ddiurl = ddiurl.substring(0, cindex);\n    };\n};\nvar dataurl = \"\";\nif (myurl.indexOf(\"dataurl=\") > 0) {\n    dataurl = myurl.substring(myurl.indexOf(\"dataurl=\") + 8);\n    dataurl = dataurl.replace(/%25/g, \"%\");\n    dataurl = dataurl.replace(/%3A/g, \":\");\n    dataurl = dataurl.replace(/%2F/g, \"/\");\n    cindex = dataurl.indexOf(\"&\");\n    if (cindex > 0) {\n        dataurl = dataurl.substring(0, cindex);\n    };\n};\n\nconsole.log(\"fileid: \" + fileid);\nconsole.log(\"hostname: \" + hostname);\nconsole.log(\"apikey: \" + apikey);\nconsole.log(\"ddiurl: \" + ddiurl);\nconsole.log(\"dataurl: \" + dataurl);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvc2NyaXB0LmpzPzRmYTIiXSwic291cmNlc0NvbnRlbnQiOlsiJCgnI2xlZnRwYW5lbCBzcGFuJykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgY2xvc2VMZWZ0UGFuZWwoKTtcbn0pO1xuJCgnI3JpZ2h0cGFuZWwgc3BhbicpLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgIGNsb3NlUmlnaHRQYW5lbCgpO1xufSk7XG5cbmZ1bmN0aW9uIGNsb3NlTGVmdFBhbmVsKCkge1xuICAgIGlmICgkKCcjbGVmdHBhbmVsJykuaGFzQ2xhc3MoJ2ZvcmNlY2xvc2VwYW5lbCcpKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9IGVsc2Uge1xuICAgICAgICAvKiQoJyNsZWZ0cGFuZWwgLmJ0bi10b29sYmFyJykuaGlkZSgpOyovXG4gICAgICAgICQoJyNsZWZ0cGFuZWwnKS5yZW1vdmVDbGFzcygnZXhwYW5kcGFuZWwnKTtcbiAgICAgICAgJCgnI2xlZnRwYW5lbCA+IGRpdi5yb3ctZmx1aWQnKS50b2dnbGVDbGFzcygnY2xvc2VwYW5lbCcpO1xuICAgICAgICAkKCcjbGVmdHBhbmVsJykudG9nZ2xlQ2xhc3MoJ2Nsb3NlcGFuZWwnKTtcbiAgICAgICAgJCgnI21haW4nKS50b2dnbGVDbGFzcygnc3ZnLWxlZnRwYW5lbCcpO1xuICAgICAgICAkKCcjYnRuU2VsZWN0JykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBjbG9zZVJpZ2h0UGFuZWwoKSB7XG4gICAgaWYgKCQoJyNsZWZ0cGFuZWwnKS5oYXNDbGFzcygnZm9yY2VjbG9zZXBhbmVsJykpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8qJCgnI3JpZ2h0cGFuZWwgLm5hdi10YWJzJykuaGlkZSgpOyovXG4gICAgICAgICQoJyNyaWdodHBhbmVsJykucmVtb3ZlQ2xhc3MoJ2V4cGFuZHBhbmVsJyk7XG4gICAgICAgICQoJyNyaWdodHBhbmVsID4gZGl2LnJvdy1mbHVpZCcpLnRvZ2dsZUNsYXNzKCdjbG9zZXBhbmVsJyk7XG4gICAgICAgICQoJyNyaWdodHBhbmVsJykudG9nZ2xlQ2xhc3MoJ2Nsb3NlcGFuZWwnKTtcbiAgICAgICAgJCgnI21haW4nKS50b2dnbGVDbGFzcygnc3ZnLXJpZ2h0cGFuZWwnKTtcbiAgICB9XG59O1xuXG52YXIgbXl1cmwgPSB3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKTtcbnZhciBmaWxlaWQgPSBcIlwiO1xudmFyIGNpbmRleCA9IDA7XG5pZiAobXl1cmwuaW5kZXhPZihcImRmSWQ9XCIpID4gMCkge1xuICAgIGZpbGVpZCA9IG15dXJsLnN1YnN0cmluZyhteXVybC5pbmRleE9mKFwiZGZJZD1cIikgKyA1KTtcbiAgICBjaW5kZXggPSBmaWxlaWQuaW5kZXhPZihcIiZcIik7XG4gICAgaWYgKGNpbmRleCA+IDApIHtcbiAgICAgICAgZmlsZWlkID0gZmlsZWlkLnN1YnN0cmluZygwLCBjaW5kZXgpO1xuICAgIH07XG59O1xudmFyIGhvc3RuYW1lID0gXCJcIjtcbmlmIChteXVybC5pbmRleE9mKFwiaG9zdD1cIikgPiAwKSB7XG4gICAgaG9zdG5hbWUgPSBteXVybC5zdWJzdHJpbmcobXl1cmwuaW5kZXhPZihcImhvc3Q9XCIpICsgNSk7XG4gICAgY2luZGV4ID0gaG9zdG5hbWUuaW5kZXhPZihcIiZcIik7XG4gICAgaWYgKGNpbmRleCA+IDApIHtcbiAgICAgICAgaG9zdG5hbWUgPSBob3N0bmFtZS5zdWJzdHJpbmcoMCwgY2luZGV4KTtcbiAgICB9O1xufTtcbnZhciBhcGlrZXkgPSBcIlwiO1xuaWYgKG15dXJsLmluZGV4T2YoXCJrZXk9XCIpID4gMCkge1xuICAgIGFwaWtleSA9IG15dXJsLnN1YnN0cmluZyhteXVybC5pbmRleE9mKFwia2V5PVwiKSArIDQpO1xuICAgIGNpbmRleCA9IGFwaWtleS5pbmRleE9mKFwiJlwiKTtcbiAgICBpZiAoY2luZGV4ID4gMCkge1xuICAgICAgICBhcGlrZXkgPSBhcGlrZXkuc3Vic3RyaW5nKDAsIGNpbmRleCk7XG4gICAgfTtcbn07XG52YXIgZGRpdXJsID0gXCJcIjtcbmlmIChteXVybC5pbmRleE9mKFwiZGRpdXJsPVwiKSA+IDApIHtcbiAgICBkZGl1cmwgPSBteXVybC5zdWJzdHJpbmcobXl1cmwuaW5kZXhPZihcImRkaXVybD1cIikgKyA3KTtcbiAgICBkZGl1cmwgPSBkZGl1cmwucmVwbGFjZSgvJTI1L2csIFwiJVwiKTtcbiAgICBkZGl1cmwgPSBkZGl1cmwucmVwbGFjZSgvJTNBL2csIFwiOlwiKTtcbiAgICBkZGl1cmwgPSBkZGl1cmwucmVwbGFjZSgvJTJGL2csIFwiL1wiKTtcbiAgICBjaW5kZXggPSBkZGl1cmwuaW5kZXhPZihcIiZcIik7XG4gICAgaWYgKGNpbmRleCA+IDApIHtcbiAgICAgICAgZGRpdXJsID0gZGRpdXJsLnN1YnN0cmluZygwLCBjaW5kZXgpO1xuICAgIH07XG59O1xudmFyIGRhdGF1cmwgPSBcIlwiO1xuaWYgKG15dXJsLmluZGV4T2YoXCJkYXRhdXJsPVwiKSA+IDApIHtcbiAgICBkYXRhdXJsID0gbXl1cmwuc3Vic3RyaW5nKG15dXJsLmluZGV4T2YoXCJkYXRhdXJsPVwiKSArIDgpO1xuICAgIGRhdGF1cmwgPSBkYXRhdXJsLnJlcGxhY2UoLyUyNS9nLCBcIiVcIik7XG4gICAgZGF0YXVybCA9IGRhdGF1cmwucmVwbGFjZSgvJTNBL2csIFwiOlwiKTtcbiAgICBkYXRhdXJsID0gZGF0YXVybC5yZXBsYWNlKC8lMkYvZywgXCIvXCIpO1xuICAgIGNpbmRleCA9IGRhdGF1cmwuaW5kZXhPZihcIiZcIik7XG4gICAgaWYgKGNpbmRleCA+IDApIHtcbiAgICAgICAgZGF0YXVybCA9IGRhdGF1cmwuc3Vic3RyaW5nKDAsIGNpbmRleCk7XG4gICAgfTtcbn07XG5cblxuY29uc29sZS5sb2coXCJmaWxlaWQ6IFwiICsgZmlsZWlkKTtcbmNvbnNvbGUubG9nKFwiaG9zdG5hbWU6IFwiICsgaG9zdG5hbWUpO1xuY29uc29sZS5sb2coXCJhcGlrZXk6IFwiICsgYXBpa2V5KTtcbmNvbnNvbGUubG9nKFwiZGRpdXJsOiBcIiArIGRkaXVybCk7XG5jb25zb2xlLmxvZyhcImRhdGF1cmw6IFwiICsgZGF0YXVybCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NjcmlwdC5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 3 */
/* unknown exports provided */
/* all exports used */
/*!********************************************!*\
  !*** ./Ladda/dist/ladda-themeless.min.css ***!
  \********************************************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL0xhZGRhL2Rpc3QvbGFkZGEtdGhlbWVsZXNzLm1pbi5jc3M/MWY5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vTGFkZGEvZGlzdC9sYWRkYS10aGVtZWxlc3MubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 4 */
/* unknown exports provided */
/* all exports used */
/*!*****************!*\
  !*** ./app.css ***!
  \*****************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FwcC5jc3M/N2YyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwLmNzc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 5 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** ./bootstrap/css/bootstrap-theme.min.css ***!
  \***********************************************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Jvb3RzdHJhcC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3M/OTBiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYm9vdHN0cmFwL2Nzcy9ib290c3RyYXAtdGhlbWUubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!******************************!*\
  !*** ./~/mithril/mithril.js ***!
  \******************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(setImmediate, global) {;(function() {\n\"use strict\"\nfunction Vnode(tag, key, attrs0, children, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode(\"[\", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node != null && typeof node !== \"object\") return Vnode(\"#\", undefined, undefined, node === false ? \"\" : node, undefined, undefined)\n\treturn node\n}\nVnode.normalizeChildren = function normalizeChildren(children) {\n\tfor (var i = 0; i < children.length; i++) {\n\t\tchildren[i] = Vnode.normalize(children[i])\n\t}\n\treturn children\n}\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*(\"|'|)((?:\\\\[\"'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = {}\nvar hasOwn = {}.hasOwnProperty\nfunction compileSelector(selector) {\n\tvar match, tag = \"div\", classes = [], attrs = {}\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === \"\" && value !== \"\") tag = value\n\t\telse if (type === \"#\") attrs.id = value\n\t\telse if (type === \".\") classes.push(value)\n\t\telse if (match[3][0] === \"[\") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\([\"'])/g, \"$1\").replace(/\\\\\\\\/g, \"\\\\\")\n\t\t\tif (match[4] === \"class\") classes.push(attrValue)\n\t\t\telse attrs[match[4]] = attrValue || true\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(\" \")\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs}\n}\nfunction execSelector(state, attrs, children) {\n\tvar hasAttrs = false, childList, text\n\tvar className = attrs.className || attrs.class\n\tfor (var key in state.attrs) {\n\t\tif (hasOwn.call(state.attrs, key)) {\n\t\t\tattrs[key] = state.attrs[key]\n\t\t}\n\t}\n\tif (className !== undefined) {\n\t\tif (attrs.class !== undefined) {\n\t\t\tattrs.class = undefined\n\t\t\tattrs.className = className\n\t\t}\n\t\tif (state.attrs.className != null) {\n\t\t\tattrs.className = state.attrs.className + \" \" + className\n\t\t}\n\t}\n\tfor (var key in attrs) {\n\t\tif (hasOwn.call(attrs, key) && key !== \"key\") {\n\t\t\thasAttrs = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === \"#\") {\n\t\ttext = children[0].children\n\t} else {\n\t\tchildList = children\n\t}\n\treturn Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)\n}\nfunction hyperscript(selector) {\n\t// Because sloppy mode sucks\n\tvar attrs = arguments[1], start = 2, children\n\tif (selector == null || typeof selector !== \"string\" && typeof selector !== \"function\" && typeof selector.view !== \"function\") {\n\t\tthrow Error(\"The selector must be either a string or a component.\");\n\t}\n\tif (typeof selector === \"string\") {\n\t\tvar cached = selectorCache[selector] || compileSelector(selector)\n\t}\n\tif (attrs == null) {\n\t\tattrs = {}\n\t} else if (typeof attrs !== \"object\" || attrs.tag != null || Array.isArray(attrs)) {\n\t\tattrs = {}\n\t\tstart = 1\n\t}\n\tif (arguments.length === start + 1) {\n\t\tchildren = arguments[start]\n\t\tif (!Array.isArray(children)) children = [children]\n\t} else {\n\t\tchildren = []\n\t\twhile (start < arguments.length) children.push(arguments[start++])\n\t}\n\tvar normalized = Vnode.normalizeChildren(children)\n\tif (typeof selector === \"string\") {\n\t\treturn execSelector(cached, attrs, normalized)\n\t} else {\n\t\treturn Vnode(selector, attrs.key, attrs, normalized)\n\t}\n}\nhyperscript.trust = function(html) {\n\tif (html == null) html = \"\"\n\treturn Vnode(\"<\", undefined, undefined, html, undefined, undefined)\n}\nhyperscript.fragment = function(attrs1, children) {\n\treturn Vnode(\"[\", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)\n}\nvar m = hyperscript\n/** @constructor */\nvar PromisePolyfill = function(executor) {\n\tif (!(this instanceof PromisePolyfill)) throw new Error(\"Promise must be called with `new`\")\n\tif (typeof executor !== \"function\") throw new TypeError(\"executor must be a function\")\n\tvar self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)\n\tvar instance = self._instance = {resolvers: resolvers, rejectors: rejectors}\n\tvar callAsync = typeof setImmediate === \"function\" ? setImmediate : setTimeout\n\tfunction handler(list, shouldAbsorb) {\n\t\treturn function execute(value) {\n\t\t\tvar then\n\t\t\ttry {\n\t\t\t\tif (shouldAbsorb && value != null && (typeof value === \"object\" || typeof value === \"function\") && typeof (then = value.then) === \"function\") {\n\t\t\t\t\tif (value === self) throw new TypeError(\"Promise can't be resolved w/ itself\")\n\t\t\t\t\texecuteOnce(then.bind(value))\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallAsync(function() {\n\t\t\t\t\t\tif (!shouldAbsorb && list.length === 0) console.error(\"Possible unhandled promise rejection:\", value)\n\t\t\t\t\t\tfor (var i = 0; i < list.length; i++) list[i](value)\n\t\t\t\t\t\tresolvers.length = 0, rejectors.length = 0\n\t\t\t\t\t\tinstance.state = shouldAbsorb\n\t\t\t\t\t\tinstance.retry = function() {execute(value)}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\trejectCurrent(e)\n\t\t\t}\n\t\t}\n\t}\n\tfunction executeOnce(then) {\n\t\tvar runs = 0\n\t\tfunction run(fn) {\n\t\t\treturn function(value) {\n\t\t\t\tif (runs++ > 0) return\n\t\t\t\tfn(value)\n\t\t\t}\n\t\t}\n\t\tvar onerror = run(rejectCurrent)\n\t\ttry {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}\n\t}\n\texecuteOnce(executor)\n}\nPromisePolyfill.prototype.then = function(onFulfilled, onRejection) {\n\tvar self = this, instance = self._instance\n\tfunction handle(callback, list, next, state) {\n\t\tlist.push(function(value) {\n\t\t\tif (typeof callback !== \"function\") next(value)\n\t\t\telse try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}\n\t\t})\n\t\tif (typeof instance.retry === \"function\" && state === instance.state) instance.retry()\n\t}\n\tvar resolveNext, rejectNext\n\tvar promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})\n\thandle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)\n\treturn promise\n}\nPromisePolyfill.prototype.catch = function(onRejection) {\n\treturn this.then(null, onRejection)\n}\nPromisePolyfill.resolve = function(value) {\n\tif (value instanceof PromisePolyfill) return value\n\treturn new PromisePolyfill(function(resolve) {resolve(value)})\n}\nPromisePolyfill.reject = function(value) {\n\treturn new PromisePolyfill(function(resolve, reject) {reject(value)})\n}\nPromisePolyfill.all = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tvar total = list.length, count = 0, values = []\n\t\tif (list.length === 0) resolve([])\n\t\telse for (var i = 0; i < list.length; i++) {\n\t\t\t(function(i) {\n\t\t\t\tfunction consume(value) {\n\t\t\t\t\tcount++\n\t\t\t\t\tvalues[i] = value\n\t\t\t\t\tif (count === total) resolve(values)\n\t\t\t\t}\n\t\t\t\tif (list[i] != null && (typeof list[i] === \"object\" || typeof list[i] === \"function\") && typeof list[i].then === \"function\") {\n\t\t\t\t\tlist[i].then(consume, reject)\n\t\t\t\t}\n\t\t\t\telse consume(list[i])\n\t\t\t})(i)\n\t\t}\n\t})\n}\nPromisePolyfill.race = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tlist[i].then(resolve, reject)\n\t\t}\n\t})\n}\nif (typeof window !== \"undefined\") {\n\tif (typeof window.Promise === \"undefined\") window.Promise = PromisePolyfill\n\tvar PromisePolyfill = window.Promise\n} else if (typeof global !== \"undefined\") {\n\tif (typeof global.Promise === \"undefined\") global.Promise = PromisePolyfill\n\tvar PromisePolyfill = global.Promise\n} else {\n}\nvar buildQueryString = function(object) {\n\tif (Object.prototype.toString.call(object) !== \"[object Object]\") return \"\"\n\tvar args = []\n\tfor (var key0 in object) {\n\t\tdestructure(key0, object[key0])\n\t}\n\treturn args.join(\"&\")\n\tfunction destructure(key0, value) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tdestructure(key0 + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse if (Object.prototype.toString.call(value) === \"[object Object]\") {\n\t\t\tfor (var i in value) {\n\t\t\t\tdestructure(key0 + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse args.push(encodeURIComponent(key0) + (value != null && value !== \"\" ? \"=\" + encodeURIComponent(value) : \"\"))\n\t}\n}\nvar FILE_PROTOCOL_REGEX = new RegExp(\"^file://\", \"i\")\nvar _8 = function($window, Promise) {\n\tvar callbackCount = 0\n\tvar oncompletion\n\tfunction setCompletionCallback(callback) {oncompletion = callback}\n\tfunction finalizer() {\n\t\tvar count = 0\n\t\tfunction complete() {if (--count === 0 && typeof oncompletion === \"function\") oncompletion()}\n\t\treturn function finalize(promise0) {\n\t\t\tvar then0 = promise0.then\n\t\t\tpromise0.then = function() {\n\t\t\t\tcount++\n\t\t\t\tvar next = then0.apply(promise0, arguments)\n\t\t\t\tnext.then(complete, function(e) {\n\t\t\t\t\tcomplete()\n\t\t\t\t\tif (count === 0) throw e\n\t\t\t\t})\n\t\t\t\treturn finalize(next)\n\t\t\t}\n\t\t\treturn promise0\n\t\t}\n\t}\n\tfunction normalize(args, extra) {\n\t\tif (typeof args === \"string\") {\n\t\t\tvar url = args\n\t\t\targs = extra || {}\n\t\t\tif (args.url == null) args.url = url\n\t\t}\n\t\treturn args\n\t}\n\tfunction request(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tif (args.method == null) args.method = \"GET\"\n\t\t\targs.method = args.method.toUpperCase()\n\t\t\tvar useBody = (args.method === \"GET\" || args.method === \"TRACE\") ? false : (typeof args.useBody === \"boolean\" ? args.useBody : true)\n\t\t\tif (typeof args.serialize !== \"function\") args.serialize = typeof FormData !== \"undefined\" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify\n\t\t\tif (typeof args.deserialize !== \"function\") args.deserialize = deserialize\n\t\t\tif (typeof args.extract !== \"function\") args.extract = extract\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\tif (useBody) args.data = args.serialize(args.data)\n\t\t\telse args.url = assemble(args.url, args.data)\n\t\t\tvar xhr = new $window.XMLHttpRequest(),\n\t\t\t\taborted = false,\n\t\t\t\t_abort = xhr.abort\n\t\t\txhr.abort = function abort() {\n\t\t\t\taborted = true\n\t\t\t\t_abort.call(xhr)\n\t\t\t}\n\t\t\txhr.open(args.method, args.url, typeof args.async === \"boolean\" ? args.async : true, typeof args.user === \"string\" ? args.user : undefined, typeof args.password === \"string\" ? args.password : undefined)\n\t\t\tif (args.serialize === JSON.stringify && useBody) {\n\t\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\t\t}\n\t\t\tif (args.deserialize === deserialize) {\n\t\t\t\txhr.setRequestHeader(\"Accept\", \"application/json, text/*\")\n\t\t\t}\n\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials\n\t\t\tfor (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {\n\t\t\t\txhr.setRequestHeader(key, args.headers[key])\n\t\t\t}\n\t\t\tif (typeof args.config === \"function\") xhr = args.config(xhr, args) || xhr\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t// Don't throw errors on xhr.abort().\n\t\t\t\tif(aborted) return\n\t\t\t\tif (xhr.readyState === 4) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))\n\t\t\t\t\t\tif ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {\n\t\t\t\t\t\t\tresolve(cast(args.type, response))\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar error = new Error(xhr.responseText)\n\t\t\t\t\t\t\tfor (var key in response) error[key] = response[key]\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (useBody && (args.data != null)) xhr.send(args.data)\n\t\t\telse xhr.send()\n\t\t})\n\t\treturn args.background === true ? promise0 : finalize(promise0)\n\t}\n\tfunction jsonp(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tvar callbackName = args.callbackName || \"_mithril_\" + Math.round(Math.random() * 1e16) + \"_\" + callbackCount++\n\t\t\tvar script = $window.document.createElement(\"script\")\n\t\t\t$window[callbackName] = function(data) {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\tresolve(cast(args.type, data))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tscript.onerror = function() {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\treject(new Error(\"JSONP request failed\"))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tif (args.data == null) args.data = {}\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\targs.data[args.callbackKey || \"callback\"] = callbackName\n\t\t\tscript.src = assemble(args.url, args.data)\n\t\t\t$window.document.documentElement.appendChild(script)\n\t\t})\n\t\treturn args.background === true? promise0 : finalize(promise0)\n\t}\n\tfunction interpolate(url, data) {\n\t\tif (data == null) return url\n\t\tvar tokens = url.match(/:[^\\/]+/gi) || []\n\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\tvar key = tokens[i].slice(1)\n\t\t\tif (data[key] != null) {\n\t\t\t\turl = url.replace(tokens[i], data[key])\n\t\t\t}\n\t\t}\n\t\treturn url\n\t}\n\tfunction assemble(url, data) {\n\t\tvar querystring = buildQueryString(data)\n\t\tif (querystring !== \"\") {\n\t\t\tvar prefix = url.indexOf(\"?\") < 0 ? \"?\" : \"&\"\n\t\t\turl += prefix + querystring\n\t\t}\n\t\treturn url\n\t}\n\tfunction deserialize(data) {\n\t\ttry {return data !== \"\" ? JSON.parse(data) : null}\n\t\tcatch (e) {throw new Error(data)}\n\t}\n\tfunction extract(xhr) {return xhr.responseText}\n\tfunction cast(type0, data) {\n\t\tif (typeof type0 === \"function\") {\n\t\t\tif (Array.isArray(data)) {\n\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\tdata[i] = new type0(data[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\telse return new type0(data)\n\t\t}\n\t\treturn data\n\t}\n\treturn {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}\n}\nvar requestService = _8(window, PromisePolyfill)\nvar coreRenderer = function($window) {\n\tvar $doc = $window.document\n\tvar $emptyFragment = $doc.createDocumentFragment()\n\tvar onevent\n\tfunction setEventCallback(callback) {return onevent = callback}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tif (typeof tag === \"string\") {\n\t\t\tvnode.state = {}\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase \"#\": return createText(parent, vnode, nextSibling)\n\t\t\t\tcase \"<\": return createHTML(parent, vnode, nextSibling)\n\t\t\t\tcase \"[\": return createFragment(parent, vnode, hooks, ns, nextSibling)\n\t\t\t\tdefault: return createElement(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse return createComponent(parent, vnode, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode, nextSibling) {\n\t\tvnode.dom = $doc.createTextNode(vnode.children)\n\t\tinsertNode(parent, vnode.dom, nextSibling)\n\t\treturn vnode.dom\n\t}\n\tfunction createHTML(parent, vnode, nextSibling) {\n\t\tvar match1 = vnode.children.match(/^\\s*?<(\\w+)/im) || []\n\t\tvar parent1 = {caption: \"table\", thead: \"table\", tbody: \"table\", tfoot: \"table\", tr: \"tbody\", th: \"tr\", td: \"tr\", colgroup: \"table\", col: \"colgroup\"}[match1[1]] || \"div\"\n\t\tvar temp = $doc.createElement(parent1)\n\t\ttemp.innerHTML = vnode.children\n\t\tvnode.dom = temp.firstChild\n\t\tvnode.domSize = temp.childNodes.length\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tif (vnode.children != null) {\n\t\t\tvar children = vnode.children\n\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns)\n\t\t}\n\t\tvnode.dom = fragment.firstChild\n\t\tvnode.domSize = fragment.childNodes.length\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tswitch (vnode.tag) {\n\t\t\tcase \"svg\": ns = \"http://www.w3.org/2000/svg\"; break\n\t\t\tcase \"math\": ns = \"http://www.w3.org/1998/Math/MathML\"; break\n\t\t}\n\t\tvar attrs2 = vnode.attrs\n\t\tvar is = attrs2 && attrs2.is\n\t\tvar element = ns ?\n\t\t\tis ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :\n\t\t\tis ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)\n\t\tvnode.dom = element\n\t\tif (attrs2 != null) {\n\t\t\tsetAttrs(vnode, attrs2, ns)\n\t\t}\n\t\tinsertNode(parent, element, nextSibling)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse {\n\t\t\tif (vnode.text != null) {\n\t\t\t\tif (vnode.text !== \"\") element.textContent = vnode.text\n\t\t\t\telse vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\t}\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children\n\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns)\n\t\t\t\tsetLateAttrs(vnode)\n\t\t\t}\n\t\t}\n\t\treturn element\n\t}\n\tfunction initComponent(vnode, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode.tag.view === \"function\") {\n\t\t\tvnode.state = Object.create(vnode.tag)\n\t\t\tsentinel = vnode.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode.state = void 0\n\t\t\tsentinel = vnode.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === \"function\") ? new vnode.tag(vnode) : vnode.tag(vnode)\n\t\t}\n\t\tvnode._state = vnode.state\n\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\tinitLifecycle(vnode._state, vnode, hooks)\n\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tvar element = createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0\n\t\t\tinsertNode(parent, element, nextSibling)\n\t\t\treturn element\n\t\t}\n\t\telse {\n\t\t\tvnode.domSize = 0\n\t\t\treturn $emptyFragment\n\t\t}\n\t}\n\t//update\n\tfunction updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, undefined)\n\t\telse if (vnodes == null) removeNodes(old, 0, old.length, vnodes)\n\t\telse {\n\t\t\tif (old.length === vnodes.length) {\n\t\t\t\tvar isUnkeyed = false\n\t\t\t\tfor (var i = 0; i < vnodes.length; i++) {\n\t\t\t\t\tif (vnodes[i] != null && old[i] != null) {\n\t\t\t\t\t\tisUnkeyed = vnodes[i].key == null && old[i].key == null\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isUnkeyed) {\n\t\t\t\t\tfor (var i = 0; i < old.length; i++) {\n\t\t\t\t\t\tif (old[i] === vnodes[i]) continue\n\t\t\t\t\t\telse if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))\n\t\t\t\t\t\telse if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)\n\t\t\t\t\t\telse updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\trecycling = recycling || isRecyclable(old, vnodes)\n\t\t\tif (recycling) {\n\t\t\t\tvar pool = old.pool\n\t\t\t\told = old.concat(old.pool)\n\t\t\t}\n\t\t\tvar oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldStart], v = vnodes[start]\n\t\t\t\tif (o === v && !recycling) oldStart++, start++\n\t\t\t\telse if (o == null) oldStart++\n\t\t\t\telse if (v == null) start++\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar o = old[oldEnd]\n\t\t\t\t\tif (o === v && !recycling) oldEnd--, start++\n\t\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\t\telse if (v == null) start++\n\t\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\t\tif (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))\n\t\t\t\t\t\toldEnd--, start++\n\t\t\t\t\t}\n\t\t\t\t\telse break\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldEnd], v = vnodes[end]\n\t\t\t\tif (o === v && !recycling) oldEnd--, end--\n\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\telse if (v == null) end--\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t\tif (o.dom != null) nextSibling = o.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!map) map = getKeyMap(old, oldEnd)\n\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\tvar oldIndex = map[v.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tvar movable = old[oldIndex]\n\t\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\t\tupdateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)\n\t\t\t\t\t\t\tinsertNode(parent, toFragment(movable), nextSibling)\n\t\t\t\t\t\t\told[oldIndex].skip = true\n\t\t\t\t\t\t\tif (movable.dom != null) nextSibling = movable.dom\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar dom = createNode(parent, v, hooks, undefined, nextSibling)\n\t\t\t\t\t\t\tnextSibling = dom\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tend--\n\t\t\t\t}\n\t\t\t\tif (end < start) break\n\t\t\t}\n\t\t\tcreateNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\tremoveNodes(old, oldStart, oldEnd + 1, vnodes)\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode.tag\n\t\tif (oldTag === tag) {\n\t\t\tvnode.state = old.state\n\t\t\tvnode._state = old._state\n\t\t\tvnode.events = old.events\n\t\t\tif (!recycling && shouldNotUpdate(vnode, old)) return\n\t\t\tif (typeof oldTag === \"string\") {\n\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\tif (recycling) {\n\t\t\t\t\t\tvnode.state = {}\n\t\t\t\t\t\tinitLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t\t}\n\t\t\t\t\telse updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase \"#\": updateText(old, vnode); break\n\t\t\t\t\tcase \"<\": updateHTML(parent, old, vnode, nextSibling); break\n\t\t\t\t\tcase \"[\": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode, recycling, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(old, null)\n\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode) {\n\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\told.dom.nodeValue = vnode.children\n\t\t}\n\t\tvnode.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode, nextSibling) {\n\t\tif (old.children !== vnode.children) {\n\t\t\ttoFragment(old)\n\t\t\tcreateHTML(parent, vnode, nextSibling)\n\t\t}\n\t\telse vnode.dom = old.dom, vnode.domSize = old.domSize\n\t}\n\tfunction updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children = vnode.children\n\t\tvnode.dom = null\n\t\tif (children != null) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (domSize !== 1) vnode.domSize = domSize\n\t\t}\n\t}\n\tfunction updateElement(old, vnode, recycling, hooks, ns) {\n\t\tvar element = vnode.dom = old.dom\n\t\tswitch (vnode.tag) {\n\t\t\tcase \"svg\": ns = \"http://www.w3.org/2000/svg\"; break\n\t\t\tcase \"math\": ns = \"http://www.w3.org/1998/Math/MathML\"; break\n\t\t}\n\t\tif (vnode.tag === \"textarea\") {\n\t\t\tif (vnode.attrs == null) vnode.attrs = {}\n\t\t\tif (vnode.text != null) {\n\t\t\t\tvnode.attrs.value = vnode.text //FIXME handle0 multiple children\n\t\t\t\tvnode.text = undefined\n\t\t\t}\n\t\t}\n\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse if (old.text != null && vnode.text != null && vnode.text !== \"\") {\n\t\t\tif (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text\n\t\t}\n\t\telse {\n\t\t\tif (old.text != null) old.children = [Vnode(\"#\", undefined, undefined, old.text, undefined, old.dom.firstChild)]\n\t\t\tif (vnode.text != null) vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\tupdateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tif (recycling) {\n\t\t\tinitComponent(vnode, hooks)\n\t\t} else {\n\t\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tupdateLifecycle(vnode._state, vnode, hooks)\n\t\t}\n\t\tif (vnode.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse if (old.instance != null) {\n\t\t\tremoveNode(old.instance, null)\n\t\t\tvnode.dom = undefined\n\t\t\tvnode.domSize = 0\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction isRecyclable(old, vnodes) {\n\t\tif (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {\n\t\t\tvar oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0\n\t\t\tvar poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0\n\t\t\tvar vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0\n\t\t\tif (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tfunction getKeyMap(vnodes, end) {\n\t\tvar map = {}, i = 0\n\t\tfor (var i = 0; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tvar key2 = vnode.key\n\t\t\t\tif (key2 != null) map[key2] = i\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\tfunction toFragment(vnode) {\n\t\tvar count0 = vnode.domSize\n\t\tif (count0 != null || vnode.dom == null) {\n\t\t\tvar fragment = $doc.createDocumentFragment()\n\t\t\tif (count0 > 0) {\n\t\t\t\tvar dom = vnode.dom\n\t\t\t\twhile (--count0) fragment.appendChild(dom.nextSibling)\n\t\t\t\tfragment.insertBefore(dom, fragment.firstChild)\n\t\t\t}\n\t\t\treturn fragment\n\t\t}\n\t\telse return vnode.dom\n\t}\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\tfunction insertNode(parent, dom, nextSibling) {\n\t\tif (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\tfunction setContentEditable(vnode) {\n\t\tvar children = vnode.children\n\t\tif (children != null && children.length === 1 && children[0].tag === \"<\") {\n\t\t\tvar content = children[0].children\n\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content\n\t\t}\n\t\telse if (vnode.text != null || children != null && children.length !== 0) throw new Error(\"Child node of a contenteditable must be trusted\")\n\t}\n\t//remove\n\tfunction removeNodes(vnodes, start, end, context) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tif (vnode.skip) vnode.skip = false\n\t\t\t\telse removeNode(vnode, context)\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNode(vnode, context) {\n\t\tvar expected = 1, called = 0\n\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === \"function\") {\n\t\t\tvar result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onbeforeremove === \"function\") {\n\t\t\tvar result = vnode._state.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tcontinuation()\n\t\tfunction continuation() {\n\t\t\tif (++called === expected) {\n\t\t\t\tonremove(vnode)\n\t\t\t\tif (vnode.dom) {\n\t\t\t\t\tvar count0 = vnode.domSize || 1\n\t\t\t\t\tif (count0 > 1) {\n\t\t\t\t\t\tvar dom = vnode.dom\n\t\t\t\t\t\twhile (--count0) {\n\t\t\t\t\t\t\tremoveNodeFromDOM(dom.nextSibling)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tremoveNodeFromDOM(vnode.dom)\n\t\t\t\t\tif (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === \"string\") { //TODO test custom elements\n\t\t\t\t\t\tif (!context.pool) context.pool = [vnode]\n\t\t\t\t\t\telse context.pool.push(vnode)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNodeFromDOM(node) {\n\t\tvar parent = node.parentNode\n\t\tif (parent != null) parent.removeChild(node)\n\t}\n\tfunction onremove(vnode) {\n\t\tif (vnode.attrs && typeof vnode.attrs.onremove === \"function\") vnode.attrs.onremove.call(vnode.state, vnode)\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onremove === \"function\") vnode._state.onremove.call(vnode.state, vnode)\n\t\tif (vnode.instance != null) onremove(vnode.instance)\n\t\telse {\n\t\t\tvar children = vnode.children\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//attrs2\n\tfunction setAttrs(vnode, attrs2, ns) {\n\t\tfor (var key2 in attrs2) {\n\t\t\tsetAttr(vnode, key2, null, attrs2[key2], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode, key2, old, value, ns) {\n\t\tvar element = vnode.dom\n\t\tif (key2 === \"key\" || key2 === \"is\" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== \"object\" || typeof value === \"undefined\" || isLifecycleMethod(key2)) return\n\t\tvar nsLastIndex = key2.indexOf(\":\")\n\t\tif (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === \"xlink\") {\n\t\t\telement.setAttributeNS(\"http://www.w3.org/1999/xlink\", key2.slice(nsLastIndex + 1), value)\n\t\t}\n\t\telse if (key2[0] === \"o\" && key2[1] === \"n\" && typeof value === \"function\") updateEvent(vnode, key2, value)\n\t\telse if (key2 === \"style\") updateStyle(element, old, value)\n\t\telse if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {\n\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\tif (vnode.tag === \"input\" && key2 === \"value\" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return\n\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\tif (vnode.tag === \"select\" && key2 === \"value\" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return\n\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\tif (vnode.tag === \"option\" && key2 === \"value\" && vnode.dom.value == value) return\n\t\t\t// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.\n\t\t\tif (vnode.tag === \"input\" && key2 === \"type\") {\n\t\t\t\telement.setAttribute(key2, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t\telement[key2] = value\n\t\t}\n\t\telse {\n\t\t\tif (typeof value === \"boolean\") {\n\t\t\t\tconsole.log(element, key2);\n\t\t\t\tif (value) element.setAttribute(key2, \"\")\n\t\t\t\telse element.removeAttribute(key2)\n\t\t\t}\n\t\t\telse element.setAttribute(key2 === \"className\" ? \"class\" : key2, value)\n\t\t}\n\t}\n\tfunction setLateAttrs(vnode) {\n\t\tvar attrs2 = vnode.attrs\n\t\tif (vnode.tag === \"select\" && attrs2 != null) {\n\t\t\tif (\"value\" in attrs2) setAttr(vnode, \"value\", null, attrs2.value, undefined)\n\t\t\tif (\"selectedIndex\" in attrs2) setAttr(vnode, \"selectedIndex\", null, attrs2.selectedIndex, undefined)\n\t\t}\n\t}\n\tfunction updateAttrs(vnode, old, attrs2, ns) {\n\t\tif (attrs2 != null) {\n\t\t\tfor (var key2 in attrs2) {\n\t\t\t\tsetAttr(vnode, key2, old && old[key2], attrs2[key2], ns)\n\t\t\t}\n\t\t}\n\t\tif (old != null) {\n\t\t\tfor (var key2 in old) {\n\t\t\t\tif (attrs2 == null || !(key2 in attrs2)) {\n\t\t\t\t\tif (key2 === \"className\") key2 = \"class\"\n\t\t\t\t\tif (key2[0] === \"o\" && key2[1] === \"n\" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)\n\t\t\t\t\telse if (key2 !== \"key\") vnode.dom.removeAttribute(key2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode, attr) {\n\t\treturn attr === \"value\" || attr === \"checked\" || attr === \"selectedIndex\" || attr === \"selected\" && vnode.dom === $doc.activeElement\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === \"oninit\" || attr === \"oncreate\" || attr === \"onupdate\" || attr === \"onremove\" || attr === \"onbeforeremove\" || attr === \"onbeforeupdate\"\n\t}\n\tfunction isAttribute(attr) {\n\t\treturn attr === \"href\" || attr === \"list\" || attr === \"form\" || attr === \"width\" || attr === \"height\"// || attr === \"type\"\n\t}\n\tfunction isCustomElement(vnode){\n\t\treturn vnode.attrs.is || vnode.tag.indexOf(\"-\") > -1\n\t}\n\tfunction hasIntegrationMethods(source) {\n\t\treturn source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)\n\t}\n\t//style\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) element.style.cssText = \"\", old = null\n\t\tif (style == null) element.style.cssText = \"\"\n\t\telse if (typeof style === \"string\") element.style.cssText = style\n\t\telse {\n\t\t\tif (typeof old === \"string\") element.style.cssText = \"\"\n\t\t\tfor (var key2 in style) {\n\t\t\t\telement.style[key2] = style[key2]\n\t\t\t}\n\t\t\tif (old != null && typeof old !== \"string\") {\n\t\t\t\tfor (var key2 in old) {\n\t\t\t\t\tif (!(key2 in style)) element.style[key2] = \"\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//event\n\tfunction updateEvent(vnode, key2, value) {\n\t\tvar element = vnode.dom\n\t\tvar callback = typeof onevent !== \"function\" ? value : function(e) {\n\t\t\tvar result = value.call(element, e)\n\t\t\tonevent.call(element, e)\n\t\t\treturn result\n\t\t}\n\t\tif (key2 in element) element[key2] = typeof value === \"function\" ? callback : null\n\t\telse {\n\t\t\tvar eventName = key2.slice(2)\n\t\t\tif (vnode.events === undefined) vnode.events = {}\n\t\t\tif (vnode.events[key2] === callback) return\n\t\t\tif (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)\n\t\t\tif (typeof value === \"function\") {\n\t\t\t\tvnode.events[key2] = callback\n\t\t\t\telement.addEventListener(eventName, vnode.events[key2], false)\n\t\t\t}\n\t\t}\n\t}\n\t//lifecycle\n\tfunction initLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.oninit === \"function\") source.oninit.call(vnode.state, vnode)\n\t\tif (typeof source.oncreate === \"function\") hooks.push(source.oncreate.bind(vnode.state, vnode))\n\t}\n\tfunction updateLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.onupdate === \"function\") hooks.push(source.onupdate.bind(vnode.state, vnode))\n\t}\n\tfunction shouldNotUpdate(vnode, old) {\n\t\tvar forceVnodeUpdate, forceComponentUpdate\n\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === \"function\") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onbeforeupdate === \"function\") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t\tvnode.instance = old.instance\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\tfunction render(dom, vnodes) {\n\t\tif (!dom) throw new Error(\"Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.\")\n\t\tvar hooks = []\n\t\tvar active = $doc.activeElement\n\t\t// First time0 rendering into a node clears it out\n\t\tif (dom.vnodes == null) dom.textContent = \"\"\n\t\tif (!Array.isArray(vnodes)) vnodes = [vnodes]\n\t\tupdateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, undefined)\n\t\tdom.vnodes = vnodes\n\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t\tif ($doc.activeElement !== active) active.focus()\n\t}\n\treturn {render: render, setEventCallback: setEventCallback}\n}\nfunction throttle(callback) {\n\t//60fps translates to 16.6ms, round it down since setTimeout requires int\n\tvar time = 16\n\tvar last = 0, pending = null\n\tvar timeout = typeof requestAnimationFrame === \"function\" ? requestAnimationFrame : setTimeout\n\treturn function() {\n\t\tvar now = Date.now()\n\t\tif (last === 0 || now - last >= time) {\n\t\t\tlast = now\n\t\t\tcallback()\n\t\t}\n\t\telse if (pending === null) {\n\t\t\tpending = timeout(function() {\n\t\t\t\tpending = null\n\t\t\t\tcallback()\n\t\t\t\tlast = Date.now()\n\t\t\t}, time - (now - last))\n\t\t}\n\t}\n}\nvar _11 = function($window) {\n\tvar renderService = coreRenderer($window)\n\trenderService.setEventCallback(function(e) {\n\t\tif (e.redraw !== false) redraw()\n\t})\n\tvar callbacks = []\n\tfunction subscribe(key1, callback) {\n\t\tunsubscribe(key1)\n\t\tcallbacks.push(key1, throttle(callback))\n\t}\n\tfunction unsubscribe(key1) {\n\t\tvar index = callbacks.indexOf(key1)\n\t\tif (index > -1) callbacks.splice(index, 2)\n\t}\n\tfunction redraw() {\n\t\tfor (var i = 1; i < callbacks.length; i += 2) {\n\t\t\tcallbacks[i]()\n\t\t}\n\t}\n\treturn {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}\n}\nvar redrawService = _11(window)\nrequestService.setCompletionCallback(redrawService.redraw)\nvar _16 = function(redrawService0) {\n\treturn function(root, component) {\n\t\tif (component === null) {\n\t\t\tredrawService0.render(root, [])\n\t\t\tredrawService0.unsubscribe(root)\n\t\t\treturn\n\t\t}\n\t\t\n\t\tif (component.view == null && typeof component !== \"function\") throw new Error(\"m.mount(element, component) expects a component, not a vnode\")\n\t\t\n\t\tvar run0 = function() {\n\t\t\tredrawService0.render(root, Vnode(component))\n\t\t}\n\t\tredrawService0.subscribe(root, run0)\n\t\tredrawService0.redraw()\n\t}\n}\nm.mount = _16(redrawService)\nvar Promise = PromisePolyfill\nvar parseQueryString = function(string) {\n\tif (string === \"\" || string == null) return {}\n\tif (string.charAt(0) === \"?\") string = string.slice(1)\n\tvar entries = string.split(\"&\"), data0 = {}, counters = {}\n\tfor (var i = 0; i < entries.length; i++) {\n\t\tvar entry = entries[i].split(\"=\")\n\t\tvar key5 = decodeURIComponent(entry[0])\n\t\tvar value = entry.length === 2 ? decodeURIComponent(entry[1]) : \"\"\n\t\tif (value === \"true\") value = true\n\t\telse if (value === \"false\") value = false\n\t\tvar levels = key5.split(/\\]\\[?|\\[/)\n\t\tvar cursor = data0\n\t\tif (key5.indexOf(\"[\") > -1) levels.pop()\n\t\tfor (var j = 0; j < levels.length; j++) {\n\t\t\tvar level = levels[j], nextLevel = levels[j + 1]\n\t\t\tvar isNumber = nextLevel == \"\" || !isNaN(parseInt(nextLevel, 10))\n\t\t\tvar isValue = j === levels.length - 1\n\t\t\tif (level === \"\") {\n\t\t\t\tvar key5 = levels.slice(0, j).join()\n\t\t\t\tif (counters[key5] == null) counters[key5] = 0\n\t\t\t\tlevel = counters[key5]++\n\t\t\t}\n\t\t\tif (cursor[level] == null) {\n\t\t\t\tcursor[level] = isValue ? value : isNumber ? [] : {}\n\t\t\t}\n\t\t\tcursor = cursor[level]\n\t\t}\n\t}\n\treturn data0\n}\nvar coreRouter = function($window) {\n\tvar supportsPushState = typeof $window.history.pushState === \"function\"\n\tvar callAsync0 = typeof setImmediate === \"function\" ? setImmediate : setTimeout\n\tfunction normalize1(fragment0) {\n\t\tvar data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)\n\t\tif (fragment0 === \"pathname\" && data[0] !== \"/\") data = \"/\" + data\n\t\treturn data\n\t}\n\tvar asyncId\n\tfunction debounceAsync(callback0) {\n\t\treturn function() {\n\t\t\tif (asyncId != null) return\n\t\t\tasyncId = callAsync0(function() {\n\t\t\t\tasyncId = null\n\t\t\t\tcallback0()\n\t\t\t})\n\t\t}\n\t}\n\tfunction parsePath(path, queryData, hashData) {\n\t\tvar queryIndex = path.indexOf(\"?\")\n\t\tvar hashIndex = path.indexOf(\"#\")\n\t\tvar pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length\n\t\tif (queryIndex > -1) {\n\t\t\tvar queryEnd = hashIndex > -1 ? hashIndex : path.length\n\t\t\tvar queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))\n\t\t\tfor (var key4 in queryParams) queryData[key4] = queryParams[key4]\n\t\t}\n\t\tif (hashIndex > -1) {\n\t\t\tvar hashParams = parseQueryString(path.slice(hashIndex + 1))\n\t\t\tfor (var key4 in hashParams) hashData[key4] = hashParams[key4]\n\t\t}\n\t\treturn path.slice(0, pathEnd)\n\t}\n\tvar router = {prefix: \"#!\"}\n\trouter.getPath = function() {\n\t\tvar type2 = router.prefix.charAt(0)\n\t\tswitch (type2) {\n\t\t\tcase \"#\": return normalize1(\"hash\").slice(router.prefix.length)\n\t\t\tcase \"?\": return normalize1(\"search\").slice(router.prefix.length) + normalize1(\"hash\")\n\t\t\tdefault: return normalize1(\"pathname\").slice(router.prefix.length) + normalize1(\"search\") + normalize1(\"hash\")\n\t\t}\n\t}\n\trouter.setPath = function(path, data, options) {\n\t\tvar queryData = {}, hashData = {}\n\t\tpath = parsePath(path, queryData, hashData)\n\t\tif (data != null) {\n\t\t\tfor (var key4 in data) queryData[key4] = data[key4]\n\t\t\tpath = path.replace(/:([^\\/]+)/g, function(match2, token) {\n\t\t\t\tdelete queryData[token]\n\t\t\t\treturn data[token]\n\t\t\t})\n\t\t}\n\t\tvar query = buildQueryString(queryData)\n\t\tif (query) path += \"?\" + query\n\t\tvar hash = buildQueryString(hashData)\n\t\tif (hash) path += \"#\" + hash\n\t\tif (supportsPushState) {\n\t\t\tvar state = options ? options.state : null\n\t\t\tvar title = options ? options.title : null\n\t\t\t$window.onpopstate()\n\t\t\tif (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)\n\t\t\telse $window.history.pushState(state, title, router.prefix + path)\n\t\t}\n\t\telse $window.location.href = router.prefix + path\n\t}\n\trouter.defineRoutes = function(routes, resolve, reject) {\n\t\tfunction resolveRoute() {\n\t\t\tvar path = router.getPath()\n\t\t\tvar params = {}\n\t\t\tvar pathname = parsePath(path, params, params)\n\t\t\tvar state = $window.history.state\n\t\t\tif (state != null) {\n\t\t\t\tfor (var k in state) params[k] = state[k]\n\t\t\t}\n\t\t\tfor (var route0 in routes) {\n\t\t\t\tvar matcher = new RegExp(\"^\" + route0.replace(/:[^\\/]+?\\.{3}/g, \"(.*?)\").replace(/:[^\\/]+/g, \"([^\\\\/]+)\") + \"\\/?$\")\n\t\t\t\tif (matcher.test(pathname)) {\n\t\t\t\t\tpathname.replace(matcher, function() {\n\t\t\t\t\t\tvar keys = route0.match(/:[^\\/]+/g) || []\n\t\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2)\n\t\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\tparams[keys[i].replace(/:|\\./g, \"\")] = decodeURIComponent(values[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(routes[route0], params, path, route0)\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\treject(path, params)\n\t\t}\n\t\tif (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)\n\t\telse if (router.prefix.charAt(0) === \"#\") $window.onhashchange = resolveRoute\n\t\tresolveRoute()\n\t}\n\treturn router\n}\nvar _20 = function($window, redrawService0) {\n\tvar routeService = coreRouter($window)\n\tvar identity = function(v) {return v}\n\tvar render1, component, attrs3, currentPath, lastUpdate\n\tvar route = function(root, defaultRoute, routes) {\n\t\tif (root == null) throw new Error(\"Ensure the DOM element that was passed to `m.route` is not undefined\")\n\t\tvar run1 = function() {\n\t\t\tif (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))\n\t\t}\n\t\tvar bail = function(path) {\n\t\t\tif (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})\n\t\t\telse throw new Error(\"Could not resolve default route \" + defaultRoute)\n\t\t}\n\t\trouteService.defineRoutes(routes, function(payload, params, path) {\n\t\t\tvar update = lastUpdate = function(routeResolver, comp) {\n\t\t\t\tif (update !== lastUpdate) return\n\t\t\t\tcomponent = comp != null && (typeof comp.view === \"function\" || typeof comp === \"function\")? comp : \"div\"\n\t\t\t\tattrs3 = params, currentPath = path, lastUpdate = null\n\t\t\t\trender1 = (routeResolver.render || identity).bind(routeResolver)\n\t\t\t\trun1()\n\t\t\t}\n\t\t\tif (payload.view || typeof payload === \"function\") update({}, payload)\n\t\t\telse {\n\t\t\t\tif (payload.onmatch) {\n\t\t\t\t\tPromise.resolve(payload.onmatch(params, path)).then(function(resolved) {\n\t\t\t\t\t\tupdate(payload, resolved)\n\t\t\t\t\t}, bail)\n\t\t\t\t}\n\t\t\t\telse update(payload, \"div\")\n\t\t\t}\n\t\t}, bail)\n\t\tredrawService0.subscribe(root, run1)\n\t}\n\troute.set = function(path, data, options) {\n\t\tif (lastUpdate != null) options = {replace: true}\n\t\tlastUpdate = null\n\t\trouteService.setPath(path, data, options)\n\t}\n\troute.get = function() {return currentPath}\n\troute.prefix = function(prefix0) {routeService.prefix = prefix0}\n\troute.link = function(vnode1) {\n\t\tvnode1.dom.setAttribute(\"href\", routeService.prefix + vnode1.attrs.href)\n\t\tvnode1.dom.onclick = function(e) {\n\t\t\tif (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return\n\t\t\te.preventDefault()\n\t\t\te.redraw = false\n\t\t\tvar href = this.getAttribute(\"href\")\n\t\t\tif (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)\n\t\t\troute.set(href, undefined, undefined)\n\t\t}\n\t}\n\troute.param = function(key3) {\n\t\tif(typeof attrs3 !== \"undefined\" && typeof key3 !== \"undefined\") return attrs3[key3]\n\t\treturn attrs3\n\t}\n\treturn route\n}\nm.route = _20(window, redrawService)\nm.withAttr = function(attrName, callback1, context) {\n\treturn function(e) {\n\t\tcallback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))\n\t}\n}\nvar _28 = coreRenderer(window)\nm.render = _28.render\nm.redraw = redrawService.redraw\nm.request = requestService.request\nm.jsonp = requestService.jsonp\nm.parseQueryString = parseQueryString\nm.buildQueryString = buildQueryString\nm.version = \"1.1.1\"\nm.vnode = Vnode\nif (true) module[\"exports\"] = m\nelse window.m = m\n}());\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../timers-browserify/main.js */ 10).setImmediate, __webpack_require__(/*! ./../webpack/buildin/global.js */ 0)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbWl0aHJpbC9taXRocmlsLmpzP2JkNDIiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG9uZXZlbnRcblx0ZnVuY3Rpb24gc2V0RXZlbnRDYWxsYmFjayhjYWxsYmFjaykge3JldHVybiBvbmV2ZW50ID0gY2FsbGJhY2t9XG5cdC8vY3JlYXRlXG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRzd2l0Y2ggKHRhZykge1xuXHRcdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIjxcIjogcmV0dXJuIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCJbXCI6IHJldHVybiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHJldHVybiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dm5vZGUuZG9tID0gJGRvYy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS5jaGlsZHJlbilcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgdm5vZGUuZG9tLCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZhciBtYXRjaDEgPSB2bm9kZS5jaGlsZHJlbi5tYXRjaCgvXlxccyo/PChcXHcrKS9pbSkgfHwgW11cblx0XHR2YXIgcGFyZW50MSA9IHtjYXB0aW9uOiBcInRhYmxlXCIsIHRoZWFkOiBcInRhYmxlXCIsIHRib2R5OiBcInRhYmxlXCIsIHRmb290OiBcInRhYmxlXCIsIHRyOiBcInRib2R5XCIsIHRoOiBcInRyXCIsIHRkOiBcInRyXCIsIGNvbGdyb3VwOiBcInRhYmxlXCIsIGNvbDogXCJjb2xncm91cFwifVttYXRjaDFbMV1dIHx8IFwiZGl2XCJcblx0XHR2YXIgdGVtcCA9ICRkb2MuY3JlYXRlRWxlbWVudChwYXJlbnQxKVxuXHRcdHRlbXAuaW5uZXJIVE1MID0gdm5vZGUuY2hpbGRyZW5cblx0XHR2bm9kZS5kb20gPSB0ZW1wLmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gdGVtcC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0dmFyIGNoaWxkXG5cdFx0d2hpbGUgKGNoaWxkID0gdGVtcC5maXJzdENoaWxkKSB7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZClcblx0XHR9XG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGNyZWF0ZU5vZGVzKGZyYWdtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IGZyYWdtZW50LmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdHZhciBpcyA9IGF0dHJzMiAmJiBhdHRyczIuaXNcblx0XHR2YXIgZWxlbWVudCA9IG5zID9cblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZykgOlxuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnKVxuXHRcdHZub2RlLmRvbSA9IGVsZW1lbnRcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdHNldEF0dHJzKHZub2RlLCBhdHRyczIsIG5zKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS50ZXh0ICE9PSBcIlwiKSBlbGVtZW50LnRleHRDb250ZW50ID0gdm5vZGUudGV4dFxuXHRcdFx0XHRlbHNlIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0fVxuXHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdFx0Y3JlYXRlTm9kZXMoZWxlbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdFx0XHRzZXRMYXRlQXR0cnModm5vZGUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpIHtcblx0XHR2YXIgc2VudGluZWxcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZy52aWV3ID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gT2JqZWN0LmNyZWF0ZSh2bm9kZS50YWcpXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnN0YXRlLnZpZXdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHZvaWQgMFxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS50YWdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdFx0dm5vZGUuc3RhdGUgPSAodm5vZGUudGFnLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS50YWcucHJvdG90eXBlLnZpZXcgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgdm5vZGUudGFnKHZub2RlKSA6IHZub2RlLnRhZyh2bm9kZSlcblx0XHR9XG5cdFx0dm5vZGUuX3N0YXRlID0gdm5vZGUuc3RhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdGluaXRMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSBudWxsXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5kb20gIT0gbnVsbCA/IHZub2RlLmluc3RhbmNlLmRvbVNpemUgOiAwXG5cdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRyZXR1cm4gZWxlbWVudFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0XHRyZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHR9XG5cdH1cblx0Ly91cGRhdGVcblx0ZnVuY3Rpb24gdXBkYXRlTm9kZXMocGFyZW50LCBvbGQsIHZub2RlcywgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0aWYgKG9sZCA9PT0gdm5vZGVzIHx8IG9sZCA9PSBudWxsICYmIHZub2RlcyA9PSBudWxsKSByZXR1cm5cblx0XHRlbHNlIGlmIChvbGQgPT0gbnVsbCkgY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIDAsIHZub2Rlcy5sZW5ndGgsIGhvb2tzLCBuZXh0U2libGluZywgdW5kZWZpbmVkKVxuXHRcdGVsc2UgaWYgKHZub2RlcyA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIDAsIG9sZC5sZW5ndGgsIHZub2Rlcylcblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQubGVuZ3RoID09PSB2bm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpc1Vua2V5ZWQgPSBmYWxzZVxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiBvbGRbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aXNVbmtleWVkID0gdm5vZGVzW2ldLmtleSA9PSBudWxsICYmIG9sZFtpXS5rZXkgPT0gbnVsbFxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzVW5rZXllZCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkW2ldID09PSB2bm9kZXNbaV0pIGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChvbGRbaV0gPT0gbnVsbCAmJiB2bm9kZXNbaV0gIT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2Rlc1tpXSwgaG9va3MsIG5zLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRlbHNlIGlmICh2bm9kZXNbaV0gPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCBpLCBpICsgMSwgdm5vZGVzKVxuXHRcdFx0XHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkW2ldLCB2bm9kZXNbaV0sIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWN5Y2xpbmcgPSByZWN5Y2xpbmcgfHwgaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKVxuXHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHR2YXIgcG9vbCA9IG9sZC5wb29sXG5cdFx0XHRcdG9sZCA9IG9sZC5jb25jYXQob2xkLnBvb2wpXG5cdFx0XHR9XG5cdFx0XHR2YXIgb2xkU3RhcnQgPSAwLCBzdGFydCA9IDAsIG9sZEVuZCA9IG9sZC5sZW5ndGggLSAxLCBlbmQgPSB2bm9kZXMubGVuZ3RoIC0gMSwgbWFwXG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRTdGFydF0sIHYgPSB2bm9kZXNbc3RhcnRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRTdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkU3RhcnQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdXG5cdFx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdFx0aWYgKHJlY3ljbGluZyB8fCBzdGFydCA8IGVuZCkgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgYnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXSwgdiA9IHZub2Rlc1tlbmRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRpZiAoby5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBvLmRvbVxuXHRcdFx0XHRcdG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICghbWFwKSBtYXAgPSBnZXRLZXlNYXAob2xkLCBvbGRFbmQpXG5cdFx0XHRcdFx0aWYgKHYgIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dmFyIG9sZEluZGV4ID0gbWFwW3Yua2V5XVxuXHRcdFx0XHRcdFx0aWYgKG9sZEluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG1vdmFibGUgPSBvbGRbb2xkSW5kZXhdXG5cdFx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRJbmRleCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBtb3ZhYmxlLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0XHRcdGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG1vdmFibGUpLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0b2xkW29sZEluZGV4XS5za2lwID0gdHJ1ZVxuXHRcdFx0XHRcdFx0XHRpZiAobW92YWJsZS5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBtb3ZhYmxlLmRvbVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkb20gPSBjcmVhdGVOb2RlKHBhcmVudCwgdiwgaG9va3MsIHVuZGVmaW5lZCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdGlmICh2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikge1xuXHRcdFx0aWYgKHZub2RlLmF0dHJzID09IG51bGwpIHZub2RlLmF0dHJzID0ge31cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuYXR0cnMudmFsdWUgPSB2bm9kZS50ZXh0IC8vRklYTUUgaGFuZGxlMCBtdWx0aXBsZSBjaGlsZHJlblxuXHRcdFx0XHR2bm9kZS50ZXh0ID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQuYXR0cnMsIHZub2RlLmF0dHJzLCBucylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9PSBcIlwiKSB7XG5cdFx0XHRpZiAob2xkLnRleHQudG9TdHJpbmcoKSAhPT0gdm5vZGUudGV4dC50b1N0cmluZygpKSBvbGQuZG9tLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdm5vZGUudGV4dFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQudGV4dCAhPSBudWxsKSBvbGQuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGQudGV4dCwgdW5kZWZpbmVkLCBvbGQuZG9tLmZpcnN0Q2hpbGQpXVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkgdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR1cGRhdGVOb2RlcyhlbGVtZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHR1cGRhdGVMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0fVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAob2xkLmluc3RhbmNlID09IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZC5pbnN0YW5jZSwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmluc3RhbmNlLmRvbVNpemVcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLmluc3RhbmNlLCBudWxsKVxuXHRcdFx0dm5vZGUuZG9tID0gdW5kZWZpbmVkXG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpIHtcblx0XHRpZiAob2xkLnBvb2wgIT0gbnVsbCAmJiBNYXRoLmFicyhvbGQucG9vbC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSA8PSBNYXRoLmFicyhvbGQubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBvbGRDaGlsZHJlbkxlbmd0aCA9IG9sZFswXSAmJiBvbGRbMF0uY2hpbGRyZW4gJiYgb2xkWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgcG9vbENoaWxkcmVuTGVuZ3RoID0gb2xkLnBvb2xbMF0gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciB2bm9kZXNDaGlsZHJlbkxlbmd0aCA9IHZub2Rlc1swXSAmJiB2bm9kZXNbMF0uY2hpbGRyZW4gJiYgdm5vZGVzWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHRpZiAoTWF0aC5hYnMocG9vbENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpIDw9IE1hdGguYWJzKG9sZENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIGdldEtleU1hcCh2bm9kZXMsIGVuZCkge1xuXHRcdHZhciBtYXAgPSB7fSwgaSA9IDBcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBrZXkyID0gdm5vZGUua2V5XG5cdFx0XHRcdGlmIChrZXkyICE9IG51bGwpIG1hcFtrZXkyXSA9IGlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG5cdGZ1bmN0aW9uIHRvRnJhZ21lbnQodm5vZGUpIHtcblx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZVxuXHRcdGlmIChjb3VudDAgIT0gbnVsbCB8fCB2bm9kZS5kb20gPT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRcdGlmIChjb3VudDAgPiAwKSB7XG5cdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdGZyYWdtZW50Lmluc2VydEJlZm9yZShkb20sIGZyYWdtZW50LmZpcnN0Q2hpbGQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnJhZ21lbnRcblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcodm5vZGVzLCBpLCBuZXh0U2libGluZykge1xuXHRcdGZvciAoOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgdm5vZGVzW2ldLmRvbSAhPSBudWxsKSByZXR1cm4gdm5vZGVzW2ldLmRvbVxuXHRcdH1cblx0XHRyZXR1cm4gbmV4dFNpYmxpbmdcblx0fVxuXHRmdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudCwgZG9tLCBuZXh0U2libGluZykge1xuXHRcdGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnROb2RlKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9tKVxuXHR9XG5cdGZ1bmN0aW9uIHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCI8XCIpIHtcblx0XHRcdHZhciBjb250ZW50ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0XHRcdGlmICh2bm9kZS5kb20uaW5uZXJIVE1MICE9PSBjb250ZW50KSB2bm9kZS5kb20uaW5uZXJIVE1MID0gY29udGVudFxuXHRcdH1cblx0XHRlbHNlIGlmICh2bm9kZS50ZXh0ICE9IG51bGwgfHwgY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG5vZGUgb2YgYSBjb250ZW50ZWRpdGFibGUgbXVzdCBiZSB0cnVzdGVkXCIpXG5cdH1cblx0Ly9yZW1vdmVcblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZXModm5vZGVzLCBzdGFydCwgZW5kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnNraXApIHZub2RlLnNraXAgPSBmYWxzZVxuXHRcdFx0XHRlbHNlIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpIHtcblx0XHR2YXIgZXhwZWN0ZWQgPSAxLCBjYWxsZWQgPSAwXG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnRpbnVhdGlvbigpXG5cdFx0ZnVuY3Rpb24gY29udGludWF0aW9uKCkge1xuXHRcdFx0aWYgKCsrY2FsbGVkID09PSBleHBlY3RlZCkge1xuXHRcdFx0XHRvbnJlbW92ZSh2bm9kZSlcblx0XHRcdFx0aWYgKHZub2RlLmRvbSkge1xuXHRcdFx0XHRcdHZhciBjb3VudDAgPSB2bm9kZS5kb21TaXplIHx8IDFcblx0XHRcdFx0XHRpZiAoY291bnQwID4gMSkge1xuXHRcdFx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00odm5vZGUuZG9tKVxuXHRcdFx0XHRcdGlmIChjb250ZXh0ICE9IG51bGwgJiYgdm5vZGUuZG9tU2l6ZSA9PSBudWxsICYmICFoYXNJbnRlZ3JhdGlvbk1ldGhvZHModm5vZGUuYXR0cnMpICYmIHR5cGVvZiB2bm9kZS50YWcgPT09IFwic3RyaW5nXCIpIHsgLy9UT0RPIHRlc3QgY3VzdG9tIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnRleHQucG9vbCkgY29udGV4dC5wb29sID0gW3Zub2RlXVxuXHRcdFx0XHRcdFx0ZWxzZSBjb250ZXh0LnBvb2wucHVzaCh2bm9kZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZUZyb21ET00obm9kZSkge1xuXHRcdHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGVcblx0XHRpZiAocGFyZW50ICE9IG51bGwpIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKVxuXHR9XG5cdGZ1bmN0aW9uIG9ucmVtb3ZlKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5hdHRycy5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLl9zdGF0ZS5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkgb25yZW1vdmUodm5vZGUuaW5zdGFuY2UpXG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsKSBvbnJlbW92ZShjaGlsZClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2F0dHJzMlxuXHRmdW5jdGlvbiBzZXRBdHRycyh2bm9kZSwgYXR0cnMyLCBucykge1xuXHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRzZXRBdHRyKHZub2RlLCBrZXkyLCBudWxsLCBhdHRyczJba2V5Ml0sIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRBdHRyKHZub2RlLCBrZXkyLCBvbGQsIHZhbHVlLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0aWYgKGtleTIgPT09IFwia2V5XCIgfHwga2V5MiA9PT0gXCJpc1wiIHx8IChvbGQgPT09IHZhbHVlICYmICFpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGtleTIpKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IGlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSByZXR1cm5cblx0XHR2YXIgbnNMYXN0SW5kZXggPSBrZXkyLmluZGV4T2YoXCI6XCIpXG5cdFx0aWYgKG5zTGFzdEluZGV4ID4gLTEgJiYga2V5Mi5zdWJzdHIoMCwgbnNMYXN0SW5kZXgpID09PSBcInhsaW5rXCIpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIGtleTIuc2xpY2UobnNMYXN0SW5kZXggKyAxKSwgdmFsdWUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGtleTJbMF0gPT09IFwib1wiICYmIGtleTJbMV0gPT09IFwiblwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5MiA9PT0gXCJzdHlsZVwiKSB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgaW4gZWxlbWVudCAmJiAhaXNBdHRyaWJ1dGUoa2V5MikgJiYgbnMgPT09IHVuZGVmaW5lZCAmJiAhaXNDdXN0b21FbGVtZW50KHZub2RlKSkge1xuXHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiAmJiBrZXkyID09PSBcInZhbHVlXCIgJiYgdm5vZGUuZG9tLnZhbHVlID09IHZhbHVlICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcInNlbGVjdFwiICYmIGtleTIgPT09IFwidmFsdWVcIiAmJiB2bm9kZS5kb20udmFsdWUgPT0gdmFsdWUgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0Ly9zZXR0aW5nIG9wdGlvblt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwib3B0aW9uXCIgJiYga2V5MiA9PT0gXCJ2YWx1ZVwiICYmIHZub2RlLmRvbS52YWx1ZSA9PSB2YWx1ZSkgcmV0dXJuXG5cdFx0XHQvLyBJZiB5b3UgYXNzaWduIGFuIGlucHV0IHR5cGUxIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRSAxMSB3aXRoIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiwgYW4gZXJyb3IwIHdpbGwgb2NjdXIuXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcImlucHV0XCIgJiYga2V5MiA9PT0gXCJ0eXBlXCIpIHtcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgdmFsdWUpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudFtrZXkyXSA9IHZhbHVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coZWxlbWVudCwga2V5Mik7XG5cdFx0XHRcdGlmICh2YWx1ZSkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgXCJcIilcblx0XHRcdFx0ZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyID09PSBcImNsYXNzTmFtZVwiID8gXCJjbGFzc1wiIDoga2V5MiwgdmFsdWUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldExhdGVBdHRycyh2bm9kZSkge1xuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYgYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGlmIChcInZhbHVlXCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInZhbHVlXCIsIG51bGwsIGF0dHJzMi52YWx1ZSwgdW5kZWZpbmVkKVxuXHRcdFx0aWYgKFwic2VsZWN0ZWRJbmRleFwiIGluIGF0dHJzMikgc2V0QXR0cih2bm9kZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwsIGF0dHJzMi5zZWxlY3RlZEluZGV4LCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQsIGF0dHJzMiwgbnMpIHtcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRcdHNldEF0dHIodm5vZGUsIGtleTIsIG9sZCAmJiBvbGRba2V5Ml0sIGF0dHJzMltrZXkyXSwgbnMpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChvbGQgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0aWYgKGF0dHJzMiA9PSBudWxsIHx8ICEoa2V5MiBpbiBhdHRyczIpKSB7XG5cdFx0XHRcdFx0aWYgKGtleTIgPT09IFwiY2xhc3NOYW1lXCIpIGtleTIgPSBcImNsYXNzXCJcblx0XHRcdFx0XHRpZiAoa2V5MlswXSA9PT0gXCJvXCIgJiYga2V5MlsxXSA9PT0gXCJuXCIgJiYgIWlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGVsc2UgaWYgKGtleTIgIT09IFwia2V5XCIpIHZub2RlLmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5Milcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJ2YWx1ZVwiIHx8IGF0dHIgPT09IFwiY2hlY2tlZFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRJbmRleFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRcIiAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGlzTGlmZWN5Y2xlTWV0aG9kKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJvbmluaXRcIiB8fCBhdHRyID09PSBcIm9uY3JlYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnVwZGF0ZVwiIHx8IGF0dHIgPT09IFwib25yZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JlcmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXVwZGF0ZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNBdHRyaWJ1dGUoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcImhyZWZcIiB8fCBhdHRyID09PSBcImxpc3RcIiB8fCBhdHRyID09PSBcImZvcm1cIiB8fCBhdHRyID09PSBcIndpZHRoXCIgfHwgYXR0ciA9PT0gXCJoZWlnaHRcIi8vIHx8IGF0dHIgPT09IFwidHlwZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNDdXN0b21FbGVtZW50KHZub2RlKXtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMuaXMgfHwgdm5vZGUudGFnLmluZGV4T2YoXCItXCIpID4gLTFcblx0fVxuXHRmdW5jdGlvbiBoYXNJbnRlZ3JhdGlvbk1ldGhvZHMoc291cmNlKSB7XG5cdFx0cmV0dXJuIHNvdXJjZSAhPSBudWxsICYmIChzb3VyY2Uub25jcmVhdGUgfHwgc291cmNlLm9udXBkYXRlIHx8IHNvdXJjZS5vbmJlZm9yZXJlbW92ZSB8fCBzb3VyY2Uub25yZW1vdmUpXG5cdH1cblx0Ly9zdHlsZVxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHN0eWxlKSB7XG5cdFx0aWYgKG9sZCA9PT0gc3R5bGUpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCIsIG9sZCA9IG51bGxcblx0XHRpZiAoc3R5bGUgPT0gbnVsbCkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVcblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIHN0eWxlKSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5Ml0gPSBzdHlsZVtrZXkyXVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9sZCAhPSBudWxsICYmIHR5cGVvZiBvbGQgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0XHRpZiAoIShrZXkyIGluIHN0eWxlKSkgZWxlbWVudC5zdHlsZVtrZXkyXSA9IFwiXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2V2ZW50XG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB2YWx1ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0dmFyIGNhbGxiYWNrID0gdHlwZW9mIG9uZXZlbnQgIT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlIDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZhbHVlLmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdG9uZXZlbnQuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdH1cblx0XHRpZiAoa2V5MiBpbiBlbGVtZW50KSBlbGVtZW50W2tleTJdID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYWxsYmFjayA6IG51bGxcblx0XHRlbHNlIHtcblx0XHRcdHZhciBldmVudE5hbWUgPSBrZXkyLnNsaWNlKDIpXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzID09PSB1bmRlZmluZWQpIHZub2RlLmV2ZW50cyA9IHt9XG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdID09PSBjYWxsYmFjaykgcmV0dXJuXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdICE9IG51bGwpIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXkyXSwgZmFsc2UpXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dm5vZGUuZXZlbnRzW2tleTJdID0gY2FsbGJhY2tcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9saWZlY3ljbGVcblx0ZnVuY3Rpb24gaW5pdExpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uaW5pdCA9PT0gXCJmdW5jdGlvblwiKSBzb3VyY2Uub25pbml0LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9uY3JlYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbnVwZGF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpIHtcblx0XHR2YXIgZm9yY2VWbm9kZVVwZGF0ZSwgZm9yY2VDb21wb25lbnRVcGRhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VWbm9kZVVwZGF0ZSA9IHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICghKGZvcmNlVm5vZGVVcGRhdGUgPT09IHVuZGVmaW5lZCAmJiBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSAmJiAhZm9yY2VWbm9kZVVwZGF0ZSAmJiAhZm9yY2VDb21wb25lbnRVcGRhdGUpIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBvbGQuaW5zdGFuY2Vcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIHJlbmRlcihkb20sIHZub2Rlcykge1xuXHRcdGlmICghZG9tKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIilcblx0XHR2YXIgaG9va3MgPSBbXVxuXHRcdHZhciBhY3RpdmUgPSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0XHQvLyBGaXJzdCB0aW1lMCByZW5kZXJpbmcgaW50byBhIG5vZGUgY2xlYXJzIGl0IG91dFxuXHRcdGlmIChkb20udm5vZGVzID09IG51bGwpIGRvbS50ZXh0Q29udGVudCA9IFwiXCJcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkodm5vZGVzKSkgdm5vZGVzID0gW3Zub2Rlc11cblx0XHR1cGRhdGVOb2Rlcyhkb20sIGRvbS52bm9kZXMsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlcyksIGZhbHNlLCBob29rcywgbnVsbCwgdW5kZWZpbmVkKVxuXHRcdGRvbS52bm9kZXMgPSB2bm9kZXNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSBob29rc1tpXSgpXG5cdFx0aWYgKCRkb2MuYWN0aXZlRWxlbWVudCAhPT0gYWN0aXZlKSBhY3RpdmUuZm9jdXMoKVxuXHR9XG5cdHJldHVybiB7cmVuZGVyOiByZW5kZXIsIHNldEV2ZW50Q2FsbGJhY2s6IHNldEV2ZW50Q2FsbGJhY2t9XG59XG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaykge1xuXHQvLzYwZnBzIHRyYW5zbGF0ZXMgdG8gMTYuNm1zLCByb3VuZCBpdCBkb3duIHNpbmNlIHNldFRpbWVvdXQgcmVxdWlyZXMgaW50XG5cdHZhciB0aW1lID0gMTZcblx0dmFyIGxhc3QgPSAwLCBwZW5kaW5nID0gbnVsbFxuXHR2YXIgdGltZW91dCA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwiZnVuY3Rpb25cIiA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHNldFRpbWVvdXRcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpXG5cdFx0aWYgKGxhc3QgPT09IDAgfHwgbm93IC0gbGFzdCA+PSB0aW1lKSB7XG5cdFx0XHRsYXN0ID0gbm93XG5cdFx0XHRjYWxsYmFjaygpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcblx0XHRcdHBlbmRpbmcgPSB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwZW5kaW5nID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjaygpXG5cdFx0XHRcdGxhc3QgPSBEYXRlLm5vdygpXG5cdFx0XHR9LCB0aW1lIC0gKG5vdyAtIGxhc3QpKVxuXHRcdH1cblx0fVxufVxudmFyIF8xMSA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHJlbmRlclNlcnZpY2UgPSBjb3JlUmVuZGVyZXIoJHdpbmRvdylcblx0cmVuZGVyU2VydmljZS5zZXRFdmVudENhbGxiYWNrKGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZS5yZWRyYXcgIT09IGZhbHNlKSByZWRyYXcoKVxuXHR9KVxuXHR2YXIgY2FsbGJhY2tzID0gW11cblx0ZnVuY3Rpb24gc3Vic2NyaWJlKGtleTEsIGNhbGxiYWNrKSB7XG5cdFx0dW5zdWJzY3JpYmUoa2V5MSlcblx0XHRjYWxsYmFja3MucHVzaChrZXkxLCB0aHJvdHRsZShjYWxsYmFjaykpXG5cdH1cblx0ZnVuY3Rpb24gdW5zdWJzY3JpYmUoa2V5MSkge1xuXHRcdHZhciBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGtleTEpXG5cdFx0aWYgKGluZGV4ID4gLTEpIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDIpXG5cdH1cblx0ZnVuY3Rpb24gcmVkcmF3KCkge1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0XHRjYWxsYmFja3NbaV0oKVxuXHRcdH1cblx0fVxuXHRyZXR1cm4ge3N1YnNjcmliZTogc3Vic2NyaWJlLCB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUsIHJlZHJhdzogcmVkcmF3LCByZW5kZXI6IHJlbmRlclNlcnZpY2UucmVuZGVyfVxufVxudmFyIHJlZHJhd1NlcnZpY2UgPSBfMTEod2luZG93KVxucmVxdWVzdFNlcnZpY2Uuc2V0Q29tcGxldGlvbkNhbGxiYWNrKHJlZHJhd1NlcnZpY2UucmVkcmF3KVxudmFyIF8xNiA9IGZ1bmN0aW9uKHJlZHJhd1NlcnZpY2UwKSB7XG5cdHJldHVybiBmdW5jdGlvbihyb290LCBjb21wb25lbnQpIHtcblx0XHRpZiAoY29tcG9uZW50ID09PSBudWxsKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgW10pXG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC51bnN1YnNjcmliZShyb290KVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdFxuXHRcdGlmIChjb21wb25lbnQudmlldyA9PSBudWxsICYmIHR5cGVvZiBjb21wb25lbnQgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwibS5tb3VudChlbGVtZW50LCBjb21wb25lbnQpIGV4cGVjdHMgYSBjb21wb25lbnQsIG5vdCBhIHZub2RlXCIpXG5cdFx0XG5cdFx0dmFyIHJ1bjAgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCBWbm9kZShjb21wb25lbnQpKVxuXHRcdH1cblx0XHRyZWRyYXdTZXJ2aWNlMC5zdWJzY3JpYmUocm9vdCwgcnVuMClcblx0XHRyZWRyYXdTZXJ2aWNlMC5yZWRyYXcoKVxuXHR9XG59XG5tLm1vdW50ID0gXzE2KHJlZHJhd1NlcnZpY2UpXG52YXIgUHJvbWlzZSA9IFByb21pc2VQb2x5ZmlsbFxudmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0aWYgKHN0cmluZyA9PT0gXCJcIiB8fCBzdHJpbmcgPT0gbnVsbCkgcmV0dXJuIHt9XG5cdGlmIChzdHJpbmcuY2hhckF0KDApID09PSBcIj9cIikgc3RyaW5nID0gc3RyaW5nLnNsaWNlKDEpXG5cdHZhciBlbnRyaWVzID0gc3RyaW5nLnNwbGl0KFwiJlwiKSwgZGF0YTAgPSB7fSwgY291bnRlcnMgPSB7fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZW50cnkgPSBlbnRyaWVzW2ldLnNwbGl0KFwiPVwiKVxuXHRcdHZhciBrZXk1ID0gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5WzBdKVxuXHRcdHZhciB2YWx1ZSA9IGVudHJ5Lmxlbmd0aCA9PT0gMiA/IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVsxXSkgOiBcIlwiXG5cdFx0aWYgKHZhbHVlID09PSBcInRydWVcIikgdmFsdWUgPSB0cnVlXG5cdFx0ZWxzZSBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikgdmFsdWUgPSBmYWxzZVxuXHRcdHZhciBsZXZlbHMgPSBrZXk1LnNwbGl0KC9cXF1cXFs/fFxcWy8pXG5cdFx0dmFyIGN1cnNvciA9IGRhdGEwXG5cdFx0aWYgKGtleTUuaW5kZXhPZihcIltcIikgPiAtMSkgbGV2ZWxzLnBvcCgpXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdHZhciBsZXZlbCA9IGxldmVsc1tqXSwgbmV4dExldmVsID0gbGV2ZWxzW2ogKyAxXVxuXHRcdFx0dmFyIGlzTnVtYmVyID0gbmV4dExldmVsID09IFwiXCIgfHwgIWlzTmFOKHBhcnNlSW50KG5leHRMZXZlbCwgMTApKVxuXHRcdFx0dmFyIGlzVmFsdWUgPSBqID09PSBsZXZlbHMubGVuZ3RoIC0gMVxuXHRcdFx0aWYgKGxldmVsID09PSBcIlwiKSB7XG5cdFx0XHRcdHZhciBrZXk1ID0gbGV2ZWxzLnNsaWNlKDAsIGopLmpvaW4oKVxuXHRcdFx0XHRpZiAoY291bnRlcnNba2V5NV0gPT0gbnVsbCkgY291bnRlcnNba2V5NV0gPSAwXG5cdFx0XHRcdGxldmVsID0gY291bnRlcnNba2V5NV0rK1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnNvcltsZXZlbF0gPT0gbnVsbCkge1xuXHRcdFx0XHRjdXJzb3JbbGV2ZWxdID0gaXNWYWx1ZSA/IHZhbHVlIDogaXNOdW1iZXIgPyBbXSA6IHt9XG5cdFx0XHR9XG5cdFx0XHRjdXJzb3IgPSBjdXJzb3JbbGV2ZWxdXG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhMFxufVxudmFyIGNvcmVSb3V0ZXIgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9IHR5cGVvZiAkd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID09PSBcImZ1bmN0aW9uXCJcblx0dmFyIGNhbGxBc3luYzAgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZTEoZnJhZ21lbnQwKSB7XG5cdFx0dmFyIGRhdGEgPSAkd2luZG93LmxvY2F0aW9uW2ZyYWdtZW50MF0ucmVwbGFjZSgvKD86JVthLWY4OV1bYS1mMC05XSkrL2dpbSwgZGVjb2RlVVJJQ29tcG9uZW50KVxuXHRcdGlmIChmcmFnbWVudDAgPT09IFwicGF0aG5hbWVcIiAmJiBkYXRhWzBdICE9PSBcIi9cIikgZGF0YSA9IFwiL1wiICsgZGF0YVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0dmFyIGFzeW5jSWRcblx0ZnVuY3Rpb24gZGVib3VuY2VBc3luYyhjYWxsYmFjazApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoYXN5bmNJZCAhPSBudWxsKSByZXR1cm5cblx0XHRcdGFzeW5jSWQgPSBjYWxsQXN5bmMwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRhc3luY0lkID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjazAoKVxuXHRcdFx0fSlcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgsIHF1ZXJ5RGF0YSwgaGFzaERhdGEpIHtcblx0XHR2YXIgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIilcblx0XHR2YXIgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiI1wiKVxuXHRcdHZhciBwYXRoRW5kID0gcXVlcnlJbmRleCA+IC0xID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogcGF0aC5sZW5ndGhcblx0XHRpZiAocXVlcnlJbmRleCA+IC0xKSB7XG5cdFx0XHR2YXIgcXVlcnlFbmQgPSBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHBhdGgubGVuZ3RoXG5cdFx0XHR2YXIgcXVlcnlQYXJhbXMgPSBwYXJzZVF1ZXJ5U3RyaW5nKHBhdGguc2xpY2UocXVlcnlJbmRleCArIDEsIHF1ZXJ5RW5kKSlcblx0XHRcdGZvciAodmFyIGtleTQgaW4gcXVlcnlQYXJhbXMpIHF1ZXJ5RGF0YVtrZXk0XSA9IHF1ZXJ5UGFyYW1zW2tleTRdXG5cdFx0fVxuXHRcdGlmIChoYXNoSW5kZXggPiAtMSkge1xuXHRcdFx0dmFyIGhhc2hQYXJhbXMgPSBwYXJzZVF1ZXJ5U3RyaW5nKHBhdGguc2xpY2UoaGFzaEluZGV4ICsgMSkpXG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIGhhc2hQYXJhbXMpIGhhc2hEYXRhW2tleTRdID0gaGFzaFBhcmFtc1trZXk0XVxuXHRcdH1cblx0XHRyZXR1cm4gcGF0aC5zbGljZSgwLCBwYXRoRW5kKVxuXHR9XG5cdHZhciByb3V0ZXIgPSB7cHJlZml4OiBcIiMhXCJ9XG5cdHJvdXRlci5nZXRQYXRoID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHR5cGUyID0gcm91dGVyLnByZWZpeC5jaGFyQXQoMClcblx0XHRzd2l0Y2ggKHR5cGUyKSB7XG5cdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gbm9ybWFsaXplMShcImhhc2hcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpXG5cdFx0XHRjYXNlIFwiP1wiOiByZXR1cm4gbm9ybWFsaXplMShcInNlYXJjaFwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aCkgKyBub3JtYWxpemUxKFwiaGFzaFwiKVxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIG5vcm1hbGl6ZTEoXCJwYXRobmFtZVwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aCkgKyBub3JtYWxpemUxKFwic2VhcmNoXCIpICsgbm9ybWFsaXplMShcImhhc2hcIilcblx0XHR9XG5cdH1cblx0cm91dGVyLnNldFBhdGggPSBmdW5jdGlvbihwYXRoLCBkYXRhLCBvcHRpb25zKSB7XG5cdFx0dmFyIHF1ZXJ5RGF0YSA9IHt9LCBoYXNoRGF0YSA9IHt9XG5cdFx0cGF0aCA9IHBhcnNlUGF0aChwYXRoLCBxdWVyeURhdGEsIGhhc2hEYXRhKVxuXHRcdGlmIChkYXRhICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTQgaW4gZGF0YSkgcXVlcnlEYXRhW2tleTRdID0gZGF0YVtrZXk0XVxuXHRcdFx0cGF0aCA9IHBhdGgucmVwbGFjZSgvOihbXlxcL10rKS9nLCBmdW5jdGlvbihtYXRjaDIsIHRva2VuKSB7XG5cdFx0XHRcdGRlbGV0ZSBxdWVyeURhdGFbdG9rZW5dXG5cdFx0XHRcdHJldHVybiBkYXRhW3Rva2VuXVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0dmFyIHF1ZXJ5ID0gYnVpbGRRdWVyeVN0cmluZyhxdWVyeURhdGEpXG5cdFx0aWYgKHF1ZXJ5KSBwYXRoICs9IFwiP1wiICsgcXVlcnlcblx0XHR2YXIgaGFzaCA9IGJ1aWxkUXVlcnlTdHJpbmcoaGFzaERhdGEpXG5cdFx0aWYgKGhhc2gpIHBhdGggKz0gXCIjXCIgKyBoYXNoXG5cdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSB7XG5cdFx0XHR2YXIgc3RhdGUgPSBvcHRpb25zID8gb3B0aW9ucy5zdGF0ZSA6IG51bGxcblx0XHRcdHZhciB0aXRsZSA9IG9wdGlvbnMgPyBvcHRpb25zLnRpdGxlIDogbnVsbFxuXHRcdFx0JHdpbmRvdy5vbnBvcHN0YXRlKClcblx0XHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVwbGFjZSkgJHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHJvdXRlci5wcmVmaXggKyBwYXRoKVxuXHRcdFx0ZWxzZSAkd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgcm91dGVyLnByZWZpeCArIHBhdGgpXG5cdFx0fVxuXHRcdGVsc2UgJHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcm91dGVyLnByZWZpeCArIHBhdGhcblx0fVxuXHRyb3V0ZXIuZGVmaW5lUm91dGVzID0gZnVuY3Rpb24ocm91dGVzLCByZXNvbHZlLCByZWplY3QpIHtcblx0XHRmdW5jdGlvbiByZXNvbHZlUm91dGUoKSB7XG5cdFx0XHR2YXIgcGF0aCA9IHJvdXRlci5nZXRQYXRoKClcblx0XHRcdHZhciBwYXJhbXMgPSB7fVxuXHRcdFx0dmFyIHBhdGhuYW1lID0gcGFyc2VQYXRoKHBhdGgsIHBhcmFtcywgcGFyYW1zKVxuXHRcdFx0dmFyIHN0YXRlID0gJHdpbmRvdy5oaXN0b3J5LnN0YXRlXG5cdFx0XHRpZiAoc3RhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKHZhciBrIGluIHN0YXRlKSBwYXJhbXNba10gPSBzdGF0ZVtrXVxuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgcm91dGUwIGluIHJvdXRlcykge1xuXHRcdFx0XHR2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoXCJeXCIgKyByb3V0ZTAucmVwbGFjZSgvOlteXFwvXSs/XFwuezN9L2csIFwiKC4qPylcIikucmVwbGFjZSgvOlteXFwvXSsvZywgXCIoW15cXFxcL10rKVwiKSArIFwiXFwvPyRcIilcblx0XHRcdFx0aWYgKG1hdGNoZXIudGVzdChwYXRobmFtZSkpIHtcblx0XHRcdFx0XHRwYXRobmFtZS5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIGtleXMgPSByb3V0ZTAubWF0Y2goLzpbXlxcL10rL2cpIHx8IFtdXG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEsIC0yKVxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHBhcmFtc1trZXlzW2ldLnJlcGxhY2UoLzp8XFwuL2csIFwiXCIpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZXNbaV0pXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJvdXRlc1tyb3V0ZTBdLCBwYXJhbXMsIHBhdGgsIHJvdXRlMClcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWplY3QocGF0aCwgcGFyYW1zKVxuXHRcdH1cblx0XHRpZiAoc3VwcG9ydHNQdXNoU3RhdGUpICR3aW5kb3cub25wb3BzdGF0ZSA9IGRlYm91bmNlQXN5bmMocmVzb2x2ZVJvdXRlKVxuXHRcdGVsc2UgaWYgKHJvdXRlci5wcmVmaXguY2hhckF0KDApID09PSBcIiNcIikgJHdpbmRvdy5vbmhhc2hjaGFuZ2UgPSByZXNvbHZlUm91dGVcblx0XHRyZXNvbHZlUm91dGUoKVxuXHR9XG5cdHJldHVybiByb3V0ZXJcbn1cbnZhciBfMjAgPSBmdW5jdGlvbigkd2luZG93LCByZWRyYXdTZXJ2aWNlMCkge1xuXHR2YXIgcm91dGVTZXJ2aWNlID0gY29yZVJvdXRlcigkd2luZG93KVxuXHR2YXIgaWRlbnRpdHkgPSBmdW5jdGlvbih2KSB7cmV0dXJuIHZ9XG5cdHZhciByZW5kZXIxLCBjb21wb25lbnQsIGF0dHJzMywgY3VycmVudFBhdGgsIGxhc3RVcGRhdGVcblx0dmFyIHJvdXRlID0gZnVuY3Rpb24ocm9vdCwgZGVmYXVsdFJvdXRlLCByb3V0ZXMpIHtcblx0XHRpZiAocm9vdCA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IHRoYXQgd2FzIHBhc3NlZCB0byBgbS5yb3V0ZWAgaXMgbm90IHVuZGVmaW5lZFwiKVxuXHRcdHZhciBydW4xID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAocmVuZGVyMSAhPSBudWxsKSByZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgcmVuZGVyMShWbm9kZShjb21wb25lbnQsIGF0dHJzMy5rZXksIGF0dHJzMykpKVxuXHRcdH1cblx0XHR2YXIgYmFpbCA9IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdGlmIChwYXRoICE9PSBkZWZhdWx0Um91dGUpIHJvdXRlU2VydmljZS5zZXRQYXRoKGRlZmF1bHRSb3V0ZSwgbnVsbCwge3JlcGxhY2U6IHRydWV9KVxuXHRcdFx0ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSBkZWZhdWx0IHJvdXRlIFwiICsgZGVmYXVsdFJvdXRlKVxuXHRcdH1cblx0XHRyb3V0ZVNlcnZpY2UuZGVmaW5lUm91dGVzKHJvdXRlcywgZnVuY3Rpb24ocGF5bG9hZCwgcGFyYW1zLCBwYXRoKSB7XG5cdFx0XHR2YXIgdXBkYXRlID0gbGFzdFVwZGF0ZSA9IGZ1bmN0aW9uKHJvdXRlUmVzb2x2ZXIsIGNvbXApIHtcblx0XHRcdFx0aWYgKHVwZGF0ZSAhPT0gbGFzdFVwZGF0ZSkgcmV0dXJuXG5cdFx0XHRcdGNvbXBvbmVudCA9IGNvbXAgIT0gbnVsbCAmJiAodHlwZW9mIGNvbXAudmlldyA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBjb21wID09PSBcImZ1bmN0aW9uXCIpPyBjb21wIDogXCJkaXZcIlxuXHRcdFx0XHRhdHRyczMgPSBwYXJhbXMsIGN1cnJlbnRQYXRoID0gcGF0aCwgbGFzdFVwZGF0ZSA9IG51bGxcblx0XHRcdFx0cmVuZGVyMSA9IChyb3V0ZVJlc29sdmVyLnJlbmRlciB8fCBpZGVudGl0eSkuYmluZChyb3V0ZVJlc29sdmVyKVxuXHRcdFx0XHRydW4xKClcblx0XHRcdH1cblx0XHRcdGlmIChwYXlsb2FkLnZpZXcgfHwgdHlwZW9mIHBheWxvYWQgPT09IFwiZnVuY3Rpb25cIikgdXBkYXRlKHt9LCBwYXlsb2FkKVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmIChwYXlsb2FkLm9ubWF0Y2gpIHtcblx0XHRcdFx0XHRQcm9taXNlLnJlc29sdmUocGF5bG9hZC5vbm1hdGNoKHBhcmFtcywgcGF0aCkpLnRoZW4oZnVuY3Rpb24ocmVzb2x2ZWQpIHtcblx0XHRcdFx0XHRcdHVwZGF0ZShwYXlsb2FkLCByZXNvbHZlZClcblx0XHRcdFx0XHR9LCBiYWlsKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgdXBkYXRlKHBheWxvYWQsIFwiZGl2XCIpXG5cdFx0XHR9XG5cdFx0fSwgYmFpbClcblx0XHRyZWRyYXdTZXJ2aWNlMC5zdWJzY3JpYmUocm9vdCwgcnVuMSlcblx0fVxuXHRyb3V0ZS5zZXQgPSBmdW5jdGlvbihwYXRoLCBkYXRhLCBvcHRpb25zKSB7XG5cdFx0aWYgKGxhc3RVcGRhdGUgIT0gbnVsbCkgb3B0aW9ucyA9IHtyZXBsYWNlOiB0cnVlfVxuXHRcdGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0cm91dGVTZXJ2aWNlLnNldFBhdGgocGF0aCwgZGF0YSwgb3B0aW9ucylcblx0fVxuXHRyb3V0ZS5nZXQgPSBmdW5jdGlvbigpIHtyZXR1cm4gY3VycmVudFBhdGh9XG5cdHJvdXRlLnByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeDApIHtyb3V0ZVNlcnZpY2UucHJlZml4ID0gcHJlZml4MH1cblx0cm91dGUubGluayA9IGZ1bmN0aW9uKHZub2RlMSkge1xuXHRcdHZub2RlMS5kb20uc2V0QXR0cmlidXRlKFwiaHJlZlwiLCByb3V0ZVNlcnZpY2UucHJlZml4ICsgdm5vZGUxLmF0dHJzLmhyZWYpXG5cdFx0dm5vZGUxLmRvbS5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSB8fCBlLndoaWNoID09PSAyKSByZXR1cm5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKVxuXHRcdFx0ZS5yZWRyYXcgPSBmYWxzZVxuXHRcdFx0dmFyIGhyZWYgPSB0aGlzLmdldEF0dHJpYnV0ZShcImhyZWZcIilcblx0XHRcdGlmIChocmVmLmluZGV4T2Yocm91dGVTZXJ2aWNlLnByZWZpeCkgPT09IDApIGhyZWYgPSBocmVmLnNsaWNlKHJvdXRlU2VydmljZS5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0cm91dGUuc2V0KGhyZWYsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRyb3V0ZS5wYXJhbSA9IGZ1bmN0aW9uKGtleTMpIHtcblx0XHRpZih0eXBlb2YgYXR0cnMzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBrZXkzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gYXR0cnMzW2tleTNdXG5cdFx0cmV0dXJuIGF0dHJzM1xuXHR9XG5cdHJldHVybiByb3V0ZVxufVxubS5yb3V0ZSA9IF8yMCh3aW5kb3csIHJlZHJhd1NlcnZpY2UpXG5tLndpdGhBdHRyID0gZnVuY3Rpb24oYXR0ck5hbWUsIGNhbGxiYWNrMSwgY29udGV4dCkge1xuXHRyZXR1cm4gZnVuY3Rpb24oZSkge1xuXHRcdGNhbGxiYWNrMS5jYWxsKGNvbnRleHQgfHwgdGhpcywgYXR0ck5hbWUgaW4gZS5jdXJyZW50VGFyZ2V0ID8gZS5jdXJyZW50VGFyZ2V0W2F0dHJOYW1lXSA6IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKVxuXHR9XG59XG52YXIgXzI4ID0gY29yZVJlbmRlcmVyKHdpbmRvdylcbm0ucmVuZGVyID0gXzI4LnJlbmRlclxubS5yZWRyYXcgPSByZWRyYXdTZXJ2aWNlLnJlZHJhd1xubS5yZXF1ZXN0ID0gcmVxdWVzdFNlcnZpY2UucmVxdWVzdFxubS5qc29ucCA9IHJlcXVlc3RTZXJ2aWNlLmpzb25wXG5tLnBhcnNlUXVlcnlTdHJpbmcgPSBwYXJzZVF1ZXJ5U3RyaW5nXG5tLmJ1aWxkUXVlcnlTdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nXG5tLnZlcnNpb24gPSBcIjEuMS4xXCJcbm0udm5vZGUgPSBWbm9kZVxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBtXG5lbHNlIHdpbmRvdy5tID0gbVxufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9taXRocmlsL21pdGhyaWwuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/* unknown exports provided */
/* all exports used */
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! ../bootstrap/css/bootstrap-theme.min.css */ 5);\n\n__webpack_require__(/*! ../app.css */ 4);\n\n__webpack_require__(/*! ../Ladda/dist/ladda-themeless.min.css */ 3);\n\nvar _mithril = __webpack_require__(/*! mithril */ 6);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction leftpanel() {\n    return (0, _mithril2.default)(\".sidepanel.container.clearfix[id='leftpanel']\", [(0, _mithril2.default)(\".panelbar[id='toggleLpanelicon']\", (0, _mithril2.default)(\"span\", [_mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\")])), (0, _mithril2.default)(\".panel-heading.text-center[id='leftpaneltitle']\", (0, _mithril2.default)(\"h3.panel-title\", \"Data Selection\")), (0, _mithril2.default)(\".btn-toolbar[role='toolbar']\", {\n        style: {\n            \"margin-left\": \".5em\",\n            \"margin-top\": \".5em\"\n        }\n    }, [(0, _mithril2.default)(\".btn-group\", {\n        style: {\n            \"margin-left\": \"0\"\n        }\n    }, [(0, _mithril2.default)(\"button.btn.active[id='btnVariables'][onclick='tabLeft(\\'tab1\\');'][title='Click variable name to add or remove the variable pebble from the modeling space.'][type='button']\", \"Variables\"), (0, _mithril2.default)(\"button.btn.btn-default[id='btnSubset'][onclick='tabLeft(\\'tab2\\');'][type='button']\", \"Subset\")]), (0, _mithril2.default)(\"button.btn.btn-default.ladda-button[data-spinner-color='#000000'][data-style='zoom-in'][id='btnSelect'][onclick='subsetSelect(\\'btnSelect\\');'][title='Subset data by the intersection of all selected values.'][type='button']\", {\n        style: {\n            \"display\": \"none\",\n            \"float\": \"right\",\n            \"margin-right\": \"10px\"\n        }\n    }, (0, _mithril2.default)(\"span.ladda-label\", {\n        style: {\n            \"pointer-events\": \"none\"\n        }\n    }, \"Select\"))]), (0, _mithril2.default)(\".row-fluid\", (0, _mithril2.default)(\"[id='leftpanelcontent']\", (0, _mithril2.default)(\"[id='leftContentArea']\", {\n        style: {\n            \"overflow\": \"scroll\",\n            \"height\": \"488px\"\n        }\n    }, [(0, _mithril2.default)(\"[id='tab1']\", {\n        style: {\n            \"display\": \"block\",\n            \"padding\": \"6px 12px\",\n            \"text-align\": \"center\"\n        }\n    }), (0, _mithril2.default)(\"[id='tab2']\", {\n        style: {\n            \"display\": \"none\",\n            \"margin-top\": \".5em\"\n        }\n    }), (0, _mithril2.default)(\"[id='tab3']\", (0, _mithril2.default)(\"p\", {\n        style: {\n            \"padding\": \".5em 1em\"\n        }\n    }, \"Select a variable from within the visualization in the center panel to view its summary statistics.\"))])))]);\n}\n\nfunction rightpanel() {\n    return (0, _mithril2.default)(\".sidepanel.container.clearfix[id='rightpanel']\", [(0, _mithril2.default)(\".panelbar[id='toggleRpanelicon']\", (0, _mithril2.default)(\"span\", [_mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\")])), (0, _mithril2.default)(\".panel-heading.text-center[id='rightpaneltitle']\", (0, _mithril2.default)(\"h3.panel-title\", \"Model Selection\")), (0, _mithril2.default)(\".btn-group.btn-group-justified[aria-label='...'][role='group']\", {\n        style: {\n            \"margin-top\": \".5em\"\n        }\n    }, [(0, _mithril2.default)(\"button.btn.active[id='btnModels'][onclick='tabRight(\\'btnModels\\');'][type='button']\", {\n        style: {\n            \"width\": \"33%\"\n        }\n    }, \"Models\"), (0, _mithril2.default)(\"button.btn.btn-default[id='btnSetx'][onclick='tabRight(\\'btnSetx\\');'][type='button']\", {\n        style: {\n            \"width\": \"34%\"\n        }\n    }, \"Set Covar.\"), (0, _mithril2.default)(\"button.btn.btn-default[id='btnResults'][onclick='tabRight(\\'btnResults\\');'][type='button']\", {\n        style: {\n            \"width\": \"33%\"\n        }\n    }, \"Results\")]), (0, _mithril2.default)(\".row-fluid\", (0, _mithril2.default)(\"[id='rightpanelcontent']\", (0, _mithril2.default)(\"[id='rightContentArea']\", {\n        style: {\n            \"overflow\": \"scroll\",\n            \"height\": \"488px\"\n        }\n    }, [(0, _mithril2.default)(\"[id='results']\", {\n        style: {\n            \"margin-top\": \".5em\"\n        }\n    }, [(0, _mithril2.default)(\".container[id='resultsView']\", {\n        style: {\n            \"width\": \"80%\",\n            \"background-color\": \"white\",\n            \"display\": \"none\",\n            \"float\": \"right\",\n            \"overflow\": \"auto\",\n            \"white-space\": \"nowrap\"\n        }\n    }), (0, _mithril2.default)(\"[id='modelView']\", {\n        style: {\n            \"width\": \"20%\",\n            \"background-color\": \"white\",\n            \"display\": \"none\",\n            \"float\": \"left\"\n        }\n    }), (0, _mithril2.default)(\"p[id='resultsHolder']\", {\n        style: {\n            \"padding\": \".5em 1em\"\n        }\n    })]), (0, _mithril2.default)(\"[id='setx']\", {\n        style: {\n            \"display\": \"none\"\n        }\n    }), (0, _mithril2.default)(\"[id='models']\", {\n        style: {\n            \"display\": \"block\",\n            \"padding\": \"6px 12px\",\n            \"text-align\": \"center\"\n        }\n    })])))]);\n}\n\nvar Body = function () {\n    function Body() {\n        _classCallCheck(this, Body);\n    }\n\n    _createClass(Body, [{\n        key: 'oncreate',\n        value: function oncreate() {\n            __webpack_require__(/*! ./script.js */ 2);\n            __webpack_require__(/*! ../app_ddi.js */ 1);\n        }\n    }, {\n        key: 'view',\n        value: function view() {\n            return (0, _mithril2.default)('main', (0, _mithril2.default)(\"nav.navbar.navbar-default[id='option'][role='navigation']\", (0, _mithril2.default)(\"div\", [(0, _mithril2.default)(\".navbar-header[id='navbarheader']\", [(0, _mithril2.default)(\"img[alt='TwoRavens'][onmouseout='closeabout();'][onmouseover='about();'][src='images/TwoRavens.png'][width='100']\", {\n                style: {\n                    \"margin-left\": \"2em\",\n                    \"margin-top\": \"-0.5em\"\n                }\n            }), (0, _mithril2.default)(\".panel.panel-default[id='about']\", {\n                style: {\n                    \"position\": \"absolute\",\n                    \"left\": \"140px\",\n                    \"width\": \"380px\",\n                    \"display\": \"none\",\n                    \"z-index\": \"50\"\n                }\n            }, (0, _mithril2.default)(\".panel-body\"))]), (0, _mithril2.default)(\".field[id='dataField']\", {\n                style: {\n                    \"text-align\": \"center\",\n                    \"margin-top\": \"0.5em\"\n                }\n            }, [(0, _mithril2.default)(\"h4[id='dataName'][onclick='citetoggle=clickcite(citetoggle);'][onmouseout='closecite(citetoggle);'][onmouseover='opencite();']\", {\n                style: {\n                    \"display\": \"inline\"\n                }\n            }, \"Dataset Name\"), (0, _mithril2.default)(\".panel.panel-default[id='cite']\", {\n                style: {\n                    \"position\": \"absolute\",\n                    \"right\": \"50%\",\n                    \"width\": \"380px\",\n                    \"display\": \"none\",\n                    \"z-index\": \"50\",\n                    \"text-align\": \"left\"\n                }\n            }, (0, _mithril2.default)(\".panel-body\")), (0, _mithril2.default)(\"button.btn.btn-default.ladda-button.navbar-right[data-spinner-color='#000000'][data-style='zoom-in'][id='btnEstimate'][onclick='estimate(\\'btnEstimate\\')']\", {\n                style: {\n                    \"margin-left\": \"2em\",\n                    \"margin-right\": \"1em\"\n                }\n            }, (0, _mithril2.default)(\"span.ladda-label\", \"Estimate\")), (0, _mithril2.default)(\"button.btn.btn-default.navbar-right[id='btnReset'][onclick='reset()'][title='Reset']\", {\n                style: {\n                    \"margin-left\": \"2.0em\"\n                }\n            }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-repeat\", {\n                style: {\n                    \"font-size\": \"1em\",\n                    \"color\": \"#818181\",\n                    \"pointer-events\": \"none\"\n                }\n            })), (0, _mithril2.default)(\".transformTool[id='transformations'][title='Construct transformations of existing variables using valid R syntax. For example, assuming a variable named d, you could enter \\'log(d)\\' or \\'d^2\\'.']\")])])), (0, _mithril2.default)(\".left.svg-leftpanel.svg-rightpanel.carousel.slide[id='main']\", [(0, _mithril2.default)(\".carousel-inner\"), (0, _mithril2.default)(\".spaceTool[id='spacetools']\", {\n                style: {\n                    \"z-index\": \"16\"\n                }\n            }, [(0, _mithril2.default)(\"button.btn.btn-default[id='btnForce'][onclick='forceSwitch()'][title='Pin the variable pebbles to the page.']\", (0, _mithril2.default)(\"span.glyphicon.glyphicon-pushpin\")), (0, _mithril2.default)(\"button.btn.btn-default[id='btnEraser'][onclick='erase()'][title='Wipe all variables from the modeling space.']\", (0, _mithril2.default)(\"span.glyphicon.glyphicon-magnet\"))]), (0, _mithril2.default)(\".legendary.panel.panel-default[id='legend']\", {\n                style: {\n                    \"display\": \"none\"\n                }\n            }, [(0, _mithril2.default)(\".panel-heading\", (0, _mithril2.default)(\"h3.panel-title\", [\"Legend  \", (0, _mithril2.default)(\"span.glyphicon.glyphicon-large.glyphicon-chevron-down.pull-right[data-target='#collapseLegend'][data-toggle='collapse'][href='#collapseLegend'][onclick='$(this).toggleClass(\\'glyphicon-chevron-up\\').toggleClass(\\'glyphicon-chevron-down\\');']\", {\n                style: _defineProperty({\n                    \"cursor\": \"pointer\"\n                }, 'cursor', \"hand\")\n            })])), (0, _mithril2.default)(\".panel-collapse.collapse.in[id='collapseLegend']\", (0, _mithril2.default)(\".panel-body\", [(0, _mithril2.default)(\".clearfix.hide[id='timeButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Time\")]), (0, _mithril2.default)(\".clearfix.hide[id='csButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Cross Sec\")]), (0, _mithril2.default)(\".clearfix.hide[id='dvButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Dep Var\")]), (0, _mithril2.default)(\".clearfix.hide[id='nomButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Nom Var\")])]))]), (0, _mithril2.default)(\".logbox.panel.panel-default[id='logdiv']\", {\n                style: {\n                    \"display\": \"none\"\n                }\n            }, [(0, _mithril2.default)(\".panel-heading\", (0, _mithril2.default)(\"h3.panel-title\", [\"History \", (0, _mithril2.default)(\"span.glyphicon.glyphicon-large.glyphicon-chevron-down.pull-right[data-target='#collapseLog'][data-toggle='collapse'][href='#collapseLog'][id='logicon'][onclick='$(this).toggleClass(\\'glyphicon-chevron-down\\').toggleClass(\\'glyphicon-chevron-up\\');']\", {\n                style: _defineProperty({\n                    \"cursor\": \"pointer\"\n                }, 'cursor', \"hand\")\n            })])), (0, _mithril2.default)(\".panel-collapse.collapse.in[id='collapseLog']\", (0, _mithril2.default)(\".panel-body\"))]), (0, _mithril2.default)(\"[id='ticker']\", {\n                style: {\n                    \"position\": \"fixed\",\n                    \"height\": \"50px\",\n                    \"width\": \"100%\",\n                    \"background\": \"#F9F9F9\",\n                    \"bottom\": \"0\"\n                }\n            }, (0, _mithril2.default)(\"a[href='somelink'][id='logID'][target='_blank']\", \"Replication\")), leftpanel(), rightpanel()]));\n        }\n    }]);\n\n    return Body;\n}();\n\n_mithril2.default.mount(document.body, Body);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvaW5kZXguanM/MWZkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4uL2Jvb3RzdHJhcC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3MnO1xuaW1wb3J0ICcuLi9hcHAuY3NzJztcbmltcG9ydCAnLi4vTGFkZGEvZGlzdC9sYWRkYS10aGVtZWxlc3MubWluLmNzcyc7XG5cbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5mdW5jdGlvbiBsZWZ0cGFuZWwoKSB7XG4gICAgcmV0dXJuIG0oXCIuc2lkZXBhbmVsLmNvbnRhaW5lci5jbGVhcmZpeFtpZD0nbGVmdHBhbmVsJ11cIiwgW1xuICAgICAgICBtKFwiLnBhbmVsYmFyW2lkPSd0b2dnbGVMcGFuZWxpY29uJ11cIixcbiAgICAgICAgICAgIG0oXCJzcGFuXCIsIFtcbiAgICAgICAgICAgICAgICBtLnRydXN0KFwiJiM5Njc5O1wiKSxcbiAgICAgICAgICAgICAgICBtKFwiYnJcIiksXG4gICAgICAgICAgICAgICAgbS50cnVzdChcIiYjOTY3OTtcIiksXG4gICAgICAgICAgICAgICAgbShcImJyXCIpLFxuICAgICAgICAgICAgICAgIG0udHJ1c3QoXCImIzk2Nzk7XCIpLFxuICAgICAgICAgICAgICAgIG0oXCJiclwiKSxcbiAgICAgICAgICAgICAgICBtLnRydXN0KFwiJiM5Njc5O1wiKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgKSxcbiAgICAgICAgbShcIi5wYW5lbC1oZWFkaW5nLnRleHQtY2VudGVyW2lkPSdsZWZ0cGFuZWx0aXRsZSddXCIsXG4gICAgICAgICAgICBtKFwiaDMucGFuZWwtdGl0bGVcIixcbiAgICAgICAgICAgICAgICBcIkRhdGEgU2VsZWN0aW9uXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgbShcIi5idG4tdG9vbGJhcltyb2xlPSd0b29sYmFyJ11cIiwge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBcIm1hcmdpbi1sZWZ0XCI6IFwiLjVlbVwiLFxuICAgICAgICAgICAgICAgIFwibWFyZ2luLXRvcFwiOiBcIi41ZW1cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXG4gICAgICAgICAgICBtKFwiLmJ0bi1ncm91cFwiLCB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBcIjBcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5hY3RpdmVbaWQ9J2J0blZhcmlhYmxlcyddW29uY2xpY2s9J3RhYkxlZnQoXFwndGFiMVxcJyk7J11bdGl0bGU9J0NsaWNrIHZhcmlhYmxlIG5hbWUgdG8gYWRkIG9yIHJlbW92ZSB0aGUgdmFyaWFibGUgcGViYmxlIGZyb20gdGhlIG1vZGVsaW5nIHNwYWNlLiddW3R5cGU9J2J1dHRvbiddXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiVmFyaWFibGVzXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0W2lkPSdidG5TdWJzZXQnXVtvbmNsaWNrPSd0YWJMZWZ0KFxcJ3RhYjJcXCcpOyddW3R5cGU9J2J1dHRvbiddXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiU3Vic2V0XCJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0LmxhZGRhLWJ1dHRvbltkYXRhLXNwaW5uZXItY29sb3I9JyMwMDAwMDAnXVtkYXRhLXN0eWxlPSd6b29tLWluJ11baWQ9J2J0blNlbGVjdCddW29uY2xpY2s9J3N1YnNldFNlbGVjdChcXCdidG5TZWxlY3RcXCcpOyddW3RpdGxlPSdTdWJzZXQgZGF0YSBieSB0aGUgaW50ZXJzZWN0aW9uIG9mIGFsbCBzZWxlY3RlZCB2YWx1ZXMuJ11bdHlwZT0nYnV0dG9uJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmbG9hdFwiOiBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1yaWdodFwiOiBcIjEwcHhcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtKFwic3Bhbi5sYWRkYS1sYWJlbFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJTZWxlY3RcIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgXSksXG4gICAgICAgIG0oXCIucm93LWZsdWlkXCIsXG4gICAgICAgICAgICBtKFwiW2lkPSdsZWZ0cGFuZWxjb250ZW50J11cIixcbiAgICAgICAgICAgICAgICBtKFwiW2lkPSdsZWZ0Q29udGVudEFyZWEnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm92ZXJmbG93XCI6IFwic2Nyb2xsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiBcIjQ4OHB4XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgbShcIltpZD0ndGFiMSddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiYmxvY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmdcIjogXCI2cHggMTJweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dC1hbGlnblwiOiBcImNlbnRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBtKFwiW2lkPSd0YWIyJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tdG9wXCI6IFwiLjVlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sICksXG4gICAgICAgICAgICAgICAgICAgIG0oXCJbaWQ9J3RhYjMnXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcInBcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nXCI6IFwiLjVlbSAxZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlNlbGVjdCBhIHZhcmlhYmxlIGZyb20gd2l0aGluIHRoZSB2aXN1YWxpemF0aW9uIGluIHRoZSBjZW50ZXIgcGFuZWwgdG8gdmlldyBpdHMgc3VtbWFyeSBzdGF0aXN0aWNzLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgKVxuICAgICAgICApXG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIHJpZ2h0cGFuZWwoKSB7XG4gICAgcmV0dXJuIG0oXCIuc2lkZXBhbmVsLmNvbnRhaW5lci5jbGVhcmZpeFtpZD0ncmlnaHRwYW5lbCddXCIsIFtcbiAgICAgICAgbShcIi5wYW5lbGJhcltpZD0ndG9nZ2xlUnBhbmVsaWNvbiddXCIsXG4gICAgICAgICAgICBtKFwic3BhblwiLCBbXG4gICAgICAgICAgICAgICAgbS50cnVzdChcIiYjOTY3OTtcIiksXG4gICAgICAgICAgICAgICAgbShcImJyXCIpLFxuICAgICAgICAgICAgICAgIG0udHJ1c3QoXCImIzk2Nzk7XCIpLFxuICAgICAgICAgICAgICAgIG0oXCJiclwiKSxcbiAgICAgICAgICAgICAgICBtLnRydXN0KFwiJiM5Njc5O1wiKSxcbiAgICAgICAgICAgICAgICBtKFwiYnJcIiksXG4gICAgICAgICAgICAgICAgbS50cnVzdChcIiYjOTY3OTtcIilcbiAgICAgICAgICAgIF0pXG4gICAgICAgICksXG4gICAgICAgIG0oXCIucGFuZWwtaGVhZGluZy50ZXh0LWNlbnRlcltpZD0ncmlnaHRwYW5lbHRpdGxlJ11cIixcbiAgICAgICAgICAgIG0oXCJoMy5wYW5lbC10aXRsZVwiLFxuICAgICAgICAgICAgICAgIFwiTW9kZWwgU2VsZWN0aW9uXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgbShcIi5idG4tZ3JvdXAuYnRuLWdyb3VwLWp1c3RpZmllZFthcmlhLWxhYmVsPScuLi4nXVtyb2xlPSdncm91cCddXCIsIHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgXCJtYXJnaW4tdG9wXCI6IFwiLjVlbVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmFjdGl2ZVtpZD0nYnRuTW9kZWxzJ11bb25jbGljaz0ndGFiUmlnaHQoXFwnYnRuTW9kZWxzXFwnKTsnXVt0eXBlPSdidXR0b24nXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMzMlXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJNb2RlbHNcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0W2lkPSdidG5TZXR4J11bb25jbGljaz0ndGFiUmlnaHQoXFwnYnRuU2V0eFxcJyk7J11bdHlwZT0nYnV0dG9uJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjM0JVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiU2V0IENvdmFyLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHRbaWQ9J2J0blJlc3VsdHMnXVtvbmNsaWNrPSd0YWJSaWdodChcXCdidG5SZXN1bHRzXFwnKTsnXVt0eXBlPSdidXR0b24nXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMzMlXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJSZXN1bHRzXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgXSksXG4gICAgICAgIG0oXCIucm93LWZsdWlkXCIsXG4gICAgICAgICAgICBtKFwiW2lkPSdyaWdodHBhbmVsY29udGVudCddXCIsXG4gICAgICAgICAgICAgICAgbShcIltpZD0ncmlnaHRDb250ZW50QXJlYSddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwib3ZlcmZsb3dcIjogXCJzY3JvbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IFwiNDg4cHhcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW1xuICAgICAgICAgICAgICAgICAgICBtKFwiW2lkPSdyZXN1bHRzJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogXCIuNWVtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5jb250YWluZXJbaWQ9J3Jlc3VsdHNWaWV3J11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCI4MCVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsb2F0XCI6IFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdmVyZmxvd1wiOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aGl0ZS1zcGFjZVwiOiBcIm5vd3JhcFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiW2lkPSdtb2RlbFZpZXcnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjIwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxvYXRcIjogXCJsZWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJwW2lkPSdyZXN1bHRzSG9sZGVyJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZ1wiOiBcIi41ZW0gMWVtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgbShcIltpZD0nc2V0eCddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBtKFwiW2lkPSdtb2RlbHMnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImJsb2NrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nXCI6IFwiNnB4IDEycHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRleHQtYWxpZ25cIjogXCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICApXG4gICAgICAgIClcbiAgICBdKTtcbn1cblxuY2xhc3MgQm9keSB7XG5cdG9uY3JlYXRlKCkge1xuXHRcdHJlcXVpcmUoJy4vc2NyaXB0LmpzJyk7XHRcblx0XHRyZXF1aXJlKCcuLi9hcHBfZGRpLmpzJyk7XHRcblx0fVxuXHRcblx0dmlldygpIHtcbiAgICAgICAgcmV0dXJuIG0oJ21haW4nLFxuICAgICAgICAgICAgbShcIm5hdi5uYXZiYXIubmF2YmFyLWRlZmF1bHRbaWQ9J29wdGlvbiddW3JvbGU9J25hdmlnYXRpb24nXVwiLFxuICAgICAgICAgICAgICAgIG0oXCJkaXZcIiwgW1xuICAgICAgICAgICAgICAgICAgICBtKFwiLm5hdmJhci1oZWFkZXJbaWQ9J25hdmJhcmhlYWRlciddXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJpbWdbYWx0PSdUd29SYXZlbnMnXVtvbm1vdXNlb3V0PSdjbG9zZWFib3V0KCk7J11bb25tb3VzZW92ZXI9J2Fib3V0KCk7J11bc3JjPSdpbWFnZXMvVHdvUmF2ZW5zLnBuZyddW3dpZHRoPScxMDAnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBcIjJlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogXCItMC41ZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC5wYW5lbC1kZWZhdWx0W2lkPSdhYm91dCddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsZWZ0XCI6IFwiMTQwcHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIzODBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ6LWluZGV4XCI6IFwiNTBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWJvZHlcIiwgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgbShcIi5maWVsZFtpZD0nZGF0YUZpZWxkJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRleHQtYWxpZ25cIjogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogXCIwLjVlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJoNFtpZD0nZGF0YU5hbWUnXVtvbmNsaWNrPSdjaXRldG9nZ2xlPWNsaWNrY2l0ZShjaXRldG9nZ2xlKTsnXVtvbm1vdXNlb3V0PSdjbG9zZWNpdGUoY2l0ZXRvZ2dsZSk7J11bb25tb3VzZW92ZXI9J29wZW5jaXRlKCk7J11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiaW5saW5lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJEYXRhc2V0IE5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwucGFuZWwtZGVmYXVsdFtpZD0nY2l0ZSddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyaWdodFwiOiBcIjUwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjM4MHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInotaW5kZXhcIjogXCI1MFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0LWFsaWduXCI6IFwibGVmdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwtYm9keVwiLCApXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHQubGFkZGEtYnV0dG9uLm5hdmJhci1yaWdodFtkYXRhLXNwaW5uZXItY29sb3I9JyMwMDAwMDAnXVtkYXRhLXN0eWxlPSd6b29tLWluJ11baWQ9J2J0bkVzdGltYXRlJ11bb25jbGljaz0nZXN0aW1hdGUoXFwnYnRuRXN0aW1hdGVcXCcpJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBcIjJlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tcmlnaHRcIjogXCIxZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwic3Bhbi5sYWRkYS1sYWJlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkVzdGltYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHQubmF2YmFyLXJpZ2h0W2lkPSdidG5SZXNldCddW29uY2xpY2s9J3Jlc2V0KCknXVt0aXRsZT0nUmVzZXQnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1sZWZ0XCI6IFwiMi4wZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwic3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLXJlcGVhdFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjFlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBcIiM4MTgxODFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcIi50cmFuc2Zvcm1Ub29sW2lkPSd0cmFuc2Zvcm1hdGlvbnMnXVt0aXRsZT0nQ29uc3RydWN0IHRyYW5zZm9ybWF0aW9ucyBvZiBleGlzdGluZyB2YXJpYWJsZXMgdXNpbmcgdmFsaWQgUiBzeW50YXguIEZvciBleGFtcGxlLCBhc3N1bWluZyBhIHZhcmlhYmxlIG5hbWVkIGQsIHlvdSBjb3VsZCBlbnRlciBcXCdsb2coZClcXCcgb3IgXFwnZF4yXFwnLiddXCIsIClcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG0oXCIubGVmdC5zdmctbGVmdHBhbmVsLnN2Zy1yaWdodHBhbmVsLmNhcm91c2VsLnNsaWRlW2lkPSdtYWluJ11cIiwgW1xuICAgICAgICAgICAgICAgIG0oXCIuY2Fyb3VzZWwtaW5uZXJcIiwgKSxcbiAgICAgICAgICAgICAgICBtKFwiLnNwYWNlVG9vbFtpZD0nc3BhY2V0b29scyddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiei1pbmRleFwiOiBcIjE2XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHRbaWQ9J2J0bkZvcmNlJ11bb25jbGljaz0nZm9yY2VTd2l0Y2goKSddW3RpdGxlPSdQaW4gdGhlIHZhcmlhYmxlIHBlYmJsZXMgdG8gdGhlIHBhZ2UuJ11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tcHVzaHBpblwiKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdFtpZD0nYnRuRXJhc2VyJ11bb25jbGljaz0nZXJhc2UoKSddW3RpdGxlPSdXaXBlIGFsbCB2YXJpYWJsZXMgZnJvbSB0aGUgbW9kZWxpbmcgc3BhY2UuJ11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tbWFnbmV0XCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBtKFwiLmxlZ2VuZGFyeS5wYW5lbC5wYW5lbC1kZWZhdWx0W2lkPSdsZWdlbmQnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC1oZWFkaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiaDMucGFuZWwtdGl0bGVcIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTGVnZW5kICBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwic3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLWxhcmdlLmdseXBoaWNvbi1jaGV2cm9uLWRvd24ucHVsbC1yaWdodFtkYXRhLXRhcmdldD0nI2NvbGxhcHNlTGVnZW5kJ11bZGF0YS10b2dnbGU9J2NvbGxhcHNlJ11baHJlZj0nI2NvbGxhcHNlTGVnZW5kJ11bb25jbGljaz0nJCh0aGlzKS50b2dnbGVDbGFzcyhcXCdnbHlwaGljb24tY2hldnJvbi11cFxcJykudG9nZ2xlQ2xhc3MoXFwnZ2x5cGhpY29uLWNoZXZyb24tZG93blxcJyk7J11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjdXJzb3JcIjogXCJwb2ludGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImN1cnNvclwiOiBcImhhbmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwtY29sbGFwc2UuY29sbGFwc2UuaW5baWQ9J2NvbGxhcHNlTGVnZW5kJ11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwtYm9keVwiLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5jbGVhcmZpeC5oaWRlW2lkPSd0aW1lQnV0dG9uJ11cIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RDb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcInN2Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMjBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCIyMHB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcImNpcmNsZVtjeD0nMTAnXVtjeT0nMTAnXVtmaWxsPSd3aGl0ZSddW3I9JzknXVtzdHJva2U9J2JsYWNrJ11bc3Ryb2tlLXdpZHRoPScyJ11cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0TGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGltZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLmNsZWFyZml4LmhpZGVbaWQ9J2NzQnV0dG9uJ11cIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RDb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcInN2Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMjBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCIyMHB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcImNpcmNsZVtjeD0nMTAnXVtjeT0nMTAnXVtmaWxsPSd3aGl0ZSddW3I9JzknXVtzdHJva2U9J2JsYWNrJ11bc3Ryb2tlLXdpZHRoPScyJ11cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0TGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ3Jvc3MgU2VjXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIuY2xlYXJmaXguaGlkZVtpZD0nZHZCdXR0b24nXVwiLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucmVjdENvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwic3ZnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIyMHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiBcIjIwcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiY2lyY2xlW2N4PScxMCddW2N5PScxMCddW2ZpbGw9J3doaXRlJ11bcj0nOSddW3N0cm9rZT0nYmxhY2snXVtzdHJva2Utd2lkdGg9JzInXVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RMYWJlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJEZXAgVmFyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIuY2xlYXJmaXguaGlkZVtpZD0nbm9tQnV0dG9uJ11cIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RDb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcInN2Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMjBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCIyMHB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcImNpcmNsZVtjeD0nMTAnXVtjeT0nMTAnXVtmaWxsPSd3aGl0ZSddW3I9JzknXVtzdHJva2U9J2JsYWNrJ11bc3Ryb2tlLXdpZHRoPScyJ11cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0TGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTm9tIFZhclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIG0oXCIubG9nYm94LnBhbmVsLnBhbmVsLWRlZmF1bHRbaWQ9J2xvZ2RpdiddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW1xuICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWhlYWRpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJoMy5wYW5lbC10aXRsZVwiLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJIaXN0b3J5IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tbGFyZ2UuZ2x5cGhpY29uLWNoZXZyb24tZG93bi5wdWxsLXJpZ2h0W2RhdGEtdGFyZ2V0PScjY29sbGFwc2VMb2cnXVtkYXRhLXRvZ2dsZT0nY29sbGFwc2UnXVtocmVmPScjY29sbGFwc2VMb2cnXVtpZD0nbG9naWNvbiddW29uY2xpY2s9JyQodGhpcykudG9nZ2xlQ2xhc3MoXFwnZ2x5cGhpY29uLWNoZXZyb24tZG93blxcJykudG9nZ2xlQ2xhc3MoXFwnZ2x5cGhpY29uLWNoZXZyb24tdXBcXCcpOyddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY3Vyc29yXCI6IFwicG9pbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjdXJzb3JcIjogXCJoYW5kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWNvbGxhcHNlLmNvbGxhcHNlLmluW2lkPSdjb2xsYXBzZUxvZyddXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWJvZHlcIiwgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgbShcIltpZD0ndGlja2VyJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IFwiZml4ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiBcIjUwcHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZFwiOiBcIiNGOUY5RjlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJvdHRvbVwiOiBcIjBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtKFwiYVtocmVmPSdzb21lbGluayddW2lkPSdsb2dJRCddW3RhcmdldD0nX2JsYW5rJ11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVwbGljYXRpb25cIlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsZWZ0cGFuZWwoKSxcbiAgICAgICAgICAgICAgICByaWdodHBhbmVsKClcbiAgICAgICAgICAgIF0pXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5tLm1vdW50KGRvY3VtZW50LmJvZHksIEJvZHkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9pbmRleC5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBQ0E7QUFEQTtBQURBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBUUE7QUFDQTtBQURBO0FBREE7QUFZQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBUUE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQVFBO0FBQ0E7QUFEQTtBQURBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFrQkE7QUFDQTtBQURBO0FBREE7QUFNQTtBQUNBO0FBREE7QUFEQTtBQVFBO0FBQ0E7QUFEQTtBQURBO0FBUUE7QUFDQTtBQURBO0FBREE7QUFXQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBT0E7QUFDQTtBQURBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBREE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFEQTtBQVNBO0FBQ0E7QUFEQTtBQURBO0FBT0E7QUFDQTtBQURBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFXQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQURBO0FBYUE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBQ0E7QUFEQTtBQURBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQURBO0FBYUE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQVdBO0FBQ0E7QUFEQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBZUE7QUFDQTtBQURBO0FBREE7QUFhQTtBQUNBO0FBREE7QUFEQTtBQVNBO0FBQ0E7QUFEQTtBQURBO0FBYUE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQWdCQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBZ0JBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFnQkE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQWlCQTtBQUNBO0FBREE7QUFEQTtBQVNBO0FBQ0E7QUFEQTtBQURBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFEQTtBQWlCQTs7Ozs7O0FBR0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 8 */
/* unknown exports provided */
/* all exports used */
/*!******************************!*\
  !*** ./~/process/browser.js ***!
  \******************************/
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzPzgyZTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 9 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ./~/setimmediate/setImmediate.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 0), __webpack_require__(/*! ./../process/browser.js */ 8)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz80YTgwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 10 */
/* unknown exports provided */
/* all exports used */
/*!*************************************!*\
  !*** ./~/timers-browserify/main.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ 9);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanM/YjA4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ })
/******/ ]);