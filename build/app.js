/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/MzY5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!********************!*\
  !*** ./app_ddi.js ***!
  \********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//////////\n// Globals\n\n// hostname default - the app will use it to obtain the variable metadata\n// (ddi) and pre-processed data info if the file id is supplied as an \n// argument (for ex., gui.html?dfId=17), but hostname isn't. \n// Edit it to suit your installation. \n// (NOTE that if the file id isn't supplied, the app will default to the \n// local files specified below!)\n// NEW: it is also possible now to supply complete urls for the ddi and \n// the tab-delimited data file; the parameters are ddiurl and dataurl. \n// These new parameters are optional. If they are not supplied, the app\n// will go the old route - will try to cook standard dataverse urls \n// for both the data and metadata, if the file id is supplied; or the \n// local files if nothing is supplied. \n// -- L.A.\n\nvar varColor = '#f0f8ff'; //d3.rgb(\"aliceblue\");\nvar selVarColor = '#fa8072'; //d3.rgb(\"salmon\");\nvar dvColor = '#28a4c9';\nvar nomColor = '#ff6600';\n\n// transformation toolbar options\nvar transformList = [\"log(d)\", \"exp(d)\", \"d^2\", \"sqrt(d)\", \"interact(d,e)\"];\n\n// Radius of circle\nvar allR = 40;\n\n// space index\nvar myspace = 0;\n\nvar forcetoggle = [\"true\"];\nvar priv = false;\n\nvar valueKey = [];\nvar allNodes = [];\nvar nodes = [];\nvar links = [];\nvar mods = {};\n\nvar svg, width, height, div, obj;\nvar arc3, arc4;\n\nmodule.exports = function main(fileid, hostname, ddiurl, dataurl) {\n    var production = false;\n\n    if (production && fileid == \"\") {\n        alert(\"Error: No fileid has been provided.\");\n        throw new Error(\"Error: No fileid has been provided.\");\n    }\n\n    var dataverseurl = \"\";\n\n    if (hostname) {\n        dataverseurl = \"https://\" + hostname;\n    } else if (production) {\n        dataverseurl = \"%PRODUCTION_DATAVERSE_URL%\";\n    } else {\n        dataverseurl = \"http://localhost:8080\";\n    }\n\n    if (fileid && !dataurl) {\n        // file id supplied; we are going to assume that we are dealing with\n        // a dataverse and cook a standard dataverse data access url,\n        // with the fileid supplied and the hostname we have\n        // either supplied or configured:\n        dataurl = dataverseurl + \"/api/access/datafile/\" + fileid;\n        dataurl = dataurl + \"?key=\" + apikey;\n        // (it is also possible to supply dataurl to the script directly, \n        // as an argument -- L.A.)\n    }\n\n    // base URL for the R apps:\n    if (!production) {\n        var rappURL = \"http://0.0.0.0:8000/custom/\";\n    } else {\n        var rappURL = \"https://beta.dataverse.org/custom/\"; //this will change when/if the production host changes\n    }\n\n    svg = d3.select(\"#main.left div.carousel-inner\").attr('id', 'innercarousel').append('div').attr('class', 'item active').attr('id', 'm0').append('svg').attr('id', 'whitespace');\n\n    var logArray = [];\n\n    var tempWidth = d3.select(\"#main.left\").style(\"width\");\n    width = tempWidth.substring(0, tempWidth.length - 2);\n    height = $(window).height() - 120; // Hard coding for header and footer and bottom margin.\n\n    var estimated = false;\n    var estimateLadda = Ladda.create(document.getElementById(\"btnEstimate\"));\n    var selectLadda = Ladda.create(document.getElementById(\"btnSelect\"));\n    var rightClickLast = false;\n\n    // this is the initial color scale that is used to establish the initial colors of the nodes.  allNodes.push() below establishes a field for the master node array allNodes called \"nodeCol\" and assigns a color from this scale to that field.  everything there after should refer to the nodeCol and not the color scale, this enables us to update colors and pass the variable type to R based on its coloring\n    var colors = d3.scale.category20();\n\n    var colorTime = false;\n    var timeColor = '#2d6ca2';\n\n    var colorCS = false;\n    var csColor = '#419641';\n\n    var depVar = false;\n\n    var subsetdiv = false;\n    var setxdiv = false;\n\n    var taggedColor = '#f5f5f5'; //d3.rgb(\"whitesmoke\");\n    var grayColor = '#c0c0c0';\n\n    var lefttab = \"tab1\"; //global for current tab in left panel\n    var righttab = \"btnModels\"; // global for current tab in right panel\n\n    var zparams = {\n        zdata: [],\n        zedges: [],\n        ztime: [],\n        znom: [],\n        zcross: [],\n        zmodel: \"\",\n        zvars: [],\n        zdv: [],\n        zdataurl: \"\",\n        zsubset: [],\n        zsetx: [],\n        zmodelcount: 0,\n        zplot: [],\n        zsessionid: \"\",\n        zdatacite: \"\"\n    };\n\n    //Width and height for histgrams\n    var barwidth = 1.3 * allR;\n    var barheight = 0.5 * allR;\n    var barPadding = 0.35;\n    var barnumber = 7;\n\n    var arc0 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(0).endAngle(3.2);\n\n    var arc1 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(0).endAngle(1);\n\n    var arc2 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(1.1).endAngle(2.2);\n\n    arc3 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(2.3).endAngle(3.3);\n\n    var arc4 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(4.3).endAngle(5.3);\n\n    // From .csv\n    var dataset2 = [];\n    var lablArray = [];\n    var hold = [];\n    var allResults = [];\n    var subsetNodes = [];\n    var transformVar = \"\";\n    var summaryHold = false;\n    var selInteract = false;\n    var modelCount = 0;\n    var callHistory = []; // unique to the space. saves transform and subset calls.\n    var citetoggle = false;\n\n    // arry of objects containing allNode, zparams, transform vars\n    var spaces = [];\n    var trans = []; //var list for each space contain variables in original data plus trans in that space\n\n    // end of (most) global declarations (minus functions)\n\n    // collapsable user log\n    $('#collapseLog').on('shown.bs.collapse', function () {\n        d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").data(logArray).enter().append(\"p\").text(function (d) {\n            return d;\n        });\n        //$(\"#logicon\").removeClass(\"glyphicon-chevron-up\").addClass(\"glyphicon-chevron-down\");\n    });\n\n    $('#collapseLog').on('hidden.bs.collapse', function () {\n        d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").remove();\n        //$(\"#logicon\").removeClass(\"glyphicon-chevron-down\").addClass(\"glyphicon-chevron-up\");\n    });\n\n    // text for the about box\n    // note that .textContent is the new way to write text to a div\n    $('#about div.panel-body').text('TwoRavens v0.1 \"Dallas\" -- The Norse god Odin had two talking ravens as advisors, who would fly out into the world and report back all they observed.  In the Norse, their names were \"Thought\" and \"Memory\".  In our coming release, our thought-raven automatically advises on statistical model selection, while our memory-raven accumulates previous statistical models from Dataverse, to provide cummulative guidance and meta-analysis.'); //This is the first public release of a new, interactive Web application to explore data, view descriptive statistics, and estimate statistical models.\";\n\n    //\n    // read DDI metadata with d3:\n    var metadataurl = \"\";\n    if (ddiurl) {\n        // a complete ddiurl is supplied:\n        metadataurl = ddiurl;\n    } else if (fileid) {\n        // file id supplied; we're going to cook a standard dataverse\n        // metadata url, with the file id provided and the hostname\n        // supplied or configured:\n        metadataurl = dataverseurl + \"/api/meta/datafile/\" + fileid;\n    } else {\n        // neither a full ddi url, nor file id supplied; use one of the sample DDIs that come with\n        // the app, in the data directory:\n        // metadataurl=\"data/qog137.xml\"; // quality of government\n        //metadataurl=\"data/fearonLaitin.xml\"; // This is Fearon Laitin\n        metadataurl = \"data/PUMS5small-ddi.xml\"; // This is California PUMS subset\n        //metadataurl=\"data/BP.formatted-ddi.xml\";\n        //metadataurl=\"data/FL_insurance_sample-ddi.xml\";\n        //metadataurl=\"data/strezhnev_voeten_2013.xml\";   // This is Strezhnev Voeten\n        //metadataurl=\"data/19.xml\"; // Fearon from DVN Demo\n        //metadataurl=\"data/76.xml\"; // Collier from DVN Demo\n        //metadataurl=\"data/79.xml\"; // two vars from DVN Demo\n        //metadataurl=\"data/000.xml\"; // one var in metadata\n        //metadataurl=\"data/0000.xml\"; // zero vars in metadata\n    }\n\n    // Reading the pre-processed metadata:\n    // Pre-processed data:\n    var pURL = \"\";\n    if (dataurl) {\n        // data url is supplied\n        pURL = dataurl + \"&format=prep\";\n    } else {\n        // no dataurl/file id supplied; use one of the sample data files distributed with the\n        // app in the \"data\" directory:\n        //pURL = \"data/preprocess2429360.txt\";   // This is the Strezhnev Voeten JSON data\n        // pURL = \"data/fearonLaitin.json\";     // This is the Fearon Laitin JSON data\n        //pURL = \"data/fearonLaitinNewPreprocess3long.json\";     // This is the revised (May 29, 2015) Fearon Laitin JSON data\n        pURL = \"data/preprocessPUMS5small.json\"; // This is California PUMS subset\n        //pURL = \"data/FL_insurance_sample.tab.json\";\n\n        // pURL = \"data/qog_pp.json\";   // This is Qual of Gov\n    }\n\n    var preprocess = {};\n\n    // this is the function and callback routine that loads all external data: metadata (DVN's ddi), preprocessed (for plotting distributions), and zeligmodels (produced by Zelig) and initiates the data download to the server\n    var url, p, v, _callback;\n    readPreprocess(url = pURL, p = preprocess, v = null, _callback = function callback() {\n        d3.xml(metadataurl, \"application/xml\", function (xml) {\n            var vars = xml.documentElement.getElementsByTagName(\"var\");\n            var temp = xml.documentElement.getElementsByTagName(\"fileName\");\n            zparams.zdata = temp[0].childNodes[0].nodeValue;\n\n            // clean the citation so that the POST is valid json\n            function cleanstring(s) {\n                s = s.replace(/\\&/g, \"and\");\n                s = s.replace(/\\;/g, \",\");\n                s = s.replace(/\\%/g, \"-\");\n                return s;\n            }\n\n            var cite = xml.documentElement.getElementsByTagName(\"biblCit\");\n            zparams.zdatacite = cite[0].childNodes[0].nodeValue;\n            zparams.zdatacite = cleanstring(zparams.zdatacite);\n\n            // dataset name trimmed to 12 chars\n            var dataname = zparams.zdata.replace(/\\.(.*)/, \"\"); // regular expression to drop any file extension\n            // Put dataset name, from meta-data, into top panel\n            d3.select(\"#dataName\").html(dataname);\n\n            $('#cite div.panel-body').text(zparams.zdatacite);\n\n            // Put dataset name, from meta-data, into page title\n            d3.select(\"title\").html(\"TwoRavens \" + dataname);\n\n            // temporary values for hold that correspond to histogram bins\n            hold = [.6, .2, .9, .8, .1, .3, .4];\n            var myvalues = [0, 0, 0, 0, 0];\n            for (var i = 0; i < vars.length; i++) {\n                valueKey[i] = vars[i].attributes.name.nodeValue;\n\n                if (vars[i].getElementsByTagName(\"labl\").length === 0) {\n                    lablArray[i] = \"no label\";\n                } else {\n                    lablArray[i] = vars[i].getElementsByTagName(\"labl\")[0].childNodes[0].nodeValue;\n                }\n\n                var datasetcount = d3.layout.histogram().bins(barnumber).frequency(false)(myvalues);\n\n                // this creates an object to be pushed to allNodes. this contains all the preprocessed data we have for the variable, as well as UI data pertinent to that variable, such as setx values (if the user has selected them) and pebble coordinates\n                var obj1 = {\n                    id: i,\n                    reflexive: false,\n                    \"name\": valueKey[i],\n                    \"labl\": lablArray[i],\n                    data: [5, 15, 20, 0, 5, 15, 20],\n                    count: hold,\n                    \"nodeCol\": colors(i),\n                    \"baseCol\": colors(i),\n                    \"strokeColor\": selVarColor,\n                    \"strokeWidth\": \"1\",\n                    \"subsetplot\": false,\n                    \"subsetrange\": [\"\", \"\"],\n                    \"setxplot\": false,\n                    \"setxvals\": [\"\", \"\"],\n                    \"grayout\": false\n                };\n                jQuery.extend(true, obj1, preprocess[valueKey[i]]);\n                allNodes.push(obj1);\n            };\n\n            // Reading the zelig models and populating the model list in the right panel.\n            d3.json(\"data/zelig5models.json\", function (error, json) {\n                if (error) return console.warn(error);\n                var jsondata = json;\n\n                console.log(\"zelig models json: \", jsondata);\n                for (var key in jsondata.zelig5models) {\n                    if (jsondata.zelig5models.hasOwnProperty(key)) {\n                        mods[jsondata.zelig5models[key].name[0]] = jsondata.zelig5models[key].description[0];\n                    }\n                }\n\n                d3.json(\"data/zelig5choicemodels.json\", function (error, json) {\n                    if (error) return console.warn(error);\n                    var jsondata = json;\n                    console.log(\"zelig choice models json: \", jsondata);\n                    for (var key in jsondata.zelig5choicemodels) {\n                        if (jsondata.zelig5choicemodels.hasOwnProperty(key)) {\n                            mods[jsondata.zelig5choicemodels[key].name[0]] = jsondata.zelig5choicemodels[key].description[0];\n                        }\n                    }\n\n                    scaffolding(_callback = layout);\n                    dataDownload();\n                });\n            });\n        });\n    });\n};\n\n// scaffolding is called after all external data are guaranteed to have been read to completion. this populates the left panel with variable names, the right panel with model names, the transformation tool, an the associated mouseovers. its callback is layout(), which initializes the modeling space\nfunction scaffolding(callback) {\n    // establishing the transformation element\n    d3.select(\"#transformations\").append(\"input\").attr(\"id\", \"tInput\").attr(\"class\", \"form-control\").attr(\"type\", \"text\").attr(\"value\", \"Variable transformation\");\n\n    // the variable dropdown\n    d3.select(\"#transformations\").append(\"ul\").attr(\"id\", \"transSel\").style(\"display\", \"none\").style(\"background-color\", varColor).selectAll('li').data([\"a\", \"b\"]) //set to variables in model space as they're added\n    .enter().append(\"li\").text(function (d) {\n        return d;\n    });\n\n    // the function dropdown\n    d3.select(\"#transformations\").append(\"ul\").attr(\"id\", \"transList\").style(\"display\", \"none\").style(\"background-color\", varColor).selectAll('li').data(transformList).enter().append(\"li\").text(function (d) {\n        return d;\n    });\n\n    //jquery does this well\n    $('#tInput').click(function () {\n        var t = document.getElementById('transSel').style.display;\n        if (t !== \"none\") {\n            // if variable list is displayed when input is clicked...\n            $('#transSel').fadeOut(100);\n            return false;\n        }\n        var t1 = document.getElementById('transList').style.display;\n        if (t1 !== \"none\") {\n            // if function list is displayed when input is clicked...\n            $('#transList').fadeOut(100);\n            return false;\n        }\n\n        // highlight the text\n        $(this).select();\n\n        var pos = $('#tInput').offset();\n        pos.top += $('#tInput').width();\n        $('#transSel').fadeIn(100);\n        return false;\n    });\n\n    $('#tInput').keyup(function (event) {\n        var t = document.getElementById('transSel').style.display;\n        var t1 = document.getElementById('transList').style.display;\n\n        if (t !== \"none\") {\n            $('#transSel').fadeOut(100);\n        } else if (t1 !== \"none\") {\n            $('#transList').fadeOut(100);\n        }\n\n        if (event.keyCode == 13) {\n            // keyup on \"Enter\"\n            var n = $('#tInput').val();\n            var t = transParse(n = n);\n            if (t === null) {\n                return;\n            }\n            transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n        }\n    });\n\n    $('#transList li').click(function (event) {\n        var tvar = $('#tInput').val();\n\n        // if interact is selected, show variable list again\n        if ($(this).text() === \"interact(d,e)\") {\n            $('#tInput').val(tvar.concat('*'));\n            selInteract = true;\n            $(this).parent().fadeOut(100);\n            $('#transSel').fadeIn(100);\n            event.stopPropagation();\n            return;\n        }\n\n        var tfunc = $(this).text().replace(\"d\", \"_transvar0\");\n        var tcall = $(this).text().replace(\"d\", tvar);\n        $('#tInput').val(tcall);\n        $(this).parent().fadeOut(100);\n        event.stopPropagation();\n        transform(n = tvar, t = tfunc, typeTransform = false);\n    });\n\n    // populating the variable list in the left panel\n    d3.select(\"#tab1\").selectAll(\"p\").data(valueKey).enter().append(\"p\").attr(\"id\", function (d) {\n        return d.replace(/\\W/g, \"_\"); // replace non-alphanumerics for selection purposes\n    }) // perhapse ensure this id is unique by adding '_' to the front?\n    .text(function (d) {\n        return d;\n    }).style('background-color', function (d) {\n        if (findNodeIndex(d) > 2) {\n            return varColor;\n        } else {\n            return hexToRgba(selVarColor);\n        }\n    }).attr(\"data-container\", \"body\").attr(\"data-toggle\", \"popover\").attr(\"data-trigger\", \"hover\").attr(\"data-placement\", \"right\").attr(\"data-html\", \"true\").attr(\"onmouseover\", \"$(this).popover('toggle');\").attr(\"onmouseout\", \"$(this).popover('toggle');\").attr(\"data-original-title\", \"Summary Statistics\");\n\n    d3.select(\"#models\").style('height', 2000).style('overfill', 'scroll');\n\n    var modellist = Object.keys(mods);\n\n    d3.select(\"#models\").selectAll(\"p\").data(modellist).enter().append(\"p\").attr(\"id\", function (d) {\n        return \"_model_\".concat(d);\n    }).text(function (d) {\n        return d;\n    }).style('background-color', function (d) {\n        return varColor;\n    }).attr(\"data-container\", \"body\").attr(\"data-toggle\", \"popover\").attr(\"data-trigger\", \"hover\").attr(\"data-placement\", \"top\").attr(\"data-html\", \"true\").attr(\"onmouseover\", \"$(this).popover('toggle');\").attr(\"onmouseout\", \"$(this).popover('toggle');\").attr(\"data-original-title\", \"Model Description\").attr(\"data-content\", function (d) {\n        return mods[d];\n    });\n\n    if (typeof callback === \"function\") {\n        callback(); // this calls layout() because at this point all scaffolding is up and ready\n    }\n}\n\nfunction layout(v) {\n    var myValues = [];\n    nodes = [];\n    links = [];\n\n    if (v === \"add\" | v === \"move\") {\n        d3.select(\"#tab1\").selectAll(\"p\").style('background-color', varColor);\n        for (var j = 0; j < zparams.zvars.length; j++) {\n            var ii = findNodeIndex(zparams.zvars[j]);\n            if (allNodes[ii].grayout) {\n                continue;\n            }\n            nodes.push(allNodes[ii]);\n            var selectMe = zparams.zvars[j].replace(/\\W/g, \"_\");\n            selectMe = \"#\".concat(selectMe);\n            d3.select(selectMe).style('background-color', function () {\n                return hexToRgba(nodes[j].strokeColor);\n            });\n        }\n\n        for (var j = 0; j < zparams.zedges.length; j++) {\n            var mysrc = nodeIndex(zparams.zedges[j][0]);\n            var mytgt = nodeIndex(zparams.zedges[j][1]);\n            links.push({\n                source: nodes[mysrc],\n                target: nodes[mytgt],\n                left: false,\n                right: true\n            });\n        }\n    } else {\n        if (allNodes.length > 2) {\n            nodes = [allNodes[0], allNodes[1], allNodes[2]];\n            links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }, {\n                source: nodes[0],\n                target: nodes[2],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 2) {\n            nodes = [allNodes[0], allNodes[1]];\n            links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 1) {\n            nodes = [allNodes[0]];\n        } else {\n            alert(\"There are zero variables in the metadata.\");\n            return;\n        }\n    }\n\n    panelPlots(); // after nodes is populated, add subset and setx panels\n    populatePopover(); // pipes in the summary stats shown on mouseovers\n\n    // init D3 force layout\n    var force = d3.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(150).charge(-800).on('tick', tick); // .start() is important to initialize the layout\n\n    // define arrow markers for graph links\n    svg.append('svg:defs').append('svg:marker').attr('id', 'end-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 6).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto').append('svg:path').attr('d', 'M0,-5L10,0L0,5').style('fill', '#000');\n\n    svg.append('svg:defs').append('svg:marker').attr('id', 'start-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 4).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto').append('svg:path').attr('d', 'M10,-5L0,0L10,5').style('fill', '#000');\n\n    // line displayed when dragging new nodes\n    var drag_line = svg.append('svg:path').attr('class', 'link dragline hidden').attr('d', 'M0,0L0,0');\n\n    // handles to link and node element groups\n    var path = svg.append('svg:g').selectAll('path'),\n        circle = svg.append('svg:g').selectAll('g');\n\n    // mouse event vars\n    var selected_node = null,\n        selected_link = null,\n        mousedown_link = null,\n        mousedown_node = null,\n        mouseup_node = null;\n\n    function resetMouseVars() {\n        mousedown_node = null;\n        mouseup_node = null;\n        mousedown_link = null;\n    }\n\n    // update force layout (called automatically each iteration)\n    function tick() {\n        // draw directed edges with proper padding from node centers\n        path.attr('d', function (d) {\n            var deltaX = d.target.x - d.source.x,\n                deltaY = d.target.y - d.source.y,\n                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n                normX = deltaX / dist,\n                normY = deltaY / dist,\n                sourcePadding = d.left ? allR + 5 : allR,\n                targetPadding = d.right ? allR + 5 : allR,\n                sourceX = d.source.x + sourcePadding * normX,\n                sourceY = d.source.y + sourcePadding * normY,\n                targetX = d.target.x - targetPadding * normX,\n                targetY = d.target.y - targetPadding * normY;\n            return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;\n        });\n\n        circle.attr('transform', function (d) {\n            return 'translate(' + d.x + ',' + d.y + ')';\n        });\n    }\n\n    //  add listeners to leftpanel.left.  every time a variable is clicked, nodes updates and background color changes.  mouseover shows summary stats or model description.\n    d3.select(\"#tab1\").selectAll(\"p\").on(\"mouseover\", function (d) {\n        // REMOVED THIS TOOLTIP CODE AND MADE A BOOTSTRAP POPOVER COMPONENT\n        $(\"body div.popover\").addClass(\"variables\");\n        $(\"body div.popover div.popover-content\").addClass(\"form-horizontal\");\n    }).on(\"mouseout\", function () {\n        //Remove the tooltip\n        //d3.select(\"#tooltip\").style(\"display\", \"none\");\n    }).on(\"click\", function varClick() {\n        if (allNodes[findNodeIndex(this.id)].grayout) {\n            return null;\n        }\n        d3.select(this).style('background-color', function (d) {\n            var myText = d3.select(this).text();\n            var myColor = d3.select(this).style('background-color');\n            var mySC = allNodes[findNodeIndex(myText)].strokeColor;\n\n            zparams.zvars = []; //empty the zvars array\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                // we are adding a var\n                if (nodes.length == 0) {\n                    nodes.push(findNode(myText));\n                    nodes[0].reflexive = true;\n                } else {\n                    nodes.push(findNode(myText));\n                }\n                return hexToRgba(selVarColor);\n            } else {\n                // dropping a variable\n\n                nodes.splice(findNode(myText)[\"index\"], 1);\n                spliceLinksForNode(findNode(myText));\n\n                if (mySC == dvColor) {\n                    var dvIndex = zparams.zdv.indexOf(myText);\n                    if (dvIndex > -1) {\n                        zparams.zdv.splice(dvIndex, 1);\n                    }\n                    //zparams.zdv=\"\";\n                } else if (mySC == csColor) {\n                    var csIndex = zparams.zcross.indexOf(myText);\n                    if (csIndex > -1) {\n                        zparams.zcross.splice(csIndex, 1);\n                    }\n                } else if (mySC == timeColor) {\n                    var timeIndex = zparams.ztime.indexOf(myText);\n                    if (timeIndex > -1) {\n                        zparams.ztime.splice(timeIndex, 1);\n                    }\n                } else if (mySC == nomColor) {\n                    var nomIndex = zparams.znom.indexOf(myText);\n                    if (nomIndex > -1) {\n                        zparams.znom.splice(dvIndex, 1);\n                    }\n                }\n\n                nodeReset(allNodes[findNodeIndex(myText)]);\n                borderState();\n                legend();\n                return varColor;\n            }\n        });\n        panelPlots();\n        restart();\n    });\n\n    d3.select(\"#models\").selectAll(\"p\") // models tab\n    .on(\"mouseover\", function (d) {\n        // REMOVED THIS TOOLTIP CODE AND MADE A BOOTSTRAP POPOVER COMPONENT\n    }).on(\"mouseout\", function () {\n        //Remove the tooltip\n        //d3.select(\"#tooltip\").style(\"display\", \"none\");\n    })\n    //  d3.select(\"#Display_content\")\n    .on(\"click\", function () {\n        var myColor = d3.select(this).style('background-color');\n        d3.select(\"#models\").selectAll(\"p\").style('background-color', varColor);\n        d3.select(this).style('background-color', function (d) {\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                zparams.zmodel = d.toString();\n                return hexToRgba(selVarColor);\n            } else {\n                zparams.zmodel = \"\";\n                return varColor;\n            }\n        });\n        restart();\n    });\n\n    // update graph (called when needed)\n    function restart() {\n        // nodes.id is pegged to allNodes, i.e. the order in which variables are read in\n        // nodes.index is floating and depends on updates to nodes.  a variables index changes when new variables are added.\n        circle.call(force.drag);\n        if (forcetoggle[0] === \"true\") {\n            force.gravity(0.1);\n            force.charge(-800);\n            force.linkStrength(1);\n        } else {\n            force.gravity(0);\n            force.charge(0);\n            force.linkStrength(0);\n        }\n        force.resume();\n\n        // path (link) group\n        path = path.data(links);\n\n        // update existing links\n        // VJD: dashed links between pebbles are \"selected\". this is disabled for now\n        path.classed('selected', function (d) {\n            return;\n        }) //return d === selected_link; })\n        .style('marker-start', function (d) {\n            return d.left ? 'url(#start-arrow)' : '';\n        }).style('marker-end', function (d) {\n            return d.right ? 'url(#end-arrow)' : '';\n        });\n\n        // add new links\n        path.enter().append('svg:path').attr('class', 'link').classed('selected', function (d) {\n            return;\n        }) //return d === selected_link; })\n        .style('marker-start', function (d) {\n            return d.left ? 'url(#start-arrow)' : '';\n        }).style('marker-end', function (d) {\n            return d.right ? 'url(#end-arrow)' : '';\n        }).on('mousedown', function (d) {\n            // do we ever need to select a link? make it delete..\n            var obj1 = JSON.stringify(d);\n            for (var j = 0; j < links.length; j++) {\n                if (obj1 === JSON.stringify(links[j])) {\n                    links.splice(j, 1);\n                }\n            }\n        });\n\n        // remove old links\n        path.exit().remove();\n\n        // circle (node) group\n        circle = circle.data(nodes, function (d) {\n            return d.id;\n        });\n\n        // update existing nodes (reflexive & selected visual states)\n        //d3.rgb is the function adjusting the color here.\n        circle.selectAll('circle').classed('reflexive', function (d) {\n            return d.reflexive;\n        }).style('fill', function (d) {\n            return d3.rgb(d.nodeCol);\n        }).style('stroke', function (d) {\n            return d3.rgb(d.strokeColor);\n        }).style('stroke-width', function (d) {\n            return d.strokeWidth;\n        });\n\n        // add new nodes\n\n        var g = circle.enter().append('svg:g').attr(\"id\", function (d) {\n            var myname = d.name + \"biggroup\";\n            return myname;\n        });\n\n        // add plot\n        g.each(function (d) {\n            d3.select(this);\n            if (d.plottype === \"continuous\") {\n                densityNode(d, obj = this);\n            } else if (d.plottype === \"bar\") {\n                barsNode(d, obj = this);\n            }\n        });\n\n        g.append(\"path\").attr(\"id\", function (d) {\n            return \"dvArc\".concat(d.id);\n        }).attr(\"d\", arc3).style(\"fill\", dvColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            d3.select(this).transition().attr(\"fill-opacity\", .3).delay(0).duration(100);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", .9).delay(0).duration(100);\n        }).on('mouseout', function (d) {\n            d3.select(this).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n        }).on('click', function (d) {\n            setColors(d, dvColor);\n            legend(dvColor);\n            restart();\n        });\n        g.append(\"text\").attr(\"id\", function (d) {\n            return \"dvText\".concat(d.id);\n        }).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", function (d) {\n            return \"#dvArc\".concat(d.id);\n        }).text(\"Dep Var\");\n\n        g.append(\"path\").attr(\"id\", function (d) {\n            return \"nomArc\".concat(d.id);\n        }).attr(\"d\", arc4).style(\"fill\", nomColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            if (d.defaultNumchar == \"character\") {\n                return;\n            }\n            d3.select(this).transition().attr(\"fill-opacity\", .3).delay(0).duration(100);\n            d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", .9).delay(0).duration(100);\n        }).on('mouseout', function (d) {\n            if (d.defaultNumchar == \"character\") {\n                return;\n            }\n            d3.select(this).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n        }).on('click', function (d) {\n            if (d.defaultNumchar == \"character\") {\n                return;\n            }\n            setColors(d, nomColor);\n            legend(nomColor);\n            restart();\n        });\n        g.append(\"text\").attr(\"id\", function (d) {\n            return \"nomText\".concat(d.id);\n        }).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", function (d) {\n            return \"#nomArc\".concat(d.id);\n        }).text(\"Nominal\");\n\n        g.append('svg:circle').attr('class', 'node').attr('r', allR).style('pointer-events', 'inherit').style('fill', function (d) {\n            //      return (d === selected_node) ? d3.rgb(d.nodeCol).brighter().toString() : d.nodeCol; })\n            return d.nodeCol;\n        }).style('opacity', \"0.5\").style('stroke', function (d) {\n            return d3.rgb(d.strokeColor).toString();\n        }).classed('reflexive', function (d) {\n            return d.reflexive;\n        }).on('dblclick', function (d) {\n            d3.event.stopPropagation(); // stop click from bubbling\n            summaryHold = true;\n        }).on('contextmenu', function (d) {\n            // right click on node\n            d3.event.preventDefault();\n            d3.event.stopPropagation(); // stop right click from bubbling\n            rightClickLast = true;\n\n            mousedown_node = d;\n            if (mousedown_node === selected_node) selected_node = null;else selected_node = mousedown_node;\n            selected_link = null;\n\n            // reposition drag line\n            drag_line.style('marker-end', 'url(#end-arrow)').classed('hidden', false).attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + mousedown_node.x + ',' + mousedown_node.y);\n\n            svg.on('mousemove', mousemove);\n            restart();\n        }).on('mouseup', function (d) {\n            d3.event.stopPropagation(); // stop mouseup from bubbling\n\n            if (rightClickLast) {\n                rightClickLast = false;\n                return;\n            }\n\n            if (!mousedown_node) return;\n\n            // needed by FF\n            drag_line.classed('hidden', true).style('marker-end', '');\n\n            // check for drag-to-self\n            mouseup_node = d;\n            if (mouseup_node === mousedown_node) {\n                resetMouseVars();\n                return;\n            }\n\n            // unenlarge target node\n            d3.select(this).attr('transform', '');\n\n            // add link to graph (update if exists)\n            // NB: links are strictly source < target; arrows separately specified by booleans\n            var source, target, direction;\n            if (mousedown_node.id < mouseup_node.id) {\n                source = mousedown_node;\n                target = mouseup_node;\n                direction = 'right';\n            } else {\n                source = mouseup_node;\n                target = mousedown_node;\n                direction = 'left';\n            }\n\n            var link;\n            link = links.filter(function (l) {\n                return l.source === source && l.target === target;\n            })[0];\n            if (link) {\n                link[direction] = true;\n            } else {\n                link = {\n                    source: source,\n                    target: target,\n                    left: false,\n                    right: false\n                };\n                link[direction] = true;\n                links.push(link);\n            }\n\n            // select new link\n            selected_link = link;\n            selected_node = null;\n            svg.on('mousemove', null);\n\n            resetMouseVars();\n            restart();\n        });\n\n        // show node Names\n        g.append('svg:text').attr('x', 0).attr('y', 15).attr('class', 'id').text(function (d) {\n            return d.name;\n        });\n\n        // show summary stats on mouseover\n        // SVG doesn't support text wrapping, use html instead\n        g.selectAll(\"circle.node\").on(\"mouseover\", function (d) {\n            tabLeft(\"tab3\");\n            varSummary(d);\n            document.getElementById('transformations').setAttribute(\"style\", \"display:block\");\n            var select = document.getElementById(\"transSel\");\n            select.selectedIndex = d.id;\n            transformVar = valueKey[d.id];\n\n            d3.select(\"#dvArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n            if (d.defaultNumchar == \"numeric\") {\n                d3.select(\"#nomArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n                d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n            }\n            d3.select(\"#csArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n            d3.select(\"#csText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n            d3.select(\"#timeArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n            d3.select(\"#timeText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n        })\n        // popup(d, xPos, yPos);\n\n        .on(\"mouseout\", function (d) {\n            if (summaryHold === false) {\n                tabLeft(lefttab);\n            }\n\n            d3.select(\"#csArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#csText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#timeArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#timeText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#dvArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#nomArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n        });\n\n        // populating transformation dropdown\n        var t = [];\n        for (var j = 0; j < nodes.length; j++) {\n            t.push(nodes[j].name);\n        }\n\n        // the transformation variable list is silently updated as pebbles are added/removed\n        d3.select(\"#transSel\").selectAll('li').remove();\n\n        d3.select(\"#transSel\").selectAll('li').data(t) //set to variables in model space as they're added\n        .enter().append(\"li\").text(function (d) {\n            return d;\n        });\n\n        $('#transSel li').click(function (event) {\n            // if 'interaction' is the selected function, don't show the function list again\n            if (selInteract === true) {\n                var n = $('#tInput').val().concat($(this).text());\n                $('#tInput').val(n);\n                event.stopPropagation();\n                var t = transParse(n = n);\n                if (t === null) {\n                    return;\n                }\n                $(this).parent().fadeOut(100);\n                transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n                return;\n            }\n\n            $('#tInput').val($(this).text());\n            $(this).parent().fadeOut(100);\n            $('#transList').fadeIn(100);\n            event.stopPropagation();\n        });\n\n        // remove old nodes\n        circle.exit().remove();\n        force.start();\n    } //end restart function\n\n    function mousedown(d) {\n        // prevent I-bar on drag\n        d3.event.preventDefault();\n\n        // because :active only works in WebKit?\n        svg.classed('active', true);\n\n        if (d3.event.ctrlKey || mousedown_node || mousedown_link) {\n            return;\n        }\n\n        restart();\n    }\n\n    function mousemove(d) {\n        if (!mousedown_node) return;\n\n        // update drag line\n        drag_line.attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + d3.mouse(this)[0] + ',' + d3.mouse(this)[1]);\n    }\n\n    function mouseup(d) {\n        if (mousedown_node) {\n            // hide drag line\n            drag_line.classed('hidden', true).style('marker-end', '');\n        }\n        // because :active only works in WebKit?\n        svg.classed('active', false);\n\n        // clear mouse event vars\n        resetMouseVars();\n    }\n\n    // app starts here\n    svg.attr('id', function () {\n        return \"whitespace\".concat(myspace);\n    }).attr('height', height).on('mousedown', function () {\n        mousedown(this);\n    }).on('mouseup', function () {\n        mouseup(this);\n    });\n\n    d3.select(window).on('click', function () {\n        //NOTE: all clicks will bubble here unless event.stopPropagation()\n        $('#transList').fadeOut(100);\n        $('#transSel').fadeOut(100);\n    });\n\n    restart(); // this is the call the restart that initializes the force.layout()\n    fakeClick();\n} // end layout\n\n\n// returns id\nvar findNodeIndex = function findNodeIndex(nodeName) {\n    for (var i in allNodes) {\n        if (allNodes[i][\"name\"] === nodeName) {\n            return allNodes[i][\"id\"];\n        }\n    };\n};\n\nvar nodeIndex = function nodeIndex(nodeName) {\n    for (var i in nodes) {\n        if (nodes[i][\"name\"] === nodeName) {\n            return i;\n        }\n    }\n};\n\nvar findNode = function findNode(nodeName) {\n    for (var i in allNodes) {\n        if (allNodes[i][\"name\"] === nodeName) return allNodes[i];\n    };\n};\n\n// function called by force button\nfunction forceSwitch() {\n    if (forcetoggle[0] === \"true\") {\n        forcetoggle = [\"false\"];\n    } else {\n        forcetoggle = [\"true\"];\n    }\n\n    if (forcetoggle[0] === \"false\") {\n        document.getElementById('btnForce').setAttribute(\"class\", \"btn active\");\n    } else {\n        document.getElementById('btnForce').setAttribute(\"class\", \"btn btn-default\");\n        fakeClick();\n    }\n}\n\nfunction spliceLinksForNode(node) {\n    var toSplice = links.filter(function (l) {\n        return l.source === node || l.target === node;\n    });\n    toSplice.map(function (l) {\n        links.splice(links.indexOf(l), 1);\n    });\n}\n\nfunction zPop() {\n    if (dataurl) {\n        zparams.zdataurl = dataurl;\n    }\n\n    zparams.zmodelcount = modelCount;\n\n    zparams.zedges = [];\n    zparams.zvars = [];\n\n    for (var j = 0; j < nodes.length; j++) {\n        //populate zvars array\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n\n        zparams.zsetx[j] = allNodes[temp].setxvals;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n    }\n\n    for (var j = 0; j < links.length; j++) {\n        //populate zedges array\n        var srctgt = [];\n        //correct the source target ordering for Zelig\n        if (links[j].left === false) {\n            srctgt = [links[j].source.name, links[j].target.name];\n        } else {\n            srctgt = [links[j].target.name, links[j].source.name];\n        }\n        zparams.zedges.push(srctgt);\n    }\n}\n\nfunction estimate(btn) {\n\n    if (production && zparams.zsessionid == \"\") {\n        alert(\"Warning: Data download is not complete. Try again soon.\");\n        return;\n    }\n\n    zPop();\n    // write links to file & run R CMD\n\n    //package the output as JSON\n    // add call history and package the zparams object as JSON\n    zparams.callHistory = callHistory;\n    var jsonout = JSON.stringify(zparams);\n\n    //var base = rappURL+\"zeligapp?solaJSON=\"\n    urlcall = rappURL + \"zeligapp\"; //base.concat(jsonout);\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    zparams.allVars = valueKey.slice(10, 25); // this is because the URL is too long...\n    var jsonout = JSON.stringify(zparams);\n    //var selectorBase = rappURL+\"selectorapp?solaJSON=\";\n    var selectorurlcall = rappURL + \"selectorapp\"; //.concat(jsonout);\n\n    function estimateSuccess(btn, json) {\n        estimateLadda.stop(); // stop spinner\n        allResults.push(json);\n        console.log(allResults);\n        console.log(\"json in: \", json);\n\n        var myparent = document.getElementById(\"results\");\n        if (estimated == false) {\n            myparent.removeChild(document.getElementById(\"resultsHolder\"));\n        }\n\n        estimated = true;\n        d3.select(\"#results\").style(\"display\", \"block\");\n\n        d3.select(\"#resultsView\").style(\"display\", \"block\");\n\n        d3.select(\"#modelView\").style(\"display\", \"block\");\n\n        // programmatic click on Results button\n        $(\"#btnResults\").trigger(\"click\");\n\n        modelCount = modelCount + 1;\n        var model = \"Model\".concat(modelCount);\n\n        function modCol() {\n            d3.select(\"#modelView\").selectAll(\"p\").style('background-color', hexToRgba(varColor));\n        }\n\n        modCol();\n\n        d3.select(\"#modelView\").insert(\"p\", \":first-child\") // top stack for results\n        .attr(\"id\", model).text(model).style('background-color', hexToRgba(selVarColor)).on(\"click\", function () {\n            var a = this.style.backgroundColor.replace(/\\s*/g, \"\");\n            var b = hexToRgba(selVarColor).replace(/\\s*/g, \"\");\n            if (a.substr(0, 17) === b.substr(0, 17)) {\n                return; //escapes the function early if the displayed model is clicked\n            }\n            modCol();\n            d3.select(this).style('background-color', hexToRgba(selVarColor));\n            viz(this.id);\n        });\n\n        var rCall = [];\n        rCall[0] = json.call;\n        logArray.push(\"estimate: \".concat(rCall[0]));\n        showLog();\n\n        viz(model);\n    }\n\n    function estimateFail(btn) {\n        estimateLadda.stop(); // stop spinner\n        estimated = true;\n    }\n\n    function selectorSuccess(btn, json) {\n        d3.select(\"#ticker\").text(\"Suggested variables and percent improvement on RMSE: \" + json.vars);\n        console.log(\"selectorSuccess: \", json);\n    }\n\n    function selectorFail(btn) {\n        alert(\"Selector Fail\");\n    }\n\n    estimateLadda.start(); // start spinner\n    makeCorsRequest(urlcall, btn, estimateSuccess, estimateFail, solajsonout);\n}\n\nfunction dataDownload() {\n    zPop();\n    // write links to file & run R CMD\n\n    //package the output as JSON\n    // add call history and package the zparams object as JSON\n    var jsonout = JSON.stringify(zparams);\n    var btn = \"nobutton\";\n\n    //var base = rappURL+\"zeligapp?solaJSON=\"\n    urlcall = rappURL + \"dataapp\"; //base.concat(jsonout);\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    function downloadSuccess(btn, json) {\n        console.log(\"dataDownload json in: \", json);\n        zparams.zsessionid = json.sessionid[0];\n\n        // set the link URL\n        if (production) {\n            var logURL = rappURL + \"log_dir/log_\" + zparams.zsessionid + \".txt\";\n            document.getElementById(\"logID\").href = logURL;\n        } else {\n            var logURL = \"rook/log_\" + zparams.zsessionid + \".txt\";\n            document.getElementById(\"logID\").href = logURL;\n        }\n    }\n\n    function downloadFail(btn) {\n        console.log(\"Data have not been downloaded\");\n    }\n\n    makeCorsRequest(urlcall, btn, downloadSuccess, downloadFail, solajsonout);\n}\n\nfunction viz(m) {\n    var mym = +m.substr(5, 5) - 1;\n\n    function removeKids(parent) {\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n    }\n\n    var myparent = document.getElementById(\"resultsView\");\n    removeKids(myparent);\n\n    var json = allResults[mym];\n\n    // pipe in figures to right panel\n    var filelist = new Array();\n    for (var i in json.images) {\n        var zfig = document.createElement(\"img\");\n        zfig.setAttribute(\"src\", json.images[i]);\n        zfig.setAttribute('width', 200);\n        zfig.setAttribute('height', 200);\n        document.getElementById(\"resultsView\").appendChild(zfig);\n    }\n\n    // write the results table\n    var resultsArray = [];\n    for (var key in json.sumInfo) {\n        if (key == \"colnames\") {\n            continue;\n        }\n\n        obj = json.sumInfo[key];\n        resultsArray.push(obj);\n        /* SO says this is important check, but I don't see how it helps here...\n         for (var prop in obj) {\n         // important check that this is objects own property\n         // not from prototype prop inherited\n         if(obj.hasOwnProperty(prop)){\n         alert(prop + \" = \" + obj[prop]);\n         }\n         }  */\n    }\n\n    var table = d3.select(\"#resultsView\").append(\"p\").append(\"table\");\n\n    var thead = table.append(\"thead\");\n    thead.append(\"tr\").selectAll(\"th\").data(json.sumInfo.colnames).enter().append(\"th\").text(function (d) {\n        return d;\n    });\n\n    var tbody = table.append(\"tbody\");\n    tbody.selectAll(\"tr\").data(resultsArray).enter().append(\"tr\").selectAll(\"td\").data(function (d) {\n        return d;\n    }).enter().append(\"td\").text(function (d) {\n        var myNum = Number(d);\n        if (isNaN(myNum)) {\n            return d;\n        }\n        return myNum.toPrecision(3);\n    }).on(\"mouseover\", function () {\n        d3.select(this).style(\"background-color\", \"aliceblue\");\n    }) // for no discernable reason\n    .on(\"mouseout\", function () {\n        d3.select(this).style(\"background-color\", \"#F9F9F9\");\n    }); //(but maybe we'll think of one)\n\n    d3.select(\"#resultsView\").append(\"p\").html(function () {\n        return \"<b>Formula: </b>\".concat(json.call[0]);\n    });\n}\n\n// this function parses the transformation input. variable names are often nested inside one another, e.g., ethwar, war, wars, and so this is handled\nfunction transParse(n) {\n    var out2 = [];\n    var t2 = n;\n    var k2 = 0;\n    var subMe2 = \"_transvar\".concat(k2);\n    var indexed = [];\n\n    // out2 is all matched variables, indexed is an array, each element is an object that contains the matched variables starting index and finishing index.  e.g., n=\"wars+2\", out2=[war, wars], indexed=[{0,2},{0,3}]\n    for (var i in valueKey) {\n        var m2 = n.match(valueKey[i]);\n        if (m2 !== null) {\n            out2.push(m2[0]);\n        }\n\n        var re = new RegExp(valueKey[i], \"g\");\n        var s = n.search(re);\n        if (s != -1) {\n            indexed.push({\n                from: s,\n                to: s + valueKey[i].length\n            });\n        }\n    }\n\n    // nested loop not good, but indexed is not likely to be very large.\n    // if a variable is nested, it is removed from out2\n    // notice, loop is backwards so that index changes don't affect the splice\n    console.log(\"indexed \", indexed);\n    for (var i = indexed.length - 1; i > -1; i--) {\n        for (var j = indexed.length - 1; j > -1; j--) {\n            if (i === j) {\n                continue;\n            }\n            if (indexed[i].from >= indexed[j].from & indexed[i].to <= indexed[j].to) {\n                console.log(i, \" is nested in \", j);\n                out2.splice(i, 1);\n            }\n        }\n    }\n\n    for (var i in out2) {\n        t2 = t2.replace(out2[i], subMe2); //something that'll never be a variable name\n        k2 = k2 + 1;\n        subMe2 = \"_transvar\".concat(k2);\n    }\n\n    if (out2.length > 0) {\n        out2.push(t2);\n        console.log(\"new out \", out2);\n        return out2;\n    } else {\n        alert(\"No variable name found. Perhaps check your spelling?\");\n        return null;\n    }\n}\n\nfunction transform(n, t, typeTransform) {\n    if (production && zparams.zsessionid == \"\") {\n        alert(\"Warning: Data download is not complete. Try again soon.\");\n        return;\n    }\n\n    if (!typeTransform) {\n        t = t.replace(\"+\", \"_plus_\"); // can't send the plus operator\n    }\n\n    console.log(n);\n    console.log(t);\n\n    var btn = document.getElementById('btnEstimate');\n\n    var myn = allNodes[findNodeIndex(n[0])];\n    if (typeof myn === \"undefined\") {\n        var myn = allNodes[findNodeIndex(n)];\n    }\n\n    var outtypes = {\n        varnamesTypes: n,\n        interval: myn.interval,\n        numchar: myn.numchar,\n        nature: myn.nature,\n        binary: myn.binary\n    };\n\n    console.log(myn);\n    // if typeTransform but we already have the metadata\n    if (typeTransform) {\n        if (myn.nature == \"nominal\" & typeof myn.plotvalues !== \"undefined\") {\n            myn.plottype = \"bar\";\n            barsNode(myn);\n            populatePopover();\n            panelPlots();\n            return;\n        } else if (myn.nature != \"nominal\" & typeof myn.plotx !== \"undefined\") {\n            myn.plottype = \"continuous\";\n            densityNode(myn);\n            populatePopover();\n            panelPlots();\n            return;\n        }\n    }\n\n    //package the output as JSON\n    var transformstuff = {\n        zdataurl: dataurl,\n        zvars: n,\n        zsessionid: zparams.zsessionid,\n        transform: t,\n        callHistory: callHistory,\n        typeTransform: typeTransform,\n        typeStuff: outtypes\n    };\n    var jsonout = JSON.stringify(transformstuff);\n    //var base = rappURL+\"transformapp?solaJSON=\"\n\n    urlcall = rappURL + \"transformapp\"; //base.concat(jsonout);\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    function transformSuccess(btn, json) {\n        estimateLadda.stop();\n        console.log(\"json in: \", json);\n\n        if (json.typeTransform[0]) {\n\n            d3.json(json.url, function (error, json) {\n                if (error) return console.warn(error);\n                var jsondata = json;\n\n                for (var key in jsondata) {\n                    var myIndex = findNodeIndex(key);\n                    jQuery.extend(true, allNodes[myIndex], jsondata[key]);\n\n                    if (allNodes[myIndex].plottype === \"continuous\") {\n                        densityNode(allNodes[myIndex]);\n                    } else if (allNodes[myIndex].plottype === \"bar\") {\n                        barsNode(allNodes[myIndex]);\n                    }\n                }\n\n                fakeClick();\n                populatePopover();\n                panelPlots();\n                console.log(allNodes[myIndex]);\n            });\n        } else {\n            callHistory.push({\n                func: \"transform\",\n                zvars: n,\n                transform: t\n            });\n\n            var subseted = false;\n            var rCall = [];\n            rCall[0] = json.call;\n            var newVar = rCall[0][0];\n            trans.push(newVar);\n\n            d3.json(json.url, function (error, json) {\n                if (error) return console.warn(error);\n                var jsondata = json;\n\n                for (var key in jsondata) {\n                    var myIndex = findNodeIndex(key);\n                    if (typeof myIndex !== \"undefined\") {\n                        alert(\"Invalid transformation: this variable name already exists.\");\n                        return;\n                    }\n                    // add transformed variable to the current space\n                    var i = allNodes.length;\n                    var obj1 = {\n                        id: i,\n                        reflexive: false,\n                        \"name\": key,\n                        \"labl\": \"transformlabel\",\n                        data: [5, 15, 20, 0, 5, 15, 20],\n                        count: [.6, .2, .9, .8, .1, .3, .4],\n                        \"nodeCol\": colors(i),\n                        \"baseCol\": colors(i),\n                        \"strokeColor\": selVarColor,\n                        \"strokeWidth\": \"1\",\n                        \"subsetplot\": false,\n                        \"subsetrange\": [\"\", \"\"],\n                        \"setxplot\": false,\n                        \"setxvals\": [\"\", \"\"],\n                        \"grayout\": false,\n                        \"defaultInterval\": jsondata[key][\"interval\"],\n                        \"defaultNumchar\": jsondata[key][\"numchar\"],\n                        \"defaultNature\": jsondata[key][\"nature\"],\n                        \"defaultBinary\": jsondata[key][\"binary\"]\n                    };\n\n                    jQuery.extend(true, obj1, jsondata[key]);\n                    allNodes.push(obj1);\n\n                    scaffoldingPush(rCall[0]);\n                    valueKey.push(newVar);\n                    nodes.push(allNodes[i]);\n                    fakeClick();\n                    panelPlots();\n\n                    if (allNodes[i].plottype === \"continuous\") {\n                        densityNode(allNodes[i]);\n                    } else if (allNodes[i].plottype === \"bar\") {\n                        barsNode(allNodes[i]);\n                    }\n                } //for\n\n            });\n\n            // update the log\n            logArray.push(\"transform: \".concat(rCall[0]));\n            showLog();\n        }\n    }\n\n    function transformFail(btn) {\n        alert(\"transform fail\");\n        estimateLadda.stop();\n    }\n\n    estimateLadda.start(); // start spinner\n    makeCorsRequest(urlcall, btn, transformSuccess, transformFail, solajsonout);\n}\n\nfunction scaffoldingPush(v) {\n    // adding a variable to the variable list after a transformation\n    d3.select(\"#tab1\").data(v).append(\"p\").attr(\"id\", function () {\n        return v[0].replace(/\\W/g, \"_\");\n    }).text(v[0]).style('background-color', hexToRgba(selVarColor)).attr(\"data-container\", \"body\").attr(\"data-toggle\", \"popover\").attr(\"data-trigger\", \"hover\").attr(\"data-placement\", \"right\").attr(\"data-html\", \"true\").attr(\"onmouseover\", \"$(this).popover('toggle');\").attr(\"onmouseout\", \"$(this).popover('toggle');\").attr(\"data-original-title\", \"Summary Statistics\").on(\"click\", function varClick() {\n        // we've added a new variable, so we need to add the listener\n        d3.select(this).style('background-color', function (d) {\n            var myText = d3.select(this).text();\n            var myColor = d3.select(this).style('background-color');\n            var mySC = allNodes[findNodeIndex(myText)].strokeColor;\n\n            zparams.zvars = []; //empty the zvars array\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                // we are adding a var\n                if (nodes.length == 0) {\n                    nodes.push(findNode(myText));\n                    nodes[0].reflexive = true;\n                } else {\n                    nodes.push(findNode(myText));\n                }\n                return hexToRgba(selVarColor);\n            } else {\n                // dropping a variable\n\n                nodes.splice(findNode(myText)[\"index\"], 1);\n                spliceLinksForNode(findNode(myText));\n\n                if (mySC == dvColor) {\n                    var dvIndex = zparams.zdv.indexOf(myText);\n                    if (dvIndex > -1) {\n                        zparams.zdv.splice(dvIndex, 1);\n                    }\n                } else if (mySC == csColor) {\n                    var csIndex = zparams.zcross.indexOf(myText);\n                    if (csIndex > -1) {\n                        zparams.zcross.splice(csIndex, 1);\n                    }\n                } else if (mySC == timeColor) {\n                    var timeIndex = zparams.ztime.indexOf(myText);\n                    if (timeIndex > -1) {\n                        zparams.ztime.splice(dvIndex, 1);\n                    }\n                } else if (mySC == nomColor) {\n                    var nomIndex = zparams.znom.indexOf(myText);\n                    if (nomIndex > -1) {\n                        zparams.znom.splice(dvIndex, 1);\n                    }\n                }\n\n                nodeReset(allNodes[findNodeIndex(myText)]);\n                borderState();\n                return varColor;\n            }\n        });\n        fakeClick();\n        panelPlots();\n    });\n    populatePopover(); // pipes in the summary stats\n\n    // drop down menu for tranformation toolbar\n    d3.select(\"#transSel\").data(v).append(\"option\").text(function (d) {\n        return d;\n    });\n}\n\n// below from http://www.html5rocks.com/en/tutorials/cors/ for cross-origin resource sharing\n// Create the XHR object.\nfunction createCORSRequest(method, url, callback) {\n    var xhr = new XMLHttpRequest();\n    if (\"withCredentials\" in xhr) {\n        // XHR for Chrome/Firefox/Opera/Safari.\n        xhr.open(method, url, true);\n    } else if (typeof XDomainRequest != \"undefined\") {\n        // XDomainRequest for IE.\n        xhr = new XDomainRequest();\n        xhr.open(method, url);\n    } else {\n        // CORS not supported.\n        xhr = null;\n    }\n    //    xhr.setRequestHeader('Content-Type', 'text/plain');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    return xhr;\n}\n\n// Make the actual CORS request.\nfunction makeCorsRequest(url, btn, callback, warningcallback, jsonstring) {\n    var xhr = createCORSRequest('POST', url);\n    if (!xhr) {\n        alert('CORS not supported');\n        return;\n    }\n    // Response handlers for asynchronous load\n    // onload or onreadystatechange?\n\n    xhr.onload = function () {\n        var text = xhr.responseText;\n        console.log(\"text \", text);\n\n        try {\n            var json = JSON.parse(text); // should wrap in try / catch\n            var names = Object.keys(json);\n        } catch (err) {\n            estimateLadda.stop();\n            selectLadda.stop();\n            console.log(err);\n            alert('Error: Could not parse incoming JSON.');\n        }\n\n        if (names[0] == \"warning\") {\n            warningcallback(btn);\n            alert(\"Warning: \" + json.warning);\n        } else {\n            callback(btn, json);\n        }\n    };\n    xhr.onerror = function () {\n        // note: xhr.readystate should be 4, and status should be 200.  a status of 0 occurs when the url becomes too large\n        if (xhr.status == 0) {\n            alert('There was an error making the request. xmlhttprequest status is 0.');\n        } else if (xhr.readyState != 4) {\n            alert('There was an error making the request. xmlhttprequest readystate is not 4.');\n        } else {\n            alert('Woops, there was an error making the request.');\n        }\n        console.log(xhr);\n        estimateLadda.stop();\n        selectLadda.stop();\n    };\n    xhr.send(jsonstring);\n}\n\nfunction legend(c) {\n    // this could be made smarter\n    if (zparams.ztime.length != 0 | zparams.zcross.length != 0 | zparams.zdv.length != 0 | zparams.znom.length != 0) {\n        document.getElementById(\"legend\").setAttribute(\"style\", \"display:block\");\n    } else {\n        document.getElementById(\"legend\").setAttribute(\"style\", \"display:none\");\n    }\n\n    if (zparams.ztime.length == 0) {\n        document.getElementById(\"timeButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        document.getElementById(\"timeButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n    if (zparams.zcross.length == 0) {\n        document.getElementById(\"csButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        document.getElementById(\"csButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n    if (zparams.zdv.length == 0) {\n        document.getElementById(\"dvButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        document.getElementById(\"dvButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n    if (zparams.znom.length == 0) {\n        document.getElementById(\"nomButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        document.getElementById(\"nomButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n\n    borderState();\n}\n\nfunction reset() {\n    location.reload();\n}\n\n// programmatically deselecting every selected variable...\nfunction erase() {\n    leftpanelMedium();\n    rightpanelMedium();\n    document.getElementById(\"legend\").setAttribute(\"style\", \"display:none\");\n\n    tabLeft('tab1');\n\n    jQuery.fn.d3Click = function () {\n        this.children().each(function (i, e) {\n            var mycol = d3.rgb(this.style.backgroundColor);\n            if (mycol.toString() === varColor.toString()) {\n                return;\n            }\n            var evt = document.createEvent(\"MouseEvents\");\n            evt.initMouseEvent(\"click\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\n            e.dispatchEvent(evt);\n        });\n    };\n    $(\"#tab1\").d3Click();\n}\n\nfunction deselect(d) {\n    console.log(d);\n}\n\n// http://www.tutorials2learn.com/tutorials/scripts/javascript/xml-parser-javascript.html\nfunction loadXMLDoc(XMLname) {\n    var xmlDoc;\n    if (window.XMLHttpRequest) {\n        xmlDoc = new window.XMLHttpRequest();\n        xmlDoc.open(\"GET\", XMLname, false);\n        xmlDoc.send(\"\");\n        return xmlDoc.responseXML;\n    }\n    // IE 5 and IE 6\n    else if (ActiveXObject(\"Microsoft.XMLDOM\")) {\n            xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n            xmlDoc.async = false;\n            xmlDoc.load(XMLname);\n            return xmlDoc;\n        }\n    alert(\"Error loading document!\");\n    return null;\n}\n\nfunction tabLeft(tab) {\n\n    if (tab != \"tab3\") {\n        lefttab = tab;\n    }\n    var tabi = tab.substring(3);\n\n    document.getElementById('tab1').style.display = 'none';\n    document.getElementById('tab2').style.display = 'none';\n    document.getElementById('tab3').style.display = 'none';\n\n    if (tab === \"tab1\") {\n        summaryHold = false;\n        document.getElementById('btnSubset').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnVariables').setAttribute(\"class\", \"btn active\");\n        document.getElementById(\"btnSelect\").style.display = 'none';\n\n        d3.select(\"#leftpanel\").attr(\"class\", \"sidepanel container clearfix\");\n    } else if (tab === \"tab2\") {\n        summaryHold = false;\n        document.getElementById('btnVariables').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnSubset').setAttribute(\"class\", \"btn active\");\n\n        d3.select(\"#leftpanel\").attr(\"class\", function (d) {\n            if (this.getAttribute(\"class\") === \"sidepanel container clearfix expandpanel\") {\n                document.getElementById(\"btnSelect\").style.display = 'none';\n                return \"sidepanel container clearfix\";\n            } else {\n                document.getElementById(\"btnSelect\").style.display = 'block';\n                return \"sidepanel container clearfix expandpanel\";\n            }\n        });\n    } else {\n        document.getElementById('btnSubset').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnVariables').setAttribute(\"class\", \"btn btn-default\");\n\n        d3.select(\"#leftpanel\").attr(\"class\", \"sidepanel container clearfix\");\n    }\n\n    document.getElementById(tab).style.display = 'block';\n}\n\nfunction tabRight(tabid) {\n\n    document.getElementById('models').style.display = 'none';\n    document.getElementById('setx').style.display = 'none';\n    document.getElementById('results').style.display = 'none';\n\n    if (tabid == \"btnModels\") {\n        document.getElementById('btnSetx').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnResults').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnModels').setAttribute(\"class\", \"btn active\");\n        document.getElementById('models').style.display = 'block';\n\n        d3.select(\"#rightpanel\").attr(\"class\", \"sidepanel container clearfix\");\n    } else if (tabid == \"btnSetx\") {\n        document.getElementById('btnModels').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnResults').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnSetx').setAttribute(\"class\", \"btn active\");\n        document.getElementById('setx').style.display = 'block';\n\n        if (righttab == \"btnSetx\" | d3.select(\"#rightpanel\").attr(\"class\") == \"sidepanel container clearfix\") {\n            toggleR();\n        };\n    } else if (tabid == \"btnResults\") {\n        document.getElementById('btnModels').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnSetx').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnResults').setAttribute(\"class\", \"btn active\");\n        document.getElementById('results').style.display = 'block';\n\n        if (estimated === false) {\n            d3.select(\"#rightpanel\").attr(\"class\", \"sidepanel container clearfix\");\n        } else if (righttab == \"btnResults\" | d3.select(\"#rightpanel\").attr(\"class\") == \"sidepanel container clearfix\") {\n            toggleR();\n        };\n    }\n\n    righttab = tabid; // a global that may be of use\n\n    function toggleR() {\n        d3.select(\"#rightpanel\").attr(\"class\", function (d) {\n            if (this.getAttribute(\"class\") === \"sidepanel container clearfix expandpanel\") {\n                return \"sidepanel container clearfix\";\n            } else {\n                return \"sidepanel container clearfix expandpanel\";\n            }\n        });\n    }\n}\n\nfunction varSummary(d) {\n\n    var rint = d3.format(\"r\");\n\n    var summarydata = [],\n        tmpDataset = [],\n        t1 = [\"Mean:\", \"Median:\", \"Most Freq:\", \"Occurrences:\", \"Median Freq:\", \"Occurrences:\", \"Least Freq:\", \"Occurrences:\", \"Stand.Dev:\", \"Minimum:\", \"Maximum:\", \"Invalid:\", \"Valid:\", \"Uniques:\", \"Herfindahl:\"],\n        t2 = [(+d.mean).toPrecision(4).toString(), (+d.median).toPrecision(4).toString(), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), (+d.sd).toPrecision(4).toString(), (+d.min).toPrecision(4).toString(), (+d.max).toPrecision(4).toString(), rint(d.invalid), rint(d.valid), rint(d.uniques), (+d.herfindahl).toPrecision(4).toString()],\n        i,\n        j;\n    if (priv) {\n        if (d.meanCI) {\n            t1 = [\"Mean:\", \"Median:\", \"Most Freq:\", \"Occurrences:\", \"Median Freq:\", \"Occurrences:\", \"Least Freq:\", \"Occurrences:\", \"Stand.Dev:\", \"Minimum:\", \"Maximum:\", \"Invalid:\", \"Valid:\", \"Uniques:\", \"Herfindahl:\"], t2 = [(+d.mean).toPrecision(2).toString() + \" (\" + (+d.meanCI.lowerBound).toPrecision(2).toString() + \" - \" + (+d.meanCI.upperBound).toPrecision(2).toString() + \")\", (+d.median).toPrecision(4).toString(), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), (+d.sd).toPrecision(4).toString(), (+d.min).toPrecision(4).toString(), (+d.max).toPrecision(4).toString(), rint(d.invalid), rint(d.valid), rint(d.uniques), (+d.herfindahl).toPrecision(4).toString()], i, j;\n        }\n    }\n\n    for (i = 0; i < t1.length; i++) {\n        if (t2[i].indexOf(\"NaN\") > -1 | t2[i] == \"NA\" | t2[i] == \"\") continue;\n        tmpDataset = [];\n        tmpDataset.push(t1[i]);\n        tmpDataset.push(t2[i]);\n        summarydata.push(tmpDataset);\n    };\n\n    //  console.log(summarydata);\n    d3.select(\"#tab3\") //tab when you mouseover a pebble\n    .select(\"p\").html(\"<center><b>\" + d.name + \"</b><br><i>\" + d.labl + \"</i></center>\").append(\"table\").selectAll(\"tr\").data(summarydata).enter().append(\"tr\").selectAll(\"td\").data(function (d) {\n        return d;\n    }).enter().append(\"td\").text(function (d) {\n        return d;\n    }).on(\"mouseover\", function () {\n        d3.select(this).style(\"background-color\", \"aliceblue\");\n    }) // for no discernable reason\n    .on(\"mouseout\", function () {\n        d3.select(this).style(\"background-color\", \"#F9F9F9\");\n    }); //(but maybe we'll think of one)\n    //    .style(\"font-size\", \"12px\");\n\n\n    var plotsvg = d3.select(\"#tab3\").selectAll(\"svg\").remove();\n\n    if (typeof d.plottype === \"undefined\") {\n        // .properties is undefined for some vars\n        return;\n    } else if (d.plottype === \"continuous\") {\n        density(d, div = \"varSummary\", priv);\n    } else if (d.plottype === \"bar\") {\n        bars(d, div = \"varSummary\", priv);\n    } else {\n        var plotsvg = d3.select(\"#tab3\") // no graph to draw, but still need to remove previous graph\n        .selectAll(\"svg\").remove();\n    };\n}\n\nfunction populatePopover() {\n    d3.select(\"#tab1\").selectAll(\"p\").attr(\"data-content\", function (d) {\n        var onNode = findNodeIndex(d);\n        return popoverContent(allNodes[onNode]);\n    });\n}\n\nfunction popoverContent(d) {\n\n    var rint = d3.format(\"r\");\n\n    var outtext = \"\";\n\n    if (d.labl != \"\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Label</label><div class='col-sm-6'><p class='form-control-static'><i>\" + d.labl + \"</i></p></div></div>\";\n    }\n\n    if (d.mean != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Mean</label><div class='col-sm-6'><p class='form-control-static'>\";\n        if (priv && d.meanCI) {\n            outtext += (+d.mean).toPrecision(2).toString() + \" (\" + (+d.meanCI.lowerBound).toPrecision(2).toString() + \" - \" + (+d.meanCI.upperBound).toPrecision(2).toString() + \")\";\n        } else {\n            outtext += (+d.mean).toPrecision(4).toString();\n        }\n        outtext += \"</p></div></div>\";\n    }\n\n    if (d.median != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Median</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.median).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n\n    if (d.mode != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Most Freq</label><div class='col-sm-6'><p class='form-control-static'>\" + d.mode + \"</p></div></div>\";\n    }\n\n    if (d.freqmode != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Occurrences</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.freqmode) + \"</p></div></div>\";\n    }\n\n    if (d.mid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Median Freq</label><div class='col-sm-6'><p class='form-control-static'>\" + d.mid + \"</p></div></div>\";\n    }\n\n    if (d.freqmid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Occurrences</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.freqmid) + \"</p></div></div>\";\n    }\n    if (d.fewest != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Least Freq</label><div class='col-sm-6'><p class='form-control-static'>\" + d.fewest + \"</p></div></div>\";\n    }\n\n    if (d.freqfewest != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Occurrences</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.freqfewest) + \"</p></div></div>\";\n    }\n\n    if (d.sd != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Stand Dev</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.sd).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n\n    if (d.max != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Maximum</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.max).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n\n    if (d.min != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Minimum</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.min).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n    if (d.invalid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Invalid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.invalid) + \"</p></div></div>\";\n    }\n    if (d.valid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Valid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.valid) + \"</p></div></div>\";\n    }\n\n    if (d.uniques != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Uniques</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.uniques) + \"</p></div></div>\";\n    }\n    if (d.herfindahl != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Herfindahl</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.herfindahl).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n\n    return outtext;\n}\n\nfunction popupX(d) {\n\n    var tsf = d3.format(\".4r\");\n    var rint = d3.format(\"r\");\n\n    //Create the tooltip label\n    d3.select(\"#tooltip\").style(\"left\", tempX + \"px\").style(\"top\", tempY + \"px\").select(\"#tooltiptext\").html(\"<div class='form-group'><label class='col-sm-4 control-label'>Mean</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.mean) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Median</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.median) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Mode</label><div class='col-sm-6'><p class='form-control-static'>\" + d.mode + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Stand Dev</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.sd) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Maximum</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.max) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Minimum</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.min) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Valid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.valid) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Invalid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.invalid) + \"</p></div></div>\");\n}\n\nfunction panelPlots() {\n    // build arrays from nodes in main\n    var varArray = [];\n    var idArray = [];\n\n    for (var j = 0; j < nodes.length; j++) {\n        varArray.push(nodes[j].name.replace(/\\(|\\)/g, \"\"));\n        idArray.push(nodes[j].id);\n    }\n\n    //remove all plots, could be smarter here\n    d3.select(\"#setx\").selectAll(\"svg\").remove();\n    d3.select(\"#tab2\").selectAll(\"svg\").remove();\n\n    for (var i = 0; i < varArray.length; i++) {\n        allNodes[idArray[i]].setxplot = false;\n        allNodes[idArray[i]].subsetplot = false;\n        if (allNodes[idArray[i]].plottype === \"continuous\" & allNodes[idArray[i]].setxplot == false) {\n            allNodes[idArray[i]].setxplot = true;\n            console.log(priv);\n            density(allNodes[idArray[i]], div = \"setx\", priv);\n            allNodes[idArray[i]].subsetplot = true;\n            density(allNodes[idArray[i]], div = \"subset\", priv);\n        } else if (allNodes[idArray[i]].plottype === \"bar\" & allNodes[idArray[i]].setxplot == false) {\n            allNodes[idArray[i]].setxplot = true;\n            bars(allNodes[idArray[i]], div = \"setx\", priv);\n            allNodes[idArray[i]].subsetplot = true;\n            barsSubset(allNodes[idArray[i]]);\n        }\n    }\n\n    d3.select(\"#setx\").selectAll(\"svg\").each(function () {\n        d3.select(this);\n        var regstr = /(.+)_setx_(\\d+)/;\n        var myname = regstr.exec(this.id);\n        var nodeid = myname[2];\n        myname = myname[1];\n        var j = varArray.indexOf(myname);\n\n        if (j == -1) {\n            allNodes[nodeid].setxplot = false;\n            var temp = \"#\".concat(myname, \"_setx_\", nodeid);\n            d3.select(temp).remove();\n\n            allNodes[nodeid].subsetplot = false;\n            var temp = \"#\".concat(myname, \"_tab2_\", nodeid);\n            d3.select(temp).remove();\n        }\n    });\n}\n\n// easy functions to collapse panels to base\nfunction rightpanelMedium() {\n    d3.select(\"#rightpanel\").attr(\"class\", \"sidepanel container clearfix\");\n}\n\nfunction leftpanelMedium() {\n    d3.select(\"#leftpanel\").attr(\"class\", \"sidepanel container clearfix\");\n}\n\n// function to convert color codes\nfunction hexToRgba(hex) {\n    var h = hex.replace('#', '');\n\n    var bigint = parseInt(h, 16);\n    var r = bigint >> 16 & 255;\n    var g = bigint >> 8 & 255;\n    var b = bigint & 255;\n    var a = '0.5';\n\n    return \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + a + \")\";\n}\n\n// function takes a node and a color and updates zparams\nfunction setColors(n, c) {\n\n    if (n.strokeWidth == '1') {\n        // adding time, cs, dv, nom to a node with no stroke\n        n.strokeWidth = '4';\n        n.strokeColor = c;\n        n.nodeCol = taggedColor;\n        if (dvColor == c) {\n            // check if array, if not, make it an array\n            //  console.log(Object.prototype.toString.call(zparams.zdv));\n            zparams.zdv = Object.prototype.toString.call(zparams.zdv) == \"[object Array]\" ? zparams.zdv : [];\n            zparams.zdv.push(n.name);\n        } else if (csColor == c) {\n            zparams.zcross = Object.prototype.toString.call(zparams.zcross) == \"[object Array]\" ? zparams.zcross : [];\n            zparams.zcross.push(n.name);\n        } else if (timeColor == c) {\n            zparams.ztime = Object.prototype.toString.call(zparams.ztime) == \"[object Array]\" ? zparams.ztime : [];\n            zparams.ztime.push(n.name);\n        } else if (nomColor == c) {\n            zparams.znom = Object.prototype.toString.call(zparams.znom) == \"[object Array]\" ? zparams.znom : [];\n            zparams.znom.push(n.name);\n            allNodes[findNodeIndex(n.name)].nature = \"nominal\";\n            transform(n.name, t = null, typeTransform = true);\n        }\n\n        d3.select(\"#tab1\").select(\"p#\".concat(n.name)).style('background-color', hexToRgba(c));\n    } else if (n.strokeWidth == '4') {\n        if (c == n.strokeColor) {\n            // deselecting time, cs, dv, nom\n            n.strokeWidth = '1';\n            n.strokeColor = selVarColor;\n            n.nodeCol = colors(n.id);\n            d3.select(\"#tab1\").select(\"p#\".concat(n.name)).style('background-color', hexToRgba(selVarColor));\n\n            if (dvColor == c) {\n                var dvIndex = zparams.zdv.indexOf(n.name);\n                if (dvIndex > -1) {\n                    zparams.zdv.splice(dvIndex, 1);\n                }\n            } else if (csColor == c) {\n                var csIndex = zparams.zcross.indexOf(n.name);\n                if (csIndex > -1) {\n                    zparams.zcross.splice(csIndex, 1);\n                }\n            } else if (timeColor == c) {\n                var timeIndex = zparams.ztime.indexOf(n.name);\n                if (timeIndex > -1) {\n                    zparams.ztime.splice(timeIndex, 1);\n                }\n            } else if (nomColor == c) {\n                var nomIndex = zparams.znom.indexOf(n.name);\n                if (nomIndex > -1) {\n                    zparams.znom.splice(nomIndex, 1);\n                    allNodes[findNodeIndex(n.name)].nature = allNodes[findNodeIndex(n.name)].defaultNature;\n                    transform(n.name, t = null, typeTransform = true);\n                }\n            }\n        } else {\n            // deselecting time, cs, dv, nom AND changing it to time, cs, dv, nom\n            if (dvColor == n.strokeColor) {\n                var dvIndex = zparams.zdv.indexOf(n.name);\n                if (dvIndex > -1) {\n                    zparams.zdv.splice(dvIndex, 1);\n                }\n            } else if (csColor == n.strokeColor) {\n                var csIndex = zparams.zcross.indexOf(n.name);\n                if (csIndex > -1) {\n                    zparams.zcross.splice(csIndex, 1);\n                }\n            } else if (timeColor == n.strokeColor) {\n                var timeIndex = zparams.ztime.indexOf(n.name);\n                if (timeIndex > -1) {\n                    zparams.ztime.splice(timeIndex, 1);\n                }\n            } else if (nomColor == n.strokeColor) {\n                var nomIndex = zparams.znom.indexOf(n.name);\n                if (nomIndex > -1) {\n                    zparams.znom.splice(nomIndex, 1);\n                    allNodes[findNodeIndex(n.name)].nature = allNodes[findNodeIndex(n.name)].defaultNature;\n                    transform(n.name, t = null, typeTransform = true);\n                }\n            }\n            n.strokeColor = c;\n            d3.select(\"#tab1\").select(\"p#\".concat(n.name)).style('background-color', hexToRgba(c));\n\n            if (dvColor == c) {\n                zparams.zdv.push(n.name);\n            } else if (csColor == c) {\n                zparams.zcross.push(n.name);\n            } else if (timeColor == c) {\n                zparams.ztime.push(n.name);\n            } else if (nomColor == c) {\n                zparams.znom.push(n.name);\n                allNodes[findNodeIndex(n.name)].nature = \"nominal\";\n                transform(n.name, t = null, typeTransform = true);\n            }\n        }\n    }\n}\n\nfunction borderState() {\n    if (zparams.zdv.length > 0) {\n        $('#dvButton .rectColor svg circle').attr('stroke', dvColor);\n    } else {\n        $('#dvButton').css('border-color', '#ccc');\n    }\n    if (zparams.zcross.length > 0) {\n        $('#csButton .rectColor svg circle').attr('stroke', csColor);\n    } else {\n        $('#csButton').css('border-color', '#ccc');\n    }\n    if (zparams.ztime.length > 0) {\n        $('#timeButton .rectColor svg circle').attr('stroke', timeColor);\n    } else {\n        $('#timeButton').css('border-color', '#ccc');\n    }\n    if (zparams.znom.length > 0) {\n        $('#nomButton .rectColor svg circle').attr('stroke', nomColor);\n    } else {\n        $('#nomButton').css('border-color', '#ccc');\n    }\n}\n\n// small appearance resets, but perhaps this will become a hard reset back to all original allNode values?\nfunction nodeReset(n) {\n    n.strokeColor = selVarColor;\n    n.strokeWidth = \"1\";\n    n.nodeCol = n.baseCol;\n}\n\nfunction subsetSelect(btn) {\n    if (dataurl) {\n        zparams.zdataurl = dataurl;\n    }\n\n    if (production && zparams.zsessionid == \"\") {\n        alert(\"Warning: Data download is not complete. Try again soon.\");\n        return;\n    }\n\n    zparams.zvars = [];\n    zparams.zplot = [];\n\n    var subsetEmpty = true;\n\n    // is this the same as zPop()?\n    for (var j = 0; j < nodes.length; j++) {\n        //populate zvars and zsubset arrays\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n        if (zparams.zsubset[j].length > 0) {\n            if (zparams.zsubset[j][0] != \"\") {\n                zparams.zsubset[j][0] = Number(zparams.zsubset[j][0]);\n            }\n            if (zparams.zsubset[j][1] != \"\") {\n                zparams.zsubset[j][1] = Number(zparams.zsubset[j][1]);\n            }\n        }\n        zparams.zplot.push(allNodes[temp].plottype);\n        if (zparams.zsubset[j][1] != \"\") {\n            subsetEmpty = false;\n        } //only need to check one\n    }\n\n    if (subsetEmpty == true) {\n        alert(\"Warning: No new subset selected.\");\n        return;\n    }\n\n    var outtypes = [];\n    for (var j = 0; j < allNodes.length; j++) {\n        outtypes.push({\n            varnamesTypes: allNodes[j].name,\n            nature: allNodes[j].nature,\n            numchar: allNodes[j].numchar,\n            binary: allNodes[j].binary,\n            interval: allNodes[j].interval\n        });\n    }\n\n    var subsetstuff = {\n        zdataurl: zparams.zdataurl,\n        zvars: zparams.zvars,\n        zsubset: zparams.zsubset,\n        zsessionid: zparams.zsessionid,\n        zplot: zparams.zplot,\n        callHistory: callHistory,\n        typeStuff: outtypes\n    };\n\n    var jsonout = JSON.stringify(subsetstuff);\n    //var base = rappURL+\"subsetapp?solaJSON=\"\n    urlcall = rappURL + \"subsetapp\"; //base.concat(jsonout);\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    function subsetSelectSuccess(btn, json) {\n        selectLadda.stop(); // stop motion\n        $(\"#btnVariables\").trigger(\"click\"); // programmatic clicks\n        $(\"#btnModels\").trigger(\"click\");\n\n        var grayOuts = [];\n\n        var rCall = [];\n        rCall[0] = json.call;\n\n        // store contents of the pre-subset space\n        zPop();\n        var myNodes = jQuery.extend(true, [], allNodes);\n        var myParams = jQuery.extend(true, {}, zparams);\n        var myTrans = jQuery.extend(true, [], trans);\n        var myForce = jQuery.extend(true, [], forcetoggle);\n        var myPreprocess = jQuery.extend(true, {}, preprocess);\n        var myLog = jQuery.extend(true, [], logArray);\n        var myHistory = jQuery.extend(true, [], callHistory);\n\n        spaces[myspace] = {\n            \"allNodes\": myNodes,\n            \"zparams\": myParams,\n            \"trans\": myTrans,\n            \"force\": myForce,\n            \"preprocess\": myPreprocess,\n            \"logArray\": myLog,\n            \"callHistory\": myHistory\n        };\n\n        // remove pre-subset svg\n        var selectMe = \"#m\".concat(myspace);\n        d3.select(selectMe).attr('class', 'item');\n        selectMe = \"#whitespace\".concat(myspace);\n        d3.select(selectMe).remove();\n\n        myspace = spaces.length;\n        callHistory.push({\n            func: \"subset\",\n            zvars: jQuery.extend(true, [], zparams.zvars),\n            zsubset: jQuery.extend(true, [], zparams.zsubset),\n            zplot: jQuery.extend(true, [], zparams.zplot)\n        });\n\n        // this is to be used to gray out and remove listeners for variables that have been subsetted out of the data\n        function varOut(v) {\n            // if in nodes, remove\n            // gray out in left panel\n            // make unclickable in left panel\n            for (var i = 0; i < v.length; i++) {\n                var selectMe = v[i].replace(/\\W/g, \"_\");\n                document.getElementById(selectMe).style.color = hexToRgba(grayColor);\n                selectMe = \"p#\".concat(selectMe);\n                d3.select(selectMe).on(\"click\", null);\n            }\n        }\n\n        logArray.push(\"subset: \".concat(rCall[0]));\n        showLog();\n        reWriteLog();\n\n        d3.select(\"#innercarousel\").append('div').attr('class', 'item active').attr('id', function () {\n            return \"m\".concat(myspace.toString());\n        }).append('svg').attr('id', 'whitespace');\n        svg = d3.select(\"#whitespace\");\n\n        d3.json(json.url, function (error, json) {\n            if (error) return console.warn(error);\n            var jsondata = json;\n\n            for (var key in jsondata) {\n                var myIndex = findNodeIndex(key);\n\n                allNodes[myIndex].plotx = undefined;\n                allNodes[myIndex].ploty = undefined;\n                allNodes[myIndex].plotvalues = undefined;\n                allNodes[myIndex].plottype = \"\";\n\n                jQuery.extend(true, allNodes[myIndex], jsondata[key]);\n\n                allNodes[myIndex].subsetplot = false;\n                allNodes[myIndex].subsetrange = [\"\", \"\"];\n                allNodes[myIndex].setxplot = false;\n                allNodes[myIndex].setxvals = [\"\", \"\"];\n\n                if (allNodes[myIndex].valid == 0) {\n                    grayOuts.push(allNodes[myIndex].name);\n                    allNodes[myIndex].grayout = true;\n                }\n            }\n\n            rePlot();\n            populatePopover();\n            layout(v = \"add\");\n        });\n\n        varOut(grayOuts);\n    }\n\n    function subsetSelectFail(btn) {\n        selectLadda.stop(); //stop motion\n    }\n\n    selectLadda.start(); //start button motion\n    makeCorsRequest(urlcall, btn, subsetSelectSuccess, subsetSelectFail, solajsonout);\n}\n\nfunction readPreprocess(url, p, v, callback) {\n    console.log(url);\n    d3.json(url, function (error, json) {\n        if (error) return console.warn(error);\n        var jsondata = json;\n\n        console.log(\"inside readPreprocess function\");\n        console.log(jsondata);\n        console.log(jsondata[\"variables\"]);\n\n        if (jsondata.dataset.priv) {\n            priv = jsondata[\"dataset\"][\"priv\"];\n        };\n\n        //copying the object\n        for (var key in jsondata[\"variables\"]) {\n            p[key] = jsondata[\"variables\"][key];\n        }\n\n        if (typeof callback === \"function\") {\n            callback();\n        }\n    });\n}\n\nfunction about() {\n    $('#about').show();\n}\n\nfunction closeabout() {\n    $('#about').hide();\n}\n\nfunction opencite() {\n    $('#cite').show();\n}\n\nfunction closecite(toggle) {\n    if (toggle == false) {\n        $('#cite').hide();\n    }\n}\n\nfunction clickcite(toggle) {\n    if (toggle == false) {\n        $('#cite').show();\n        return true;\n    } else {\n        $('#cite').hide();\n        return false;\n    }\n}\n\n// function to remove all the children svgs inside subset and setx divs\nfunction rePlot() {\n    d3.select(\"#tab2\").selectAll(\"svg\").remove();\n\n    d3.select(\"#setx\").selectAll(\"svg\").remove();\n\n    // make this smarter\n    for (var i = 0; i < allNodes.length; i++) {\n        allNodes[i].setxplot = false;\n        allNodes[i].subsetplot = false;\n    }\n}\n\nfunction showLog() {\n    if (logArray.length > 0) {\n        document.getElementById('logdiv').setAttribute(\"style\", \"display:block\");\n        d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").data(logArray).enter().append(\"p\").text(function (d) {\n            return d;\n        });\n    } else {\n        document.getElementById('logdiv').setAttribute(\"style\", \"display:none\");\n    }\n}\n\nfunction reWriteLog() {\n    d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").remove();\n    d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").data(logArray).enter().append(\"p\").text(function (d) {\n        return d;\n    });\n}\n\n// acts as if the user clicked in whitespace. useful when restart() is outside of scope\nfunction fakeClick() {\n    var myws = \"#whitespace\".concat(myspace);\n    // d3 and programmatic events don't mesh well, here's a SO workaround that looks good but uses jquery...\n    jQuery.fn.d3Click = function () {\n        this.each(function (i, e) {\n            var evt = document.createEvent(\"MouseEvents\");\n            evt.initMouseEvent(\"mousedown\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\n            e.dispatchEvent(evt);\n        });\n    };\n    $(myws).d3Click();\n\n    d3.select(myws).classed('active', false); // remove active class\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9hcHBfZGRpLmpzPzdhNjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8vLy8vLy8vL1xuLy8gR2xvYmFsc1xuXG4vLyBob3N0bmFtZSBkZWZhdWx0IC0gdGhlIGFwcCB3aWxsIHVzZSBpdCB0byBvYnRhaW4gdGhlIHZhcmlhYmxlIG1ldGFkYXRhXG4vLyAoZGRpKSBhbmQgcHJlLXByb2Nlc3NlZCBkYXRhIGluZm8gaWYgdGhlIGZpbGUgaWQgaXMgc3VwcGxpZWQgYXMgYW4gXG4vLyBhcmd1bWVudCAoZm9yIGV4LiwgZ3VpLmh0bWw/ZGZJZD0xNyksIGJ1dCBob3N0bmFtZSBpc24ndC4gXG4vLyBFZGl0IGl0IHRvIHN1aXQgeW91ciBpbnN0YWxsYXRpb24uIFxuLy8gKE5PVEUgdGhhdCBpZiB0aGUgZmlsZSBpZCBpc24ndCBzdXBwbGllZCwgdGhlIGFwcCB3aWxsIGRlZmF1bHQgdG8gdGhlIFxuLy8gbG9jYWwgZmlsZXMgc3BlY2lmaWVkIGJlbG93ISlcbi8vIE5FVzogaXQgaXMgYWxzbyBwb3NzaWJsZSBub3cgdG8gc3VwcGx5IGNvbXBsZXRlIHVybHMgZm9yIHRoZSBkZGkgYW5kIFxuLy8gdGhlIHRhYi1kZWxpbWl0ZWQgZGF0YSBmaWxlOyB0aGUgcGFyYW1ldGVycyBhcmUgZGRpdXJsIGFuZCBkYXRhdXJsLiBcbi8vIFRoZXNlIG5ldyBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbC4gSWYgdGhleSBhcmUgbm90IHN1cHBsaWVkLCB0aGUgYXBwXG4vLyB3aWxsIGdvIHRoZSBvbGQgcm91dGUgLSB3aWxsIHRyeSB0byBjb29rIHN0YW5kYXJkIGRhdGF2ZXJzZSB1cmxzIFxuLy8gZm9yIGJvdGggdGhlIGRhdGEgYW5kIG1ldGFkYXRhLCBpZiB0aGUgZmlsZSBpZCBpcyBzdXBwbGllZDsgb3IgdGhlIFxuLy8gbG9jYWwgZmlsZXMgaWYgbm90aGluZyBpcyBzdXBwbGllZC4gXG4vLyAtLSBMLkEuXG5cbnZhciB2YXJDb2xvciA9ICcjZjBmOGZmJzsgLy9kMy5yZ2IoXCJhbGljZWJsdWVcIik7XG52YXIgc2VsVmFyQ29sb3IgPSAnI2ZhODA3Mic7IC8vZDMucmdiKFwic2FsbW9uXCIpO1xudmFyIGR2Q29sb3IgPSAnIzI4YTRjOSc7XG52YXIgbm9tQ29sb3IgPSAnI2ZmNjYwMCc7XG5cbi8vIHRyYW5zZm9ybWF0aW9uIHRvb2xiYXIgb3B0aW9uc1xudmFyIHRyYW5zZm9ybUxpc3QgPSBbXCJsb2coZClcIiwgXCJleHAoZClcIiwgXCJkXjJcIiwgXCJzcXJ0KGQpXCIsIFwiaW50ZXJhY3QoZCxlKVwiXTtcblxuLy8gUmFkaXVzIG9mIGNpcmNsZVxudmFyIGFsbFIgPSA0MDtcblxuLy8gc3BhY2UgaW5kZXhcbnZhciBteXNwYWNlID0gMDtcblxudmFyIGZvcmNldG9nZ2xlID0gW1widHJ1ZVwiXTtcbnZhciBwcml2ID0gZmFsc2U7XG5cbnZhciB2YWx1ZUtleSA9IFtdO1xudmFyIGFsbE5vZGVzID0gW107XG52YXIgbm9kZXMgPSBbXTtcbnZhciBsaW5rcyA9IFtdO1xudmFyIG1vZHMgPSB7fTtcblxudmFyIHN2Zywgd2lkdGgsIGhlaWdodCwgZGl2LCBvYmo7XG52YXIgYXJjMywgYXJjNDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYWluKGZpbGVpZCwgaG9zdG5hbWUsIGRkaXVybCwgZGF0YXVybCkge1xuICAgIHZhciBwcm9kdWN0aW9uID0gZmFsc2U7XG5cbiAgICBpZiAocHJvZHVjdGlvbiAmJiBmaWxlaWQgPT0gXCJcIikge1xuICAgICAgICBhbGVydChcIkVycm9yOiBObyBmaWxlaWQgaGFzIGJlZW4gcHJvdmlkZWQuXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvcjogTm8gZmlsZWlkIGhhcyBiZWVuIHByb3ZpZGVkLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YXZlcnNldXJsID0gXCJcIjtcblxuICAgIGlmIChob3N0bmFtZSkge1xuICAgICAgICBkYXRhdmVyc2V1cmwgPSBcImh0dHBzOi8vXCIgKyBob3N0bmFtZTtcbiAgICB9IGVsc2UgaWYgKHByb2R1Y3Rpb24pIHtcbiAgICAgICAgZGF0YXZlcnNldXJsID0gXCIlUFJPRFVDVElPTl9EQVRBVkVSU0VfVVJMJVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGF2ZXJzZXVybCA9IFwiaHR0cDovL2xvY2FsaG9zdDo4MDgwXCI7XG4gICAgfVxuXG4gICAgaWYgKGZpbGVpZCAmJiAhZGF0YXVybCkge1xuICAgICAgICAvLyBmaWxlIGlkIHN1cHBsaWVkOyB3ZSBhcmUgZ29pbmcgdG8gYXNzdW1lIHRoYXQgd2UgYXJlIGRlYWxpbmcgd2l0aFxuICAgICAgICAvLyBhIGRhdGF2ZXJzZSBhbmQgY29vayBhIHN0YW5kYXJkIGRhdGF2ZXJzZSBkYXRhIGFjY2VzcyB1cmwsXG4gICAgICAgIC8vIHdpdGggdGhlIGZpbGVpZCBzdXBwbGllZCBhbmQgdGhlIGhvc3RuYW1lIHdlIGhhdmVcbiAgICAgICAgLy8gZWl0aGVyIHN1cHBsaWVkIG9yIGNvbmZpZ3VyZWQ6XG4gICAgICAgIGRhdGF1cmwgPSBkYXRhdmVyc2V1cmwgKyBcIi9hcGkvYWNjZXNzL2RhdGFmaWxlL1wiICsgZmlsZWlkO1xuICAgICAgICBkYXRhdXJsID0gZGF0YXVybCArIFwiP2tleT1cIiArIGFwaWtleTtcbiAgICAgICAgLy8gKGl0IGlzIGFsc28gcG9zc2libGUgdG8gc3VwcGx5IGRhdGF1cmwgdG8gdGhlIHNjcmlwdCBkaXJlY3RseSwgXG4gICAgICAgIC8vIGFzIGFuIGFyZ3VtZW50IC0tIEwuQS4pXG4gICAgfVxuXG4gICAgLy8gYmFzZSBVUkwgZm9yIHRoZSBSIGFwcHM6XG4gICAgaWYgKCFwcm9kdWN0aW9uKSB7XG4gICAgICAgIHZhciByYXBwVVJMID0gXCJodHRwOi8vMC4wLjAuMDo4MDAwL2N1c3RvbS9cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmFwcFVSTCA9IFwiaHR0cHM6Ly9iZXRhLmRhdGF2ZXJzZS5vcmcvY3VzdG9tL1wiOyAvL3RoaXMgd2lsbCBjaGFuZ2Ugd2hlbi9pZiB0aGUgcHJvZHVjdGlvbiBob3N0IGNoYW5nZXNcbiAgICB9XG5cbiAgICBzdmcgPSBkMy5zZWxlY3QoXCIjbWFpbi5sZWZ0IGRpdi5jYXJvdXNlbC1pbm5lclwiKS5hdHRyKCdpZCcsICdpbm5lcmNhcm91c2VsJylcbiAgICAgICAgLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCAnaXRlbSBhY3RpdmUnKS5hdHRyKCdpZCcsICdtMCcpLmFwcGVuZCgnc3ZnJykuYXR0cignaWQnLCAnd2hpdGVzcGFjZScpO1xuXG4gICAgdmFyIGxvZ0FycmF5ID0gW107XG5cbiAgICB2YXIgdGVtcFdpZHRoID0gZDMuc2VsZWN0KFwiI21haW4ubGVmdFwiKS5zdHlsZShcIndpZHRoXCIpXG4gICAgd2lkdGggPSB0ZW1wV2lkdGguc3Vic3RyaW5nKDAsICh0ZW1wV2lkdGgubGVuZ3RoIC0gMikpO1xuICAgIGhlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKSAtIDEyMDsgLy8gSGFyZCBjb2RpbmcgZm9yIGhlYWRlciBhbmQgZm9vdGVyIGFuZCBib3R0b20gbWFyZ2luLlxuXG4gICAgdmFyIGVzdGltYXRlZCA9IGZhbHNlO1xuICAgIHZhciBlc3RpbWF0ZUxhZGRhID0gTGFkZGEuY3JlYXRlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnRuRXN0aW1hdGVcIikpO1xuICAgIHZhciBzZWxlY3RMYWRkYSA9IExhZGRhLmNyZWF0ZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJ0blNlbGVjdFwiKSk7XG4gICAgdmFyIHJpZ2h0Q2xpY2tMYXN0ID0gZmFsc2U7XG5cbiAgICAvLyB0aGlzIGlzIHRoZSBpbml0aWFsIGNvbG9yIHNjYWxlIHRoYXQgaXMgdXNlZCB0byBlc3RhYmxpc2ggdGhlIGluaXRpYWwgY29sb3JzIG9mIHRoZSBub2Rlcy4gIGFsbE5vZGVzLnB1c2goKSBiZWxvdyBlc3RhYmxpc2hlcyBhIGZpZWxkIGZvciB0aGUgbWFzdGVyIG5vZGUgYXJyYXkgYWxsTm9kZXMgY2FsbGVkIFwibm9kZUNvbFwiIGFuZCBhc3NpZ25zIGEgY29sb3IgZnJvbSB0aGlzIHNjYWxlIHRvIHRoYXQgZmllbGQuICBldmVyeXRoaW5nIHRoZXJlIGFmdGVyIHNob3VsZCByZWZlciB0byB0aGUgbm9kZUNvbCBhbmQgbm90IHRoZSBjb2xvciBzY2FsZSwgdGhpcyBlbmFibGVzIHVzIHRvIHVwZGF0ZSBjb2xvcnMgYW5kIHBhc3MgdGhlIHZhcmlhYmxlIHR5cGUgdG8gUiBiYXNlZCBvbiBpdHMgY29sb3JpbmdcbiAgICB2YXIgY29sb3JzID0gZDMuc2NhbGUuY2F0ZWdvcnkyMCgpO1xuXG4gICAgdmFyIGNvbG9yVGltZSA9IGZhbHNlO1xuICAgIHZhciB0aW1lQ29sb3IgPSAnIzJkNmNhMic7XG5cbiAgICB2YXIgY29sb3JDUyA9IGZhbHNlO1xuICAgIHZhciBjc0NvbG9yID0gJyM0MTk2NDEnO1xuXG4gICAgdmFyIGRlcFZhciA9IGZhbHNlO1xuXG4gICAgdmFyIHN1YnNldGRpdiA9IGZhbHNlO1xuICAgIHZhciBzZXR4ZGl2ID0gZmFsc2U7XG5cbiAgICB2YXIgdGFnZ2VkQ29sb3IgPSAnI2Y1ZjVmNSc7IC8vZDMucmdiKFwid2hpdGVzbW9rZVwiKTtcbiAgICB2YXIgZ3JheUNvbG9yID0gJyNjMGMwYzAnO1xuXG4gICAgdmFyIGxlZnR0YWIgPSBcInRhYjFcIjsgLy9nbG9iYWwgZm9yIGN1cnJlbnQgdGFiIGluIGxlZnQgcGFuZWxcbiAgICB2YXIgcmlnaHR0YWIgPSBcImJ0bk1vZGVsc1wiOyAvLyBnbG9iYWwgZm9yIGN1cnJlbnQgdGFiIGluIHJpZ2h0IHBhbmVsXG5cbiAgICB2YXIgenBhcmFtcyA9IHtcbiAgICAgICAgemRhdGE6IFtdLFxuICAgICAgICB6ZWRnZXM6IFtdLFxuICAgICAgICB6dGltZTogW10sXG4gICAgICAgIHpub206IFtdLFxuICAgICAgICB6Y3Jvc3M6IFtdLFxuICAgICAgICB6bW9kZWw6IFwiXCIsXG4gICAgICAgIHp2YXJzOiBbXSxcbiAgICAgICAgemR2OiBbXSxcbiAgICAgICAgemRhdGF1cmw6IFwiXCIsXG4gICAgICAgIHpzdWJzZXQ6IFtdLFxuICAgICAgICB6c2V0eDogW10sXG4gICAgICAgIHptb2RlbGNvdW50OiAwLFxuICAgICAgICB6cGxvdDogW10sXG4gICAgICAgIHpzZXNzaW9uaWQ6IFwiXCIsXG4gICAgICAgIHpkYXRhY2l0ZTogXCJcIlxuICAgIH07XG5cblxuICAgIC8vV2lkdGggYW5kIGhlaWdodCBmb3IgaGlzdGdyYW1zXG4gICAgdmFyIGJhcndpZHRoID0gMS4zICogYWxsUjtcbiAgICB2YXIgYmFyaGVpZ2h0ID0gMC41ICogYWxsUjtcbiAgICB2YXIgYmFyUGFkZGluZyA9IDAuMzU7XG4gICAgdmFyIGJhcm51bWJlciA9IDc7XG5cblxuICAgIHZhciBhcmMwID0gZDMuc3ZnLmFyYygpXG4gICAgICAgIC5pbm5lclJhZGl1cyhhbGxSICsgNSlcbiAgICAgICAgLm91dGVyUmFkaXVzKGFsbFIgKyAyMClcbiAgICAgICAgLnN0YXJ0QW5nbGUoMClcbiAgICAgICAgLmVuZEFuZ2xlKDMuMik7XG5cbiAgICB2YXIgYXJjMSA9IGQzLnN2Zy5hcmMoKVxuICAgICAgICAuaW5uZXJSYWRpdXMoYWxsUiArIDUpXG4gICAgICAgIC5vdXRlclJhZGl1cyhhbGxSICsgMjApXG4gICAgICAgIC5zdGFydEFuZ2xlKDApXG4gICAgICAgIC5lbmRBbmdsZSgxKTtcblxuICAgIHZhciBhcmMyID0gZDMuc3ZnLmFyYygpXG4gICAgICAgIC5pbm5lclJhZGl1cyhhbGxSICsgNSlcbiAgICAgICAgLm91dGVyUmFkaXVzKGFsbFIgKyAyMClcbiAgICAgICAgLnN0YXJ0QW5nbGUoMS4xKVxuICAgICAgICAuZW5kQW5nbGUoMi4yKTtcblxuICAgIGFyYzMgPSBkMy5zdmcuYXJjKClcbiAgICAgICAgLmlubmVyUmFkaXVzKGFsbFIgKyA1KVxuICAgICAgICAub3V0ZXJSYWRpdXMoYWxsUiArIDIwKVxuICAgICAgICAuc3RhcnRBbmdsZSgyLjMpXG4gICAgICAgIC5lbmRBbmdsZSgzLjMpO1xuXG4gICAgdmFyIGFyYzQgPSBkMy5zdmcuYXJjKClcbiAgICAgICAgLmlubmVyUmFkaXVzKGFsbFIgKyA1KVxuICAgICAgICAub3V0ZXJSYWRpdXMoYWxsUiArIDIwKVxuICAgICAgICAuc3RhcnRBbmdsZSg0LjMpXG4gICAgICAgIC5lbmRBbmdsZSg1LjMpO1xuXG4gICAgLy8gRnJvbSAuY3N2XG4gICAgdmFyIGRhdGFzZXQyID0gW107XG4gICAgdmFyIGxhYmxBcnJheSA9IFtdO1xuICAgIHZhciBob2xkID0gW107XG4gICAgdmFyIGFsbFJlc3VsdHMgPSBbXTtcbiAgICB2YXIgc3Vic2V0Tm9kZXMgPSBbXTtcbiAgICB2YXIgdHJhbnNmb3JtVmFyID0gXCJcIjtcbiAgICB2YXIgc3VtbWFyeUhvbGQgPSBmYWxzZTtcbiAgICB2YXIgc2VsSW50ZXJhY3QgPSBmYWxzZTtcbiAgICB2YXIgbW9kZWxDb3VudCA9IDA7XG4gICAgdmFyIGNhbGxIaXN0b3J5ID0gW107IC8vIHVuaXF1ZSB0byB0aGUgc3BhY2UuIHNhdmVzIHRyYW5zZm9ybSBhbmQgc3Vic2V0IGNhbGxzLlxuICAgIHZhciBjaXRldG9nZ2xlID0gZmFsc2U7XG5cbiAgICAvLyBhcnJ5IG9mIG9iamVjdHMgY29udGFpbmluZyBhbGxOb2RlLCB6cGFyYW1zLCB0cmFuc2Zvcm0gdmFyc1xuICAgIHZhciBzcGFjZXMgPSBbXTtcbiAgICB2YXIgdHJhbnMgPSBbXTsgLy92YXIgbGlzdCBmb3IgZWFjaCBzcGFjZSBjb250YWluIHZhcmlhYmxlcyBpbiBvcmlnaW5hbCBkYXRhIHBsdXMgdHJhbnMgaW4gdGhhdCBzcGFjZVxuXG4gICAgLy8gZW5kIG9mIChtb3N0KSBnbG9iYWwgZGVjbGFyYXRpb25zIChtaW51cyBmdW5jdGlvbnMpXG5cbiAgICAvLyBjb2xsYXBzYWJsZSB1c2VyIGxvZ1xuICAgICQoJyNjb2xsYXBzZUxvZycpLm9uKCdzaG93bi5icy5jb2xsYXBzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgLmRhdGEobG9nQXJyYXkpXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAvLyQoXCIjbG9naWNvblwiKS5yZW1vdmVDbGFzcyhcImdseXBoaWNvbi1jaGV2cm9uLXVwXCIpLmFkZENsYXNzKFwiZ2x5cGhpY29uLWNoZXZyb24tZG93blwiKTtcbiAgICB9KTtcblxuICAgICQoJyNjb2xsYXBzZUxvZycpLm9uKCdoaWRkZW4uYnMuY29sbGFwc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI2NvbGxhcHNlTG9nIGRpdi5wYW5lbC1ib2R5XCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgLy8kKFwiI2xvZ2ljb25cIikucmVtb3ZlQ2xhc3MoXCJnbHlwaGljb24tY2hldnJvbi1kb3duXCIpLmFkZENsYXNzKFwiZ2x5cGhpY29uLWNoZXZyb24tdXBcIik7XG4gICAgfSk7XG5cblxuICAgIC8vIHRleHQgZm9yIHRoZSBhYm91dCBib3hcbiAgICAvLyBub3RlIHRoYXQgLnRleHRDb250ZW50IGlzIHRoZSBuZXcgd2F5IHRvIHdyaXRlIHRleHQgdG8gYSBkaXZcbiAgICAkKCcjYWJvdXQgZGl2LnBhbmVsLWJvZHknKS50ZXh0KCdUd29SYXZlbnMgdjAuMSBcIkRhbGxhc1wiIC0tIFRoZSBOb3JzZSBnb2QgT2RpbiBoYWQgdHdvIHRhbGtpbmcgcmF2ZW5zIGFzIGFkdmlzb3JzLCB3aG8gd291bGQgZmx5IG91dCBpbnRvIHRoZSB3b3JsZCBhbmQgcmVwb3J0IGJhY2sgYWxsIHRoZXkgb2JzZXJ2ZWQuICBJbiB0aGUgTm9yc2UsIHRoZWlyIG5hbWVzIHdlcmUgXCJUaG91Z2h0XCIgYW5kIFwiTWVtb3J5XCIuICBJbiBvdXIgY29taW5nIHJlbGVhc2UsIG91ciB0aG91Z2h0LXJhdmVuIGF1dG9tYXRpY2FsbHkgYWR2aXNlcyBvbiBzdGF0aXN0aWNhbCBtb2RlbCBzZWxlY3Rpb24sIHdoaWxlIG91ciBtZW1vcnktcmF2ZW4gYWNjdW11bGF0ZXMgcHJldmlvdXMgc3RhdGlzdGljYWwgbW9kZWxzIGZyb20gRGF0YXZlcnNlLCB0byBwcm92aWRlIGN1bW11bGF0aXZlIGd1aWRhbmNlIGFuZCBtZXRhLWFuYWx5c2lzLicpOyAvL1RoaXMgaXMgdGhlIGZpcnN0IHB1YmxpYyByZWxlYXNlIG9mIGEgbmV3LCBpbnRlcmFjdGl2ZSBXZWIgYXBwbGljYXRpb24gdG8gZXhwbG9yZSBkYXRhLCB2aWV3IGRlc2NyaXB0aXZlIHN0YXRpc3RpY3MsIGFuZCBlc3RpbWF0ZSBzdGF0aXN0aWNhbCBtb2RlbHMuXCI7XG5cbiAgICAvL1xuICAgIC8vIHJlYWQgRERJIG1ldGFkYXRhIHdpdGggZDM6XG4gICAgdmFyIG1ldGFkYXRhdXJsID0gXCJcIjtcbiAgICBpZiAoZGRpdXJsKSB7XG4gICAgICAgIC8vIGEgY29tcGxldGUgZGRpdXJsIGlzIHN1cHBsaWVkOlxuICAgICAgICBtZXRhZGF0YXVybCA9IGRkaXVybDtcbiAgICB9IGVsc2UgaWYgKGZpbGVpZCkge1xuICAgICAgICAvLyBmaWxlIGlkIHN1cHBsaWVkOyB3ZSdyZSBnb2luZyB0byBjb29rIGEgc3RhbmRhcmQgZGF0YXZlcnNlXG4gICAgICAgIC8vIG1ldGFkYXRhIHVybCwgd2l0aCB0aGUgZmlsZSBpZCBwcm92aWRlZCBhbmQgdGhlIGhvc3RuYW1lXG4gICAgICAgIC8vIHN1cHBsaWVkIG9yIGNvbmZpZ3VyZWQ6XG4gICAgICAgIG1ldGFkYXRhdXJsID0gZGF0YXZlcnNldXJsICsgXCIvYXBpL21ldGEvZGF0YWZpbGUvXCIgKyBmaWxlaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbmVpdGhlciBhIGZ1bGwgZGRpIHVybCwgbm9yIGZpbGUgaWQgc3VwcGxpZWQ7IHVzZSBvbmUgb2YgdGhlIHNhbXBsZSBERElzIHRoYXQgY29tZSB3aXRoXG4gICAgICAgIC8vIHRoZSBhcHAsIGluIHRoZSBkYXRhIGRpcmVjdG9yeTpcbiAgICAgICAgLy8gbWV0YWRhdGF1cmw9XCJkYXRhL3FvZzEzNy54bWxcIjsgLy8gcXVhbGl0eSBvZiBnb3Zlcm5tZW50XG4gICAgICAgIC8vbWV0YWRhdGF1cmw9XCJkYXRhL2ZlYXJvbkxhaXRpbi54bWxcIjsgLy8gVGhpcyBpcyBGZWFyb24gTGFpdGluXG4gICAgICAgIG1ldGFkYXRhdXJsID0gXCJkYXRhL1BVTVM1c21hbGwtZGRpLnhtbFwiOyAvLyBUaGlzIGlzIENhbGlmb3JuaWEgUFVNUyBzdWJzZXRcbiAgICAgICAgLy9tZXRhZGF0YXVybD1cImRhdGEvQlAuZm9ybWF0dGVkLWRkaS54bWxcIjtcbiAgICAgICAgLy9tZXRhZGF0YXVybD1cImRhdGEvRkxfaW5zdXJhbmNlX3NhbXBsZS1kZGkueG1sXCI7XG4gICAgICAgIC8vbWV0YWRhdGF1cmw9XCJkYXRhL3N0cmV6aG5ldl92b2V0ZW5fMjAxMy54bWxcIjsgICAvLyBUaGlzIGlzIFN0cmV6aG5ldiBWb2V0ZW5cbiAgICAgICAgLy9tZXRhZGF0YXVybD1cImRhdGEvMTkueG1sXCI7IC8vIEZlYXJvbiBmcm9tIERWTiBEZW1vXG4gICAgICAgIC8vbWV0YWRhdGF1cmw9XCJkYXRhLzc2LnhtbFwiOyAvLyBDb2xsaWVyIGZyb20gRFZOIERlbW9cbiAgICAgICAgLy9tZXRhZGF0YXVybD1cImRhdGEvNzkueG1sXCI7IC8vIHR3byB2YXJzIGZyb20gRFZOIERlbW9cbiAgICAgICAgLy9tZXRhZGF0YXVybD1cImRhdGEvMDAwLnhtbFwiOyAvLyBvbmUgdmFyIGluIG1ldGFkYXRhXG4gICAgICAgIC8vbWV0YWRhdGF1cmw9XCJkYXRhLzAwMDAueG1sXCI7IC8vIHplcm8gdmFycyBpbiBtZXRhZGF0YVxuICAgIH1cblxuICAgIC8vIFJlYWRpbmcgdGhlIHByZS1wcm9jZXNzZWQgbWV0YWRhdGE6XG4gICAgLy8gUHJlLXByb2Nlc3NlZCBkYXRhOlxuICAgIHZhciBwVVJMID0gXCJcIjtcbiAgICBpZiAoZGF0YXVybCkge1xuICAgICAgICAvLyBkYXRhIHVybCBpcyBzdXBwbGllZFxuICAgICAgICBwVVJMID0gZGF0YXVybCArIFwiJmZvcm1hdD1wcmVwXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gZGF0YXVybC9maWxlIGlkIHN1cHBsaWVkOyB1c2Ugb25lIG9mIHRoZSBzYW1wbGUgZGF0YSBmaWxlcyBkaXN0cmlidXRlZCB3aXRoIHRoZVxuICAgICAgICAvLyBhcHAgaW4gdGhlIFwiZGF0YVwiIGRpcmVjdG9yeTpcbiAgICAgICAgLy9wVVJMID0gXCJkYXRhL3ByZXByb2Nlc3MyNDI5MzYwLnR4dFwiOyAgIC8vIFRoaXMgaXMgdGhlIFN0cmV6aG5ldiBWb2V0ZW4gSlNPTiBkYXRhXG4gICAgICAgIC8vIHBVUkwgPSBcImRhdGEvZmVhcm9uTGFpdGluLmpzb25cIjsgICAgIC8vIFRoaXMgaXMgdGhlIEZlYXJvbiBMYWl0aW4gSlNPTiBkYXRhXG4gICAgICAgIC8vcFVSTCA9IFwiZGF0YS9mZWFyb25MYWl0aW5OZXdQcmVwcm9jZXNzM2xvbmcuanNvblwiOyAgICAgLy8gVGhpcyBpcyB0aGUgcmV2aXNlZCAoTWF5IDI5LCAyMDE1KSBGZWFyb24gTGFpdGluIEpTT04gZGF0YVxuICAgICAgICBwVVJMID0gXCJkYXRhL3ByZXByb2Nlc3NQVU1TNXNtYWxsLmpzb25cIjsgLy8gVGhpcyBpcyBDYWxpZm9ybmlhIFBVTVMgc3Vic2V0XG4gICAgICAgIC8vcFVSTCA9IFwiZGF0YS9GTF9pbnN1cmFuY2Vfc2FtcGxlLnRhYi5qc29uXCI7XG5cbiAgICAgICAgLy8gcFVSTCA9IFwiZGF0YS9xb2dfcHAuanNvblwiOyAgIC8vIFRoaXMgaXMgUXVhbCBvZiBHb3ZcbiAgICB9XG5cbiAgICB2YXIgcHJlcHJvY2VzcyA9IHt9O1xuXG4gICAgLy8gdGhpcyBpcyB0aGUgZnVuY3Rpb24gYW5kIGNhbGxiYWNrIHJvdXRpbmUgdGhhdCBsb2FkcyBhbGwgZXh0ZXJuYWwgZGF0YTogbWV0YWRhdGEgKERWTidzIGRkaSksIHByZXByb2Nlc3NlZCAoZm9yIHBsb3R0aW5nIGRpc3RyaWJ1dGlvbnMpLCBhbmQgemVsaWdtb2RlbHMgKHByb2R1Y2VkIGJ5IFplbGlnKSBhbmQgaW5pdGlhdGVzIHRoZSBkYXRhIGRvd25sb2FkIHRvIHRoZSBzZXJ2ZXJcbiAgICB2YXIgdXJsLCBwLCB2LCBjYWxsYmFjaztcbiAgICByZWFkUHJlcHJvY2Vzcyh1cmwgPSBwVVJMLCBwID0gcHJlcHJvY2VzcywgdiA9IG51bGwsIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGQzLnhtbChtZXRhZGF0YXVybCwgXCJhcHBsaWNhdGlvbi94bWxcIiwgZnVuY3Rpb24oeG1sKSB7XG4gICAgICAgICAgICB2YXIgdmFycyA9IHhtbC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ2YXJcIik7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IHhtbC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJmaWxlTmFtZVwiKTtcbiAgICAgICAgICAgIHpwYXJhbXMuemRhdGEgPSB0ZW1wWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlO1xuXG4gICAgICAgICAgICAvLyBjbGVhbiB0aGUgY2l0YXRpb24gc28gdGhhdCB0aGUgUE9TVCBpcyB2YWxpZCBqc29uXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGVhbnN0cmluZyhzKSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgvXFwmL2csIFwiYW5kXCIpO1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoL1xcOy9nLCBcIixcIik7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgvXFwlL2csIFwiLVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNpdGUgPSB4bWwuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYmlibENpdFwiKTtcbiAgICAgICAgICAgIHpwYXJhbXMuemRhdGFjaXRlID0gY2l0ZVswXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIHpwYXJhbXMuemRhdGFjaXRlID0gY2xlYW5zdHJpbmcoenBhcmFtcy56ZGF0YWNpdGUpO1xuXG5cbiAgICAgICAgICAgIC8vIGRhdGFzZXQgbmFtZSB0cmltbWVkIHRvIDEyIGNoYXJzXG4gICAgICAgICAgICB2YXIgZGF0YW5hbWUgPSB6cGFyYW1zLnpkYXRhLnJlcGxhY2UoL1xcLiguKikvLCBcIlwiKTsgLy8gcmVndWxhciBleHByZXNzaW9uIHRvIGRyb3AgYW55IGZpbGUgZXh0ZW5zaW9uXG4gICAgICAgICAgICAvLyBQdXQgZGF0YXNldCBuYW1lLCBmcm9tIG1ldGEtZGF0YSwgaW50byB0b3AgcGFuZWxcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNkYXRhTmFtZVwiKVxuICAgICAgICAgICAgICAgIC5odG1sKGRhdGFuYW1lKTtcblxuICAgICAgICAgICAgJCgnI2NpdGUgZGl2LnBhbmVsLWJvZHknKS50ZXh0KHpwYXJhbXMuemRhdGFjaXRlKTtcblxuICAgICAgICAgICAgLy8gUHV0IGRhdGFzZXQgbmFtZSwgZnJvbSBtZXRhLWRhdGEsIGludG8gcGFnZSB0aXRsZVxuICAgICAgICAgICAgZDMuc2VsZWN0KFwidGl0bGVcIikuaHRtbChcIlR3b1JhdmVucyBcIiArIGRhdGFuYW1lKVxuXG4gICAgICAgICAgICAvLyB0ZW1wb3JhcnkgdmFsdWVzIGZvciBob2xkIHRoYXQgY29ycmVzcG9uZCB0byBoaXN0b2dyYW0gYmluc1xuICAgICAgICAgICAgaG9sZCA9IFsuNiwgLjIsIC45LCAuOCwgLjEsIC4zLCAuNF07XG4gICAgICAgICAgICB2YXIgbXl2YWx1ZXMgPSBbMCwgMCwgMCwgMCwgMF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZUtleVtpXSA9IHZhcnNbaV0uYXR0cmlidXRlcy5uYW1lLm5vZGVWYWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmICh2YXJzW2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGFibFwiKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGFibEFycmF5W2ldID0gXCJubyBsYWJlbFwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmxBcnJheVtpXSA9IHZhcnNbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsYWJsXCIpWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkYXRhc2V0Y291bnQgPSBkMy5sYXlvdXQuaGlzdG9ncmFtKClcbiAgICAgICAgICAgICAgICAgICAgLmJpbnMoYmFybnVtYmVyKS5mcmVxdWVuY3koZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIChteXZhbHVlcyk7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNyZWF0ZXMgYW4gb2JqZWN0IHRvIGJlIHB1c2hlZCB0byBhbGxOb2Rlcy4gdGhpcyBjb250YWlucyBhbGwgdGhlIHByZXByb2Nlc3NlZCBkYXRhIHdlIGhhdmUgZm9yIHRoZSB2YXJpYWJsZSwgYXMgd2VsbCBhcyBVSSBkYXRhIHBlcnRpbmVudCB0byB0aGF0IHZhcmlhYmxlLCBzdWNoIGFzIHNldHggdmFsdWVzIChpZiB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgdGhlbSkgYW5kIHBlYmJsZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIHZhciBvYmoxID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgICAgICAgICAgcmVmbGV4aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IHZhbHVlS2V5W2ldLFxuICAgICAgICAgICAgICAgICAgICBcImxhYmxcIjogbGFibEFycmF5W2ldLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbNSwgMTUsIDIwLCAwLCA1LCAxNSwgMjBdLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgXCJub2RlQ29sXCI6IGNvbG9ycyhpKSxcbiAgICAgICAgICAgICAgICAgICAgXCJiYXNlQ29sXCI6IGNvbG9ycyhpKSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VDb2xvclwiOiBzZWxWYXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VXaWR0aFwiOiBcIjFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzdWJzZXRwbG90XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInN1YnNldHJhbmdlXCI6IFtcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgICAgICAgICAgXCJzZXR4cGxvdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJzZXR4dmFsc1wiOiBbXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JheW91dFwiOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBvYmoxLCBwcmVwcm9jZXNzW3ZhbHVlS2V5W2ldXSk7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXMucHVzaChvYmoxKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFJlYWRpbmcgdGhlIHplbGlnIG1vZGVscyBhbmQgcG9wdWxhdGluZyB0aGUgbW9kZWwgbGlzdCBpbiB0aGUgcmlnaHQgcGFuZWwuXG4gICAgICAgICAgICBkMy5qc29uKFwiZGF0YS96ZWxpZzVtb2RlbHMuanNvblwiLCBmdW5jdGlvbihlcnJvciwganNvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgICAgICAgICAgdmFyIGpzb25kYXRhID0ganNvbjtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiemVsaWcgbW9kZWxzIGpzb246IFwiLCBqc29uZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGpzb25kYXRhLnplbGlnNW1vZGVscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbmRhdGEuemVsaWc1bW9kZWxzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHNbanNvbmRhdGEuemVsaWc1bW9kZWxzW2tleV0ubmFtZVswXV0gPSBqc29uZGF0YS56ZWxpZzVtb2RlbHNba2V5XS5kZXNjcmlwdGlvblswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGQzLmpzb24oXCJkYXRhL3plbGlnNWNob2ljZW1vZGVscy5qc29uXCIsIGZ1bmN0aW9uKGVycm9yLCBqc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqc29uZGF0YSA9IGpzb247XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiemVsaWcgY2hvaWNlIG1vZGVscyBqc29uOiBcIiwganNvbmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbmRhdGEuemVsaWc1Y2hvaWNlbW9kZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbmRhdGEuemVsaWc1Y2hvaWNlbW9kZWxzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RzW2pzb25kYXRhLnplbGlnNWNob2ljZW1vZGVsc1trZXldLm5hbWVbMF1dID0ganNvbmRhdGEuemVsaWc1Y2hvaWNlbW9kZWxzW2tleV0uZGVzY3JpcHRpb25bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzY2FmZm9sZGluZyhjYWxsYmFjayA9IGxheW91dCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFEb3dubG9hZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vLyBzY2FmZm9sZGluZyBpcyBjYWxsZWQgYWZ0ZXIgYWxsIGV4dGVybmFsIGRhdGEgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSBiZWVuIHJlYWQgdG8gY29tcGxldGlvbi4gdGhpcyBwb3B1bGF0ZXMgdGhlIGxlZnQgcGFuZWwgd2l0aCB2YXJpYWJsZSBuYW1lcywgdGhlIHJpZ2h0IHBhbmVsIHdpdGggbW9kZWwgbmFtZXMsIHRoZSB0cmFuc2Zvcm1hdGlvbiB0b29sLCBhbiB0aGUgYXNzb2NpYXRlZCBtb3VzZW92ZXJzLiBpdHMgY2FsbGJhY2sgaXMgbGF5b3V0KCksIHdoaWNoIGluaXRpYWxpemVzIHRoZSBtb2RlbGluZyBzcGFjZVxuZnVuY3Rpb24gc2NhZmZvbGRpbmcoY2FsbGJhY2spIHtcbiAgICAvLyBlc3RhYmxpc2hpbmcgdGhlIHRyYW5zZm9ybWF0aW9uIGVsZW1lbnRcbiAgICBkMy5zZWxlY3QoXCIjdHJhbnNmb3JtYXRpb25zXCIpXG4gICAgICAgIC5hcHBlbmQoXCJpbnB1dFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwidElucHV0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJmb3JtLWNvbnRyb2xcIilcbiAgICAgICAgLmF0dHIoXCJ0eXBlXCIsIFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInZhbHVlXCIsIFwiVmFyaWFibGUgdHJhbnNmb3JtYXRpb25cIik7XG5cbiAgICAvLyB0aGUgdmFyaWFibGUgZHJvcGRvd25cbiAgICBkMy5zZWxlY3QoXCIjdHJhbnNmb3JtYXRpb25zXCIpXG4gICAgICAgIC5hcHBlbmQoXCJ1bFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwidHJhbnNTZWxcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCB2YXJDb2xvcilcbiAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAuZGF0YShbXCJhXCIsIFwiYlwiXSkgLy9zZXQgdG8gdmFyaWFibGVzIGluIG1vZGVsIHNwYWNlIGFzIHRoZXkncmUgYWRkZWRcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcImxpXCIpXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KTtcblxuICAgIC8vIHRoZSBmdW5jdGlvbiBkcm9wZG93blxuICAgIGQzLnNlbGVjdChcIiN0cmFuc2Zvcm1hdGlvbnNcIilcbiAgICAgICAgLmFwcGVuZChcInVsXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJ0cmFuc0xpc3RcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCB2YXJDb2xvcilcbiAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAuZGF0YSh0cmFuc2Zvcm1MaXN0KVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwibGlcIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0pO1xuXG4gICAgLy9qcXVlcnkgZG9lcyB0aGlzIHdlbGxcbiAgICAkKCcjdElucHV0JykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RyYW5zU2VsJykuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgaWYgKHQgIT09IFwibm9uZVwiKSB7IC8vIGlmIHZhcmlhYmxlIGxpc3QgaXMgZGlzcGxheWVkIHdoZW4gaW5wdXQgaXMgY2xpY2tlZC4uLlxuICAgICAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0MSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cmFuc0xpc3QnKS5zdHlsZS5kaXNwbGF5O1xuICAgICAgICBpZiAodDEgIT09IFwibm9uZVwiKSB7IC8vIGlmIGZ1bmN0aW9uIGxpc3QgaXMgZGlzcGxheWVkIHdoZW4gaW5wdXQgaXMgY2xpY2tlZC4uLlxuICAgICAgICAgICAgJCgnI3RyYW5zTGlzdCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhpZ2hsaWdodCB0aGUgdGV4dFxuICAgICAgICAkKHRoaXMpLnNlbGVjdCgpO1xuXG4gICAgICAgIHZhciBwb3MgPSAkKCcjdElucHV0Jykub2Zmc2V0KCk7XG4gICAgICAgIHBvcy50b3AgKz0gJCgnI3RJbnB1dCcpLndpZHRoKCk7XG4gICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVJbigxMDApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAkKCcjdElucHV0Jykua2V5dXAoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHJhbnNTZWwnKS5zdHlsZS5kaXNwbGF5O1xuICAgICAgICB2YXIgdDEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHJhbnNMaXN0Jykuc3R5bGUuZGlzcGxheTtcblxuICAgICAgICBpZiAodCAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgfSBlbHNlIGlmICh0MSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICQoJyN0cmFuc0xpc3QnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykgeyAvLyBrZXl1cCBvbiBcIkVudGVyXCJcbiAgICAgICAgICAgIHZhciBuID0gJCgnI3RJbnB1dCcpLnZhbCgpO1xuICAgICAgICAgICAgdmFyIHQgPSB0cmFuc1BhcnNlKG4gPSBuKTtcbiAgICAgICAgICAgIGlmICh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNmb3JtKG4gPSB0LnNsaWNlKDAsIHQubGVuZ3RoIC0gMSksIHQgPSB0W3QubGVuZ3RoIC0gMV0sIHR5cGVUcmFuc2Zvcm0gPSBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICQoJyN0cmFuc0xpc3QgbGknKS5jbGljayhmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgdHZhciA9ICQoJyN0SW5wdXQnKS52YWwoKTtcblxuICAgICAgICAvLyBpZiBpbnRlcmFjdCBpcyBzZWxlY3RlZCwgc2hvdyB2YXJpYWJsZSBsaXN0IGFnYWluXG4gICAgICAgIGlmICgkKHRoaXMpLnRleHQoKSA9PT0gXCJpbnRlcmFjdChkLGUpXCIpIHtcbiAgICAgICAgICAgICQoJyN0SW5wdXQnKS52YWwodHZhci5jb25jYXQoJyonKSk7XG4gICAgICAgICAgICBzZWxJbnRlcmFjdCA9IHRydWU7XG4gICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVJbigxMDApO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGZ1bmMgPSAkKHRoaXMpLnRleHQoKS5yZXBsYWNlKFwiZFwiLCBcIl90cmFuc3ZhcjBcIik7XG4gICAgICAgIHZhciB0Y2FsbCA9ICQodGhpcykudGV4dCgpLnJlcGxhY2UoXCJkXCIsIHR2YXIpO1xuICAgICAgICAkKCcjdElucHV0JykudmFsKHRjYWxsKTtcbiAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0cmFuc2Zvcm0obiA9IHR2YXIsIHQgPSB0ZnVuYywgdHlwZVRyYW5zZm9ybSA9IGZhbHNlKTtcbiAgICB9KTtcblxuICAgIC8vIHBvcHVsYXRpbmcgdGhlIHZhcmlhYmxlIGxpc3QgaW4gdGhlIGxlZnQgcGFuZWxcbiAgICBkMy5zZWxlY3QoXCIjdGFiMVwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5kYXRhKHZhbHVlS2V5KVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLnJlcGxhY2UoL1xcVy9nLCBcIl9cIik7IC8vIHJlcGxhY2Ugbm9uLWFscGhhbnVtZXJpY3MgZm9yIHNlbGVjdGlvbiBwdXJwb3Nlc1xuICAgICAgICB9KSAvLyBwZXJoYXBzZSBlbnN1cmUgdGhpcyBpZCBpcyB1bmlxdWUgYnkgYWRkaW5nICdfJyB0byB0aGUgZnJvbnQ/XG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBpZiAoZmluZE5vZGVJbmRleChkKSA+IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyQ29sb3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGFpbmVyXCIsIFwiYm9keVwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdG9nZ2xlXCIsIFwicG9wb3ZlclwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdHJpZ2dlclwiLCBcImhvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1wbGFjZW1lbnRcIiwgXCJyaWdodFwiKVxuICAgICAgICAuYXR0cihcImRhdGEtaHRtbFwiLCBcInRydWVcIilcbiAgICAgICAgLmF0dHIoXCJvbm1vdXNlb3ZlclwiLCBcIiQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW91dFwiLCBcIiQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiLCBcIlN1bW1hcnkgU3RhdGlzdGljc1wiKTtcblxuICAgIGQzLnNlbGVjdChcIiNtb2RlbHNcIilcbiAgICAgICAgLnN0eWxlKCdoZWlnaHQnLCAyMDAwKVxuICAgICAgICAuc3R5bGUoJ292ZXJmaWxsJywgJ3Njcm9sbCcpO1xuXG4gICAgdmFyIG1vZGVsbGlzdCA9IE9iamVjdC5rZXlzKG1vZHMpO1xuXG4gICAgZDMuc2VsZWN0KFwiI21vZGVsc1wiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5kYXRhKG1vZGVsbGlzdClcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJfbW9kZWxfXCIuY29uY2F0KGQpO1xuICAgICAgICB9KVxuICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSlcbiAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhckNvbG9yO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGFpbmVyXCIsIFwiYm9keVwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdG9nZ2xlXCIsIFwicG9wb3ZlclwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdHJpZ2dlclwiLCBcImhvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1wbGFjZW1lbnRcIiwgXCJ0b3BcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWh0bWxcIiwgXCJ0cnVlXCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW92ZXJcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcIm9ubW91c2VvdXRcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIiwgXCJNb2RlbCBEZXNjcmlwdGlvblwiKVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGVudFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kc1tkXTtcbiAgICAgICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2soKTsgLy8gdGhpcyBjYWxscyBsYXlvdXQoKSBiZWNhdXNlIGF0IHRoaXMgcG9pbnQgYWxsIHNjYWZmb2xkaW5nIGlzIHVwIGFuZCByZWFkeVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbGF5b3V0KHYpIHtcbiAgICB2YXIgbXlWYWx1ZXMgPSBbXTtcbiAgICBub2RlcyA9IFtdO1xuICAgIGxpbmtzID0gW107XG5cbiAgICBpZiAodiA9PT0gXCJhZGRcIiB8IHYgPT09IFwibW92ZVwiKSB7XG4gICAgICAgIGQzLnNlbGVjdChcIiN0YWIxXCIpLnNlbGVjdEFsbChcInBcIikuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCB2YXJDb2xvcik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgenBhcmFtcy56dmFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGlpID0gZmluZE5vZGVJbmRleCh6cGFyYW1zLnp2YXJzW2pdKTtcbiAgICAgICAgICAgIGlmIChhbGxOb2Rlc1tpaV0uZ3JheW91dCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXMucHVzaChhbGxOb2Rlc1tpaV0pO1xuICAgICAgICAgICAgdmFyIHNlbGVjdE1lID0genBhcmFtcy56dmFyc1tqXS5yZXBsYWNlKC9cXFcvZywgXCJfXCIpO1xuICAgICAgICAgICAgc2VsZWN0TWUgPSBcIiNcIi5jb25jYXQoc2VsZWN0TWUpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhUb1JnYmEobm9kZXNbal0uc3Ryb2tlQ29sb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHpwYXJhbXMuemVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgbXlzcmMgPSBub2RlSW5kZXgoenBhcmFtcy56ZWRnZXNbal1bMF0pO1xuICAgICAgICAgICAgdmFyIG15dGd0ID0gbm9kZUluZGV4KHpwYXJhbXMuemVkZ2VzW2pdWzFdKTtcbiAgICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbbXlzcmNdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbbXl0Z3RdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhbGxOb2Rlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXSwgYWxsTm9kZXNbMV0sIGFsbE5vZGVzWzJdXTtcbiAgICAgICAgICAgIGxpbmtzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBub2Rlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbMl0sXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXSwgYWxsTm9kZXNbMV1dO1xuICAgICAgICAgICAgbGlua3MgPSBbe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbMV0sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1swXSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGVydChcIlRoZXJlIGFyZSB6ZXJvIHZhcmlhYmxlcyBpbiB0aGUgbWV0YWRhdGEuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFuZWxQbG90cygpOyAvLyBhZnRlciBub2RlcyBpcyBwb3B1bGF0ZWQsIGFkZCBzdWJzZXQgYW5kIHNldHggcGFuZWxzXG4gICAgcG9wdWxhdGVQb3BvdmVyKCk7IC8vIHBpcGVzIGluIHRoZSBzdW1tYXJ5IHN0YXRzIHNob3duIG9uIG1vdXNlb3ZlcnNcblxuICAgIC8vIGluaXQgRDMgZm9yY2UgbGF5b3V0XG4gICAgdmFyIGZvcmNlID0gZDMubGF5b3V0LmZvcmNlKClcbiAgICAgICAgLm5vZGVzKG5vZGVzKVxuICAgICAgICAubGlua3MobGlua3MpXG4gICAgICAgIC5zaXplKFt3aWR0aCwgaGVpZ2h0XSlcbiAgICAgICAgLmxpbmtEaXN0YW5jZSgxNTApXG4gICAgICAgIC5jaGFyZ2UoLTgwMClcbiAgICAgICAgLm9uKCd0aWNrJywgdGljayk7IC8vIC5zdGFydCgpIGlzIGltcG9ydGFudCB0byBpbml0aWFsaXplIHRoZSBsYXlvdXRcblxuICAgIC8vIGRlZmluZSBhcnJvdyBtYXJrZXJzIGZvciBncmFwaCBsaW5rc1xuICAgIHN2Zy5hcHBlbmQoJ3N2ZzpkZWZzJykuYXBwZW5kKCdzdmc6bWFya2VyJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2VuZC1hcnJvdycpXG4gICAgICAgIC5hdHRyKCd2aWV3Qm94JywgJzAgLTUgMTAgMTAnKVxuICAgICAgICAuYXR0cigncmVmWCcsIDYpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDMpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCAzKVxuICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxuICAgICAgICAuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgIC5hdHRyKCdkJywgJ00wLC01TDEwLDBMMCw1JylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJyMwMDAnKTtcblxuICAgIHN2Zy5hcHBlbmQoJ3N2ZzpkZWZzJykuYXBwZW5kKCdzdmc6bWFya2VyJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ3N0YXJ0LWFycm93JylcbiAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCAnMCAtNSAxMCAxMCcpXG4gICAgICAgIC5hdHRyKCdyZWZYJywgNClcbiAgICAgICAgLmF0dHIoJ21hcmtlcldpZHRoJywgMylcbiAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDMpXG4gICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXG4gICAgICAgIC5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTEwLC01TDAsMEwxMCw1JylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJyMwMDAnKTtcblxuICAgIC8vIGxpbmUgZGlzcGxheWVkIHdoZW4gZHJhZ2dpbmcgbmV3IG5vZGVzXG4gICAgdmFyIGRyYWdfbGluZSA9IHN2Zy5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmsgZHJhZ2xpbmUgaGlkZGVuJylcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTAsMEwwLDAnKTtcblxuICAgIC8vIGhhbmRsZXMgdG8gbGluayBhbmQgbm9kZSBlbGVtZW50IGdyb3Vwc1xuICAgIHZhciBwYXRoID0gc3ZnLmFwcGVuZCgnc3ZnOmcnKS5zZWxlY3RBbGwoJ3BhdGgnKSxcbiAgICAgICAgY2lyY2xlID0gc3ZnLmFwcGVuZCgnc3ZnOmcnKS5zZWxlY3RBbGwoJ2cnKTtcblxuICAgIC8vIG1vdXNlIGV2ZW50IHZhcnNcbiAgICB2YXIgc2VsZWN0ZWRfbm9kZSA9IG51bGwsXG4gICAgICAgIHNlbGVjdGVkX2xpbmsgPSBudWxsLFxuICAgICAgICBtb3VzZWRvd25fbGluayA9IG51bGwsXG4gICAgICAgIG1vdXNlZG93bl9ub2RlID0gbnVsbCxcbiAgICAgICAgbW91c2V1cF9ub2RlID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIHJlc2V0TW91c2VWYXJzKCkge1xuICAgICAgICBtb3VzZWRvd25fbm9kZSA9IG51bGw7XG4gICAgICAgIG1vdXNldXBfbm9kZSA9IG51bGw7XG4gICAgICAgIG1vdXNlZG93bl9saW5rID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZm9yY2UgbGF5b3V0IChjYWxsZWQgYXV0b21hdGljYWxseSBlYWNoIGl0ZXJhdGlvbilcbiAgICBmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgICAvLyBkcmF3IGRpcmVjdGVkIGVkZ2VzIHdpdGggcHJvcGVyIHBhZGRpbmcgZnJvbSBub2RlIGNlbnRlcnNcbiAgICAgICAgcGF0aC5hdHRyKCdkJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIGRlbHRhWCA9IGQudGFyZ2V0LnggLSBkLnNvdXJjZS54LFxuICAgICAgICAgICAgICAgIGRlbHRhWSA9IGQudGFyZ2V0LnkgLSBkLnNvdXJjZS55LFxuICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKSxcbiAgICAgICAgICAgICAgICBub3JtWCA9IGRlbHRhWCAvIGRpc3QsXG4gICAgICAgICAgICAgICAgbm9ybVkgPSBkZWx0YVkgLyBkaXN0LFxuICAgICAgICAgICAgICAgIHNvdXJjZVBhZGRpbmcgPSBkLmxlZnQgPyBhbGxSICsgNSA6IGFsbFIsXG4gICAgICAgICAgICAgICAgdGFyZ2V0UGFkZGluZyA9IGQucmlnaHQgPyBhbGxSICsgNSA6IGFsbFIsXG4gICAgICAgICAgICAgICAgc291cmNlWCA9IGQuc291cmNlLnggKyAoc291cmNlUGFkZGluZyAqIG5vcm1YKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VZID0gZC5zb3VyY2UueSArIChzb3VyY2VQYWRkaW5nICogbm9ybVkpLFxuICAgICAgICAgICAgICAgIHRhcmdldFggPSBkLnRhcmdldC54IC0gKHRhcmdldFBhZGRpbmcgKiBub3JtWCksXG4gICAgICAgICAgICAgICAgdGFyZ2V0WSA9IGQudGFyZ2V0LnkgLSAodGFyZ2V0UGFkZGluZyAqIG5vcm1ZKTtcbiAgICAgICAgICAgIHJldHVybiAnTScgKyBzb3VyY2VYICsgJywnICsgc291cmNlWSArICdMJyArIHRhcmdldFggKyAnLCcgKyB0YXJnZXRZO1xuICAgICAgICB9KTtcblxuICAgICAgICBjaXJjbGUuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIGQueCArICcsJyArIGQueSArICcpJztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gIGFkZCBsaXN0ZW5lcnMgdG8gbGVmdHBhbmVsLmxlZnQuICBldmVyeSB0aW1lIGEgdmFyaWFibGUgaXMgY2xpY2tlZCwgbm9kZXMgdXBkYXRlcyBhbmQgYmFja2dyb3VuZCBjb2xvciBjaGFuZ2VzLiAgbW91c2VvdmVyIHNob3dzIHN1bW1hcnkgc3RhdHMgb3IgbW9kZWwgZGVzY3JpcHRpb24uXG4gICAgZDMuc2VsZWN0KFwiI3RhYjFcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgLy8gUkVNT1ZFRCBUSElTIFRPT0xUSVAgQ09ERSBBTkQgTUFERSBBIEJPT1RTVFJBUCBQT1BPVkVSIENPTVBPTkVOVFxuICAgICAgICAgICAgJChcImJvZHkgZGl2LnBvcG92ZXJcIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJ2YXJpYWJsZXNcIik7XG4gICAgICAgICAgICAkKFwiYm9keSBkaXYucG9wb3ZlciBkaXYucG9wb3Zlci1jb250ZW50XCIpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiZm9ybS1ob3Jpem9udGFsXCIpO1xuICAgICAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vUmVtb3ZlIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAvL2QzLnNlbGVjdChcIiN0b29sdGlwXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIHZhckNsaWNrKCkge1xuICAgICAgICAgICAgaWYgKGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgodGhpcy5pZCldLmdyYXlvdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG15VGV4dCA9IGQzLnNlbGVjdCh0aGlzKS50ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBteUNvbG9yID0gZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBteVNDID0gYWxsTm9kZXNbZmluZE5vZGVJbmRleChteVRleHQpXS5zdHJva2VDb2xvcjtcblxuICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnp2YXJzID0gW107IC8vZW1wdHkgdGhlIHp2YXJzIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGlmIChkMy5yZ2IobXlDb2xvcikudG9TdHJpbmcoKSA9PT0gdmFyQ29sb3IudG9TdHJpbmcoKSkgeyAvLyB3ZSBhcmUgYWRkaW5nIGEgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGZpbmROb2RlKG15VGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzWzBdLnJlZmxleGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goZmluZE5vZGUobXlUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGV4VG9SZ2JhKHNlbFZhckNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gZHJvcHBpbmcgYSB2YXJpYWJsZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoZmluZE5vZGUobXlUZXh0KVtcImluZGV4XCJdLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZUxpbmtzRm9yTm9kZShmaW5kTm9kZShteVRleHQpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG15U0MgPT0gZHZDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdkluZGV4ID0genBhcmFtcy56ZHYuaW5kZXhPZihteVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkdkluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56ZHYuc3BsaWNlKGR2SW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3pwYXJhbXMuemR2PVwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG15U0MgPT0gY3NDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjc0luZGV4ID0genBhcmFtcy56Y3Jvc3MuaW5kZXhPZihteVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc0luZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56Y3Jvc3Muc3BsaWNlKGNzSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobXlTQyA9PSB0aW1lQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZUluZGV4ID0genBhcmFtcy56dGltZS5pbmRleE9mKG15VGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuenRpbWUuc3BsaWNlKHRpbWVJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChteVNDID09IG5vbUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vbUluZGV4ID0genBhcmFtcy56bm9tLmluZGV4T2YobXlUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9tSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpub20uc3BsaWNlKGR2SW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlc2V0KGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgobXlUZXh0KV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG4gICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgZDMuc2VsZWN0KFwiI21vZGVsc1wiKS5zZWxlY3RBbGwoXCJwXCIpIC8vIG1vZGVscyB0YWJcbiAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIC8vIFJFTU9WRUQgVEhJUyBUT09MVElQIENPREUgQU5EIE1BREUgQSBCT09UU1RSQVAgUE9QT1ZFUiBDT01QT05FTlRcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvL1JlbW92ZSB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgLy9kMy5zZWxlY3QoXCIjdG9vbHRpcFwiKS5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgICAgICB9KVxuICAgICAgICAvLyAgZDMuc2VsZWN0KFwiI0Rpc3BsYXlfY29udGVudFwiKVxuICAgICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBteUNvbG9yID0gZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjbW9kZWxzXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCB2YXJDb2xvcik7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkMy5yZ2IobXlDb2xvcikudG9TdHJpbmcoKSA9PT0gdmFyQ29sb3IudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56bW9kZWwgPSBkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGV4VG9SZ2JhKHNlbFZhckNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuem1vZGVsID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YXJDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSBncmFwaCAoY2FsbGVkIHdoZW4gbmVlZGVkKVxuICAgIGZ1bmN0aW9uIHJlc3RhcnQoKSB7XG4gICAgICAgIC8vIG5vZGVzLmlkIGlzIHBlZ2dlZCB0byBhbGxOb2RlcywgaS5lLiB0aGUgb3JkZXIgaW4gd2hpY2ggdmFyaWFibGVzIGFyZSByZWFkIGluXG4gICAgICAgIC8vIG5vZGVzLmluZGV4IGlzIGZsb2F0aW5nIGFuZCBkZXBlbmRzIG9uIHVwZGF0ZXMgdG8gbm9kZXMuICBhIHZhcmlhYmxlcyBpbmRleCBjaGFuZ2VzIHdoZW4gbmV3IHZhcmlhYmxlcyBhcmUgYWRkZWQuXG4gICAgICAgIGNpcmNsZS5jYWxsKGZvcmNlLmRyYWcpO1xuICAgICAgICBpZiAoZm9yY2V0b2dnbGVbMF0gPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICBmb3JjZS5ncmF2aXR5KDAuMSk7XG4gICAgICAgICAgICBmb3JjZS5jaGFyZ2UoLTgwMCk7XG4gICAgICAgICAgICBmb3JjZS5saW5rU3RyZW5ndGgoMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JjZS5ncmF2aXR5KDApO1xuICAgICAgICAgICAgZm9yY2UuY2hhcmdlKDApO1xuICAgICAgICAgICAgZm9yY2UubGlua1N0cmVuZ3RoKDApO1xuICAgICAgICB9XG4gICAgICAgIGZvcmNlLnJlc3VtZSgpO1xuXG4gICAgICAgIC8vIHBhdGggKGxpbmspIGdyb3VwXG4gICAgICAgIHBhdGggPSBwYXRoLmRhdGEobGlua3MpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBleGlzdGluZyBsaW5rc1xuICAgICAgICAvLyBWSkQ6IGRhc2hlZCBsaW5rcyBiZXR3ZWVuIHBlYmJsZXMgYXJlIFwic2VsZWN0ZWRcIi4gdGhpcyBpcyBkaXNhYmxlZCBmb3Igbm93XG4gICAgICAgIHBhdGguY2xhc3NlZCgnc2VsZWN0ZWQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSkgLy9yZXR1cm4gZCA9PT0gc2VsZWN0ZWRfbGluazsgfSlcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLXN0YXJ0JywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmxlZnQgPyAndXJsKCNzdGFydC1hcnJvdyknIDogJyc7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLnJpZ2h0ID8gJ3VybCgjZW5kLWFycm93KScgOiAnJztcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgLy8gYWRkIG5ldyBsaW5rc1xuICAgICAgICBwYXRoLmVudGVyKCkuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluaycpXG4gICAgICAgICAgICAuY2xhc3NlZCgnc2VsZWN0ZWQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSkgLy9yZXR1cm4gZCA9PT0gc2VsZWN0ZWRfbGluazsgfSlcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLXN0YXJ0JywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmxlZnQgPyAndXJsKCNzdGFydC1hcnJvdyknIDogJyc7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLnJpZ2h0ID8gJ3VybCgjZW5kLWFycm93KScgOiAnJztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGQpIHsgLy8gZG8gd2UgZXZlciBuZWVkIHRvIHNlbGVjdCBhIGxpbms/IG1ha2UgaXQgZGVsZXRlLi5cbiAgICAgICAgICAgICAgICB2YXIgb2JqMSA9IEpTT04uc3RyaW5naWZ5KGQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGlua3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iajEgPT09IEpTT04uc3RyaW5naWZ5KGxpbmtzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua3Muc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIG9sZCBsaW5rc1xuICAgICAgICBwYXRoLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAvLyBjaXJjbGUgKG5vZGUpIGdyb3VwXG4gICAgICAgIGNpcmNsZSA9IGNpcmNsZS5kYXRhKG5vZGVzLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5pZDtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvLyB1cGRhdGUgZXhpc3Rpbmcgbm9kZXMgKHJlZmxleGl2ZSAmIHNlbGVjdGVkIHZpc3VhbCBzdGF0ZXMpXG4gICAgICAgIC8vZDMucmdiIGlzIHRoZSBmdW5jdGlvbiBhZGp1c3RpbmcgdGhlIGNvbG9yIGhlcmUuXG4gICAgICAgIGNpcmNsZS5zZWxlY3RBbGwoJ2NpcmNsZScpXG4gICAgICAgICAgICAuY2xhc3NlZCgncmVmbGV4aXZlJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLnJlZmxleGl2ZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQzLnJnYihkLm5vZGVDb2wpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZDMucmdiKGQuc3Ryb2tlQ29sb3IpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGQuc3Ryb2tlV2lkdGgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIG5ldyBub2Rlc1xuXG4gICAgICAgIHZhciBnID0gY2lyY2xlLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHZhciBteW5hbWUgPSBkLm5hbWUgKyBcImJpZ2dyb3VwXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChteW5hbWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIHBsb3RcbiAgICAgICAgZy5lYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIGlmIChkLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgICAgICAgICAgIGRlbnNpdHlOb2RlKGQsIG9iaiA9IHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkLnBsb3R0eXBlID09PSBcImJhclwiKSB7XG4gICAgICAgICAgICAgICAgYmFyc05vZGUoZCwgb2JqID0gdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZHZBcmNcIi5jb25jYXQoZC5pZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzMpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGR2Q29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC4zKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI2R2VGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjkpXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjZHZUZXh0XCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBkdkNvbG9yKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQoZHZDb2xvcik7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZHZUZXh0XCIuY29uY2F0KGQuaWQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCA2KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0UGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIjZHZBcmNcIi5jb25jYXQoZC5pZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRleHQoXCJEZXAgVmFyXCIpO1xuXG4gICAgICAgIGcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibm9tQXJjXCIuY29uY2F0KGQuaWQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmM0KVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBub21Db2xvcilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcImNoYXJhY3RlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC4zKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI25vbVRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC45KVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcImNoYXJhY3RlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNub21UZXh0XCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwiY2hhcmFjdGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRDb2xvcnMoZCwgbm9tQ29sb3IpO1xuICAgICAgICAgICAgICAgIGxlZ2VuZChub21Db2xvcik7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibm9tVGV4dFwiLmNvbmNhdChkLmlkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgNilcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgMTEuNSlcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuYXBwZW5kKFwidGV4dFBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwieGxpbms6aHJlZlwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiI25vbUFyY1wiLmNvbmNhdChkLmlkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGV4dChcIk5vbWluYWxcIik7XG5cbiAgICAgICAgZy5hcHBlbmQoJ3N2ZzpjaXJjbGUnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ25vZGUnKVxuICAgICAgICAgICAgLmF0dHIoJ3InLCBhbGxSKVxuICAgICAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdpbmhlcml0JylcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgIHJldHVybiAoZCA9PT0gc2VsZWN0ZWRfbm9kZSkgPyBkMy5yZ2IoZC5ub2RlQ29sKS5icmlnaHRlcigpLnRvU3RyaW5nKCkgOiBkLm5vZGVDb2w7IH0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubm9kZUNvbDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBcIjAuNVwiKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQzLnJnYihkLnN0cm9rZUNvbG9yKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdyZWZsZXhpdmUnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQucmVmbGV4aXZlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZGJsY2xpY2snLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIHN0b3AgY2xpY2sgZnJvbSBidWJibGluZ1xuICAgICAgICAgICAgICAgIHN1bW1hcnlIb2xkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NvbnRleHRtZW51JywgZnVuY3Rpb24oZCkgeyAvLyByaWdodCBjbGljayBvbiBub2RlXG4gICAgICAgICAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3RvcCByaWdodCBjbGljayBmcm9tIGJ1YmJsaW5nXG4gICAgICAgICAgICAgICAgcmlnaHRDbGlja0xhc3QgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgbW91c2Vkb3duX25vZGUgPSBkO1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZWRvd25fbm9kZSA9PT0gc2VsZWN0ZWRfbm9kZSkgc2VsZWN0ZWRfbm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZWxzZSBzZWxlY3RlZF9ub2RlID0gbW91c2Vkb3duX25vZGU7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbGluayA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyByZXBvc2l0aW9uIGRyYWcgbGluZVxuICAgICAgICAgICAgICAgIGRyYWdfbGluZVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCAndXJsKCNlbmQtYXJyb3cpJylcbiAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZCcsICdNJyArIG1vdXNlZG93bl9ub2RlLnggKyAnLCcgKyBtb3VzZWRvd25fbm9kZS55ICsgJ0wnICsgbW91c2Vkb3duX25vZGUueCArICcsJyArIG1vdXNlZG93bl9ub2RlLnkpO1xuXG4gICAgICAgICAgICAgICAgc3ZnLm9uKCdtb3VzZW1vdmUnLCBtb3VzZW1vdmUpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNldXAnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIHN0b3AgbW91c2V1cCBmcm9tIGJ1YmJsaW5nXG5cbiAgICAgICAgICAgICAgICBpZiAocmlnaHRDbGlja0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDbGlja0xhc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbW91c2Vkb3duX25vZGUpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIG5lZWRlZCBieSBGRlxuICAgICAgICAgICAgICAgIGRyYWdfbGluZVxuICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJycpO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGRyYWctdG8tc2VsZlxuICAgICAgICAgICAgICAgIG1vdXNldXBfbm9kZSA9IGQ7XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNldXBfbm9kZSA9PT0gbW91c2Vkb3duX25vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRNb3VzZVZhcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVuZW5sYXJnZSB0YXJnZXQgbm9kZVxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCd0cmFuc2Zvcm0nLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgbGluayB0byBncmFwaCAodXBkYXRlIGlmIGV4aXN0cylcbiAgICAgICAgICAgICAgICAvLyBOQjogbGlua3MgYXJlIHN0cmljdGx5IHNvdXJjZSA8IHRhcmdldDsgYXJyb3dzIHNlcGFyYXRlbHkgc3BlY2lmaWVkIGJ5IGJvb2xlYW5zXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSwgdGFyZ2V0LCBkaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNlZG93bl9ub2RlLmlkIDwgbW91c2V1cF9ub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IG1vdXNlZG93bl9ub2RlO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBtb3VzZXVwX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbW91c2V1cF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBtb3VzZWRvd25fbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsaW5rO1xuICAgICAgICAgICAgICAgIGxpbmsgPSBsaW5rcy5maWx0ZXIoZnVuY3Rpb24obCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGwuc291cmNlID09PSBzb3VyY2UgJiYgbC50YXJnZXQgPT09IHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgbGlua1tkaXJlY3Rpb25dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaW5rID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGxpbmtbZGlyZWN0aW9uXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0IG5ldyBsaW5rXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbGluayA9IGxpbms7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3ZnLm9uKCdtb3VzZW1vdmUnLCBudWxsKTtcblxuICAgICAgICAgICAgICAgIHJlc2V0TW91c2VWYXJzKCk7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAvLyBzaG93IG5vZGUgTmFtZXNcbiAgICAgICAgZy5hcHBlbmQoJ3N2Zzp0ZXh0JylcbiAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMTUpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaWQnKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLm5hbWU7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIC8vIHNob3cgc3VtbWFyeSBzdGF0cyBvbiBtb3VzZW92ZXJcbiAgICAgICAgLy8gU1ZHIGRvZXNuJ3Qgc3VwcG9ydCB0ZXh0IHdyYXBwaW5nLCB1c2UgaHRtbCBpbnN0ZWFkXG4gICAgICAgIGcuc2VsZWN0QWxsKFwiY2lyY2xlLm5vZGVcIilcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgdGFiTGVmdChcInRhYjNcIik7XG4gICAgICAgICAgICAgICAgdmFyU3VtbWFyeShkKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHJhbnNmb3JtYXRpb25zJykuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJkaXNwbGF5OmJsb2NrXCIpO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRyYW5zU2VsXCIpO1xuICAgICAgICAgICAgICAgIHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gZC5pZDtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1WYXIgPSB2YWx1ZUtleVtkLmlkXTtcblxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNkdkFyY1wiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjEpXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMTAwKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjZHZUZXh0XCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAuNSlcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwibnVtZXJpY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNub21BcmNcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC4xKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI25vbVRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC41KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI2NzQXJjXCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAuMSlcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNjc1RleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC41KVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3RpbWVBcmNcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC4xKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3RpbWVUZXh0XCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAuNSlcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC8vIHBvcHVwKGQsIHhQb3MsIHlQb3MpO1xuXG4gICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1bW1hcnlIb2xkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0YWJMZWZ0KGxlZnR0YWIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNjc0FyY1wiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNjc1RleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjdGltZUFyY1wiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiN0aW1lVGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNkdkFyY1wiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNkdlRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjbm9tQXJjXCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDEwMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI25vbVRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHBvcHVsYXRpbmcgdHJhbnNmb3JtYXRpb24gZHJvcGRvd25cbiAgICAgICAgdmFyIHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdC5wdXNoKG5vZGVzW2pdLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIHRyYW5zZm9ybWF0aW9uIHZhcmlhYmxlIGxpc3QgaXMgc2lsZW50bHkgdXBkYXRlZCBhcyBwZWJibGVzIGFyZSBhZGRlZC9yZW1vdmVkXG4gICAgICAgIGQzLnNlbGVjdChcIiN0cmFuc1NlbFwiKVxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiN0cmFuc1NlbFwiKVxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAgICAgLmRhdGEodCkgLy9zZXQgdG8gdmFyaWFibGVzIGluIG1vZGVsIHNwYWNlIGFzIHRoZXkncmUgYWRkZWRcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwibGlcIilcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICQoJyN0cmFuc1NlbCBsaScpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBpZiAnaW50ZXJhY3Rpb24nIGlzIHRoZSBzZWxlY3RlZCBmdW5jdGlvbiwgZG9uJ3Qgc2hvdyB0aGUgZnVuY3Rpb24gbGlzdCBhZ2FpblxuICAgICAgICAgICAgaWYgKHNlbEludGVyYWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSAkKCcjdElucHV0JykudmFsKCkuY29uY2F0KCQodGhpcykudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAkKCcjdElucHV0JykudmFsKG4pO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdHJhbnNQYXJzZShuID0gbik7XG4gICAgICAgICAgICAgICAgaWYgKHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obiA9IHQuc2xpY2UoMCwgdC5sZW5ndGggLSAxKSwgdCA9IHRbdC5sZW5ndGggLSAxXSwgdHlwZVRyYW5zZm9ybSA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQoJyN0SW5wdXQnKS52YWwoJCh0aGlzKS50ZXh0KCkpO1xuICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAkKCcjdHJhbnNMaXN0JykuZmFkZUluKDEwMCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIG9sZCBub2Rlc1xuICAgICAgICBjaXJjbGUuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICBmb3JjZS5zdGFydCgpO1xuICAgIH0gLy9lbmQgcmVzdGFydCBmdW5jdGlvblxuXG4gICAgZnVuY3Rpb24gbW91c2Vkb3duKGQpIHtcbiAgICAgICAgLy8gcHJldmVudCBJLWJhciBvbiBkcmFnXG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gYmVjYXVzZSA6YWN0aXZlIG9ubHkgd29ya3MgaW4gV2ViS2l0P1xuICAgICAgICBzdmcuY2xhc3NlZCgnYWN0aXZlJywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGQzLmV2ZW50LmN0cmxLZXkgfHwgbW91c2Vkb3duX25vZGUgfHwgbW91c2Vkb3duX2xpbmspIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3RhcnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmUoZCkge1xuICAgICAgICBpZiAoIW1vdXNlZG93bl9ub2RlKSByZXR1cm47XG5cbiAgICAgICAgLy8gdXBkYXRlIGRyYWcgbGluZVxuICAgICAgICBkcmFnX2xpbmUuYXR0cignZCcsICdNJyArIG1vdXNlZG93bl9ub2RlLnggKyAnLCcgKyBtb3VzZWRvd25fbm9kZS55ICsgJ0wnICsgZDMubW91c2UodGhpcylbMF0gKyAnLCcgKyBkMy5tb3VzZSh0aGlzKVsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2V1cChkKSB7XG4gICAgICAgIGlmIChtb3VzZWRvd25fbm9kZSkge1xuICAgICAgICAgICAgLy8gaGlkZSBkcmFnIGxpbmVcbiAgICAgICAgICAgIGRyYWdfbGluZVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCB0cnVlKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsICcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBiZWNhdXNlIDphY3RpdmUgb25seSB3b3JrcyBpbiBXZWJLaXQ/XG4gICAgICAgIHN2Zy5jbGFzc2VkKCdhY3RpdmUnLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gY2xlYXIgbW91c2UgZXZlbnQgdmFyc1xuICAgICAgICByZXNldE1vdXNlVmFycygpO1xuICAgIH1cblxuICAgIC8vIGFwcCBzdGFydHMgaGVyZVxuICAgIHN2Zy5hdHRyKCdpZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwid2hpdGVzcGFjZVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodClcbiAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1vdXNlZG93bih0aGlzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtb3VzZXVwKHRoaXMpO1xuICAgICAgICB9KTtcblxuICAgIGQzLnNlbGVjdCh3aW5kb3cpXG4gICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbigpIHsgLy9OT1RFOiBhbGwgY2xpY2tzIHdpbGwgYnViYmxlIGhlcmUgdW5sZXNzIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAkKCcjdHJhbnNMaXN0JykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZU91dCgxMDApO1xuICAgICAgICB9KTtcblxuICAgIHJlc3RhcnQoKTsgLy8gdGhpcyBpcyB0aGUgY2FsbCB0aGUgcmVzdGFydCB0aGF0IGluaXRpYWxpemVzIHRoZSBmb3JjZS5sYXlvdXQoKVxuICAgIGZha2VDbGljaygpO1xufSAvLyBlbmQgbGF5b3V0XG5cblxuLy8gcmV0dXJucyBpZFxudmFyIGZpbmROb2RlSW5kZXggPSBmdW5jdGlvbihub2RlTmFtZSkge1xuICAgIGZvciAodmFyIGkgaW4gYWxsTm9kZXMpIHtcbiAgICAgICAgaWYgKGFsbE5vZGVzW2ldW1wibmFtZVwiXSA9PT0gbm9kZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhbGxOb2Rlc1tpXVtcImlkXCJdO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxudmFyIG5vZGVJbmRleCA9IGZ1bmN0aW9uKG5vZGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSBpbiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZXNbaV1bXCJuYW1lXCJdID09PSBub2RlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBmaW5kTm9kZSA9IGZ1bmN0aW9uKG5vZGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSBpbiBhbGxOb2Rlcykge1xuICAgICAgICBpZiAoYWxsTm9kZXNbaV1bXCJuYW1lXCJdID09PSBub2RlTmFtZSkgcmV0dXJuIGFsbE5vZGVzW2ldXG4gICAgfTtcbn1cblxuLy8gZnVuY3Rpb24gY2FsbGVkIGJ5IGZvcmNlIGJ1dHRvblxuZnVuY3Rpb24gZm9yY2VTd2l0Y2goKSB7XG4gICAgaWYgKGZvcmNldG9nZ2xlWzBdID09PSBcInRydWVcIikge1xuICAgICAgICBmb3JjZXRvZ2dsZSA9IFtcImZhbHNlXCJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcmNldG9nZ2xlID0gW1widHJ1ZVwiXVxuICAgIH1cblxuICAgIGlmIChmb3JjZXRvZ2dsZVswXSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5Gb3JjZScpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGFjdGl2ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuRm9yY2UnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgZmFrZUNsaWNrKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzcGxpY2VMaW5rc0Zvck5vZGUobm9kZSkge1xuICAgIHZhciB0b1NwbGljZSA9IGxpbmtzLmZpbHRlcihmdW5jdGlvbihsKSB7XG4gICAgICAgIHJldHVybiAobC5zb3VyY2UgPT09IG5vZGUgfHwgbC50YXJnZXQgPT09IG5vZGUpO1xuICAgIH0pO1xuICAgIHRvU3BsaWNlLm1hcChmdW5jdGlvbihsKSB7XG4gICAgICAgIGxpbmtzLnNwbGljZShsaW5rcy5pbmRleE9mKGwpLCAxKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gelBvcCgpIHtcbiAgICBpZiAoZGF0YXVybCkge1xuICAgICAgICB6cGFyYW1zLnpkYXRhdXJsID0gZGF0YXVybDtcbiAgICB9XG5cbiAgICB6cGFyYW1zLnptb2RlbGNvdW50ID0gbW9kZWxDb3VudDtcblxuICAgIHpwYXJhbXMuemVkZ2VzID0gW107XG4gICAgenBhcmFtcy56dmFycyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykgeyAvL3BvcHVsYXRlIHp2YXJzIGFycmF5XG4gICAgICAgIHpwYXJhbXMuenZhcnMucHVzaChub2Rlc1tqXS5uYW1lKTtcbiAgICAgICAgdmFyIHRlbXAgPSBub2Rlc1tqXS5pZDtcblxuICAgICAgICB6cGFyYW1zLnpzZXR4W2pdID0gYWxsTm9kZXNbdGVtcF0uc2V0eHZhbHM7XG4gICAgICAgIHpwYXJhbXMuenN1YnNldFtqXSA9IGFsbE5vZGVzW3RlbXBdLnN1YnNldHJhbmdlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGlua3MubGVuZ3RoOyBqKyspIHsgLy9wb3B1bGF0ZSB6ZWRnZXMgYXJyYXlcbiAgICAgICAgdmFyIHNyY3RndCA9IFtdO1xuICAgICAgICAvL2NvcnJlY3QgdGhlIHNvdXJjZSB0YXJnZXQgb3JkZXJpbmcgZm9yIFplbGlnXG4gICAgICAgIGlmIChsaW5rc1tqXS5sZWZ0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3JjdGd0ID0gW2xpbmtzW2pdLnNvdXJjZS5uYW1lLCBsaW5rc1tqXS50YXJnZXQubmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcmN0Z3QgPSBbbGlua3Nbal0udGFyZ2V0Lm5hbWUsIGxpbmtzW2pdLnNvdXJjZS5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICB6cGFyYW1zLnplZGdlcy5wdXNoKHNyY3RndCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBlc3RpbWF0ZShidG4pIHtcblxuICAgIGlmIChwcm9kdWN0aW9uICYmIHpwYXJhbXMuenNlc3Npb25pZCA9PSBcIlwiKSB7XG4gICAgICAgIGFsZXJ0KFwiV2FybmluZzogRGF0YSBkb3dubG9hZCBpcyBub3QgY29tcGxldGUuIFRyeSBhZ2FpbiBzb29uLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHpQb3AoKTtcbiAgICAvLyB3cml0ZSBsaW5rcyB0byBmaWxlICYgcnVuIFIgQ01EXG5cbiAgICAvL3BhY2thZ2UgdGhlIG91dHB1dCBhcyBKU09OXG4gICAgLy8gYWRkIGNhbGwgaGlzdG9yeSBhbmQgcGFja2FnZSB0aGUgenBhcmFtcyBvYmplY3QgYXMgSlNPTlxuICAgIHpwYXJhbXMuY2FsbEhpc3RvcnkgPSBjYWxsSGlzdG9yeTtcbiAgICB2YXIganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KHpwYXJhbXMpO1xuXG4gICAgLy92YXIgYmFzZSA9IHJhcHBVUkwrXCJ6ZWxpZ2FwcD9zb2xhSlNPTj1cIlxuICAgIHVybGNhbGwgPSByYXBwVVJMICsgXCJ6ZWxpZ2FwcFwiOyAvL2Jhc2UuY29uY2F0KGpzb25vdXQpO1xuICAgIHZhciBzb2xhanNvbm91dCA9IFwic29sYUpTT049XCIgKyBqc29ub3V0O1xuICAgIGNvbnNvbGUubG9nKFwidXJsY2FsbCBvdXQ6IFwiLCB1cmxjYWxsKTtcbiAgICBjb25zb2xlLmxvZyhcIlBPU1Qgb3V0OiBcIiwgc29sYWpzb25vdXQpO1xuXG5cbiAgICB6cGFyYW1zLmFsbFZhcnMgPSB2YWx1ZUtleS5zbGljZSgxMCwgMjUpOyAvLyB0aGlzIGlzIGJlY2F1c2UgdGhlIFVSTCBpcyB0b28gbG9uZy4uLlxuICAgIHZhciBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoenBhcmFtcyk7XG4gICAgLy92YXIgc2VsZWN0b3JCYXNlID0gcmFwcFVSTCtcInNlbGVjdG9yYXBwP3NvbGFKU09OPVwiO1xuICAgIHZhciBzZWxlY3RvcnVybGNhbGwgPSByYXBwVVJMICsgXCJzZWxlY3RvcmFwcFwiOyAvLy5jb25jYXQoanNvbm91dCk7XG5cbiAgICBmdW5jdGlvbiBlc3RpbWF0ZVN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpOyAvLyBzdG9wIHNwaW5uZXJcbiAgICAgICAgYWxsUmVzdWx0cy5wdXNoKGpzb24pO1xuICAgICAgICBjb25zb2xlLmxvZyhhbGxSZXN1bHRzKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJqc29uIGluOiBcIiwganNvbik7XG5cbiAgICAgICAgdmFyIG15cGFyZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXN1bHRzXCIpO1xuICAgICAgICBpZiAoZXN0aW1hdGVkID09IGZhbHNlKSB7XG4gICAgICAgICAgICBteXBhcmVudC5yZW1vdmVDaGlsZChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlc3VsdHNIb2xkZXJcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXN0aW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNcIilcbiAgICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcblxuICAgICAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1ZpZXdcIilcbiAgICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcblxuICAgICAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cblxuICAgICAgICAvLyBwcm9ncmFtbWF0aWMgY2xpY2sgb24gUmVzdWx0cyBidXR0b25cbiAgICAgICAgJChcIiNidG5SZXN1bHRzXCIpLnRyaWdnZXIoXCJjbGlja1wiKTtcblxuXG4gICAgICAgIG1vZGVsQ291bnQgPSBtb2RlbENvdW50ICsgMTtcbiAgICAgICAgdmFyIG1vZGVsID0gXCJNb2RlbFwiLmNvbmNhdChtb2RlbENvdW50KTtcblxuICAgICAgICBmdW5jdGlvbiBtb2RDb2woKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEodmFyQ29sb3IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZENvbCgpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgICAgIC5pbnNlcnQoXCJwXCIsIFwiOmZpcnN0LWNoaWxkXCIpIC8vIHRvcCBzdGFjayBmb3IgcmVzdWx0c1xuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBtb2RlbClcbiAgICAgICAgICAgIC50ZXh0KG1vZGVsKVxuICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHNlbFZhckNvbG9yKSlcbiAgICAgICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IucmVwbGFjZSgvXFxzKi9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGhleFRvUmdiYShzZWxWYXJDb2xvcikucmVwbGFjZSgvXFxzKi9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoYS5zdWJzdHIoMCwgMTcpID09PSBiLnN1YnN0cigwLCAxNykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvL2VzY2FwZXMgdGhlIGZ1bmN0aW9uIGVhcmx5IGlmIHRoZSBkaXNwbGF5ZWQgbW9kZWwgaXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RDb2woKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHNlbFZhckNvbG9yKSk7XG4gICAgICAgICAgICAgICAgdml6KHRoaXMuaWQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJDYWxsID0gW107XG4gICAgICAgIHJDYWxsWzBdID0ganNvbi5jYWxsO1xuICAgICAgICBsb2dBcnJheS5wdXNoKFwiZXN0aW1hdGU6IFwiLmNvbmNhdChyQ2FsbFswXSkpO1xuICAgICAgICBzaG93TG9nKCk7XG5cbiAgICAgICAgdml6KG1vZGVsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc3RpbWF0ZUZhaWwoYnRuKSB7XG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpOyAvLyBzdG9wIHNwaW5uZXJcbiAgICAgICAgZXN0aW1hdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWxlY3RvclN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAgIGQzLnNlbGVjdChcIiN0aWNrZXJcIilcbiAgICAgICAgICAgIC50ZXh0KFwiU3VnZ2VzdGVkIHZhcmlhYmxlcyBhbmQgcGVyY2VudCBpbXByb3ZlbWVudCBvbiBSTVNFOiBcIiArIGpzb24udmFycyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic2VsZWN0b3JTdWNjZXNzOiBcIiwganNvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZWN0b3JGYWlsKGJ0bikge1xuICAgICAgICBhbGVydChcIlNlbGVjdG9yIEZhaWxcIik7XG4gICAgfVxuXG4gICAgZXN0aW1hdGVMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBzcGlubmVyXG4gICAgbWFrZUNvcnNSZXF1ZXN0KHVybGNhbGwsIGJ0biwgZXN0aW1hdGVTdWNjZXNzLCBlc3RpbWF0ZUZhaWwsIHNvbGFqc29ub3V0KTtcbn1cblxuXG5mdW5jdGlvbiBkYXRhRG93bmxvYWQoKSB7XG4gICAgelBvcCgpO1xuICAgIC8vIHdyaXRlIGxpbmtzIHRvIGZpbGUgJiBydW4gUiBDTURcblxuICAgIC8vcGFja2FnZSB0aGUgb3V0cHV0IGFzIEpTT05cbiAgICAvLyBhZGQgY2FsbCBoaXN0b3J5IGFuZCBwYWNrYWdlIHRoZSB6cGFyYW1zIG9iamVjdCBhcyBKU09OXG4gICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh6cGFyYW1zKTtcbiAgICB2YXIgYnRuID0gXCJub2J1dHRvblwiO1xuXG4gICAgLy92YXIgYmFzZSA9IHJhcHBVUkwrXCJ6ZWxpZ2FwcD9zb2xhSlNPTj1cIlxuICAgIHVybGNhbGwgPSByYXBwVVJMICsgXCJkYXRhYXBwXCI7IC8vYmFzZS5jb25jYXQoanNvbm91dCk7XG4gICAgdmFyIHNvbGFqc29ub3V0ID0gXCJzb2xhSlNPTj1cIiArIGpzb25vdXQ7XG4gICAgY29uc29sZS5sb2coXCJ1cmxjYWxsIG91dDogXCIsIHVybGNhbGwpO1xuICAgIGNvbnNvbGUubG9nKFwiUE9TVCBvdXQ6IFwiLCBzb2xhanNvbm91dCk7XG5cbiAgICBmdW5jdGlvbiBkb3dubG9hZFN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZGF0YURvd25sb2FkIGpzb24gaW46IFwiLCBqc29uKTtcbiAgICAgICAgenBhcmFtcy56c2Vzc2lvbmlkID0ganNvbi5zZXNzaW9uaWRbMF07XG5cbiAgICAgICAgLy8gc2V0IHRoZSBsaW5rIFVSTFxuICAgICAgICBpZiAocHJvZHVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGxvZ1VSTCA9IHJhcHBVUkwgKyBcImxvZ19kaXIvbG9nX1wiICsgenBhcmFtcy56c2Vzc2lvbmlkICsgXCIudHh0XCI7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxvZ0lEXCIpLmhyZWYgPSBsb2dVUkw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbG9nVVJMID0gXCJyb29rL2xvZ19cIiArIHpwYXJhbXMuenNlc3Npb25pZCArIFwiLnR4dFwiO1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsb2dJRFwiKS5ocmVmID0gbG9nVVJMO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb3dubG9hZEZhaWwoYnRuKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRGF0YSBoYXZlIG5vdCBiZWVuIGRvd25sb2FkZWRcIik7XG4gICAgfVxuXG4gICAgbWFrZUNvcnNSZXF1ZXN0KHVybGNhbGwsIGJ0biwgZG93bmxvYWRTdWNjZXNzLCBkb3dubG9hZEZhaWwsIHNvbGFqc29ub3V0KTtcbn1cblxuZnVuY3Rpb24gdml6KG0pIHtcbiAgICB2YXIgbXltID0gK20uc3Vic3RyKDUsIDUpIC0gMTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUtpZHMocGFyZW50KSB7XG4gICAgICAgIHdoaWxlIChwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHBhcmVudC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBteXBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVzdWx0c1ZpZXdcIik7XG4gICAgcmVtb3ZlS2lkcyhteXBhcmVudCk7XG5cbiAgICB2YXIganNvbiA9IGFsbFJlc3VsdHNbbXltXTtcblxuICAgIC8vIHBpcGUgaW4gZmlndXJlcyB0byByaWdodCBwYW5lbFxuICAgIHZhciBmaWxlbGlzdCA9IG5ldyBBcnJheTtcbiAgICBmb3IgKHZhciBpIGluIGpzb24uaW1hZ2VzKSB7XG4gICAgICAgIHZhciB6ZmlnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgemZpZy5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwganNvbi5pbWFnZXNbaV0pO1xuICAgICAgICB6ZmlnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAyMDApO1xuICAgICAgICB6ZmlnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMjAwKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXN1bHRzVmlld1wiKS5hcHBlbmRDaGlsZCh6ZmlnKTtcbiAgICB9XG5cbiAgICAvLyB3cml0ZSB0aGUgcmVzdWx0cyB0YWJsZVxuICAgIHZhciByZXN1bHRzQXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4ganNvbi5zdW1JbmZvKSB7XG4gICAgICAgIGlmIChrZXkgPT0gXCJjb2xuYW1lc1wiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGpzb24uc3VtSW5mb1trZXldO1xuICAgICAgICByZXN1bHRzQXJyYXkucHVzaChvYmopO1xuICAgICAgICAvKiBTTyBzYXlzIHRoaXMgaXMgaW1wb3J0YW50IGNoZWNrLCBidXQgSSBkb24ndCBzZWUgaG93IGl0IGhlbHBzIGhlcmUuLi5cbiAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAvLyBpbXBvcnRhbnQgY2hlY2sgdGhhdCB0aGlzIGlzIG9iamVjdHMgb3duIHByb3BlcnR5XG4gICAgICAgICAvLyBub3QgZnJvbSBwcm90b3R5cGUgcHJvcCBpbmhlcml0ZWRcbiAgICAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSl7XG4gICAgICAgICBhbGVydChwcm9wICsgXCIgPSBcIiArIG9ialtwcm9wXSk7XG4gICAgICAgICB9XG4gICAgICAgICB9ICAqL1xuICAgIH1cblxuICAgIHZhciB0YWJsZSA9IGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld1wiKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXBwZW5kKFwidGFibGVcIik7XG5cbiAgICB2YXIgdGhlYWQgPSB0YWJsZS5hcHBlbmQoXCJ0aGVhZFwiKTtcbiAgICB0aGVhZC5hcHBlbmQoXCJ0clwiKVxuICAgICAgICAuc2VsZWN0QWxsKFwidGhcIilcbiAgICAgICAgLmRhdGEoanNvbi5zdW1JbmZvLmNvbG5hbWVzKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwidGhcIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0pO1xuXG4gICAgdmFyIHRib2R5ID0gdGFibGUuYXBwZW5kKFwidGJvZHlcIik7XG4gICAgdGJvZHkuc2VsZWN0QWxsKFwidHJcIilcbiAgICAgICAgLmRhdGEocmVzdWx0c0FycmF5KVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJ0clwiKVxuICAgICAgICAuc2VsZWN0QWxsKFwidGRcIilcbiAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0pXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcInRkXCIpXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciBteU51bSA9IE51bWJlcihkKTtcbiAgICAgICAgICAgIGlmIChpc05hTihteU51bSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBteU51bS50b1ByZWNpc2lvbigzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcImFsaWNlYmx1ZVwiKVxuICAgICAgICB9KSAvLyBmb3Igbm8gZGlzY2VybmFibGUgcmVhc29uXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiNGOUY5RjlcIilcbiAgICAgICAgfSk7IC8vKGJ1dCBtYXliZSB3ZSdsbCB0aGluayBvZiBvbmUpXG5cbiAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1ZpZXdcIilcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLmh0bWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gXCI8Yj5Gb3JtdWxhOiA8L2I+XCIuY29uY2F0KGpzb24uY2FsbFswXSk7XG4gICAgICAgIH0pO1xufVxuXG4vLyB0aGlzIGZ1bmN0aW9uIHBhcnNlcyB0aGUgdHJhbnNmb3JtYXRpb24gaW5wdXQuIHZhcmlhYmxlIG5hbWVzIGFyZSBvZnRlbiBuZXN0ZWQgaW5zaWRlIG9uZSBhbm90aGVyLCBlLmcuLCBldGh3YXIsIHdhciwgd2FycywgYW5kIHNvIHRoaXMgaXMgaGFuZGxlZFxuZnVuY3Rpb24gdHJhbnNQYXJzZShuKSB7XG4gICAgdmFyIG91dDIgPSBbXTtcbiAgICB2YXIgdDIgPSBuO1xuICAgIHZhciBrMiA9IDA7XG4gICAgdmFyIHN1Yk1lMiA9IFwiX3RyYW5zdmFyXCIuY29uY2F0KGsyKTtcbiAgICB2YXIgaW5kZXhlZCA9IFtdO1xuXG4gICAgLy8gb3V0MiBpcyBhbGwgbWF0Y2hlZCB2YXJpYWJsZXMsIGluZGV4ZWQgaXMgYW4gYXJyYXksIGVhY2ggZWxlbWVudCBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbWF0Y2hlZCB2YXJpYWJsZXMgc3RhcnRpbmcgaW5kZXggYW5kIGZpbmlzaGluZyBpbmRleC4gIGUuZy4sIG49XCJ3YXJzKzJcIiwgb3V0Mj1bd2FyLCB3YXJzXSwgaW5kZXhlZD1bezAsMn0sezAsM31dXG4gICAgZm9yICh2YXIgaSBpbiB2YWx1ZUtleSkge1xuICAgICAgICB2YXIgbTIgPSBuLm1hdGNoKHZhbHVlS2V5W2ldKTtcbiAgICAgICAgaWYgKG0yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvdXQyLnB1c2gobTJbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cCh2YWx1ZUtleVtpXSwgXCJnXCIpXG4gICAgICAgIHZhciBzID0gbi5zZWFyY2gocmUpO1xuICAgICAgICBpZiAocyAhPSAtMSkge1xuICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBmcm9tOiBzLFxuICAgICAgICAgICAgICAgIHRvOiBzICsgdmFsdWVLZXlbaV0ubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5lc3RlZCBsb29wIG5vdCBnb29kLCBidXQgaW5kZXhlZCBpcyBub3QgbGlrZWx5IHRvIGJlIHZlcnkgbGFyZ2UuXG4gICAgLy8gaWYgYSB2YXJpYWJsZSBpcyBuZXN0ZWQsIGl0IGlzIHJlbW92ZWQgZnJvbSBvdXQyXG4gICAgLy8gbm90aWNlLCBsb29wIGlzIGJhY2t3YXJkcyBzbyB0aGF0IGluZGV4IGNoYW5nZXMgZG9uJ3QgYWZmZWN0IHRoZSBzcGxpY2VcbiAgICBjb25zb2xlLmxvZyhcImluZGV4ZWQgXCIsIGluZGV4ZWQpO1xuICAgIGZvciAodmFyIGkgPSBpbmRleGVkLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBpbmRleGVkLmxlbmd0aCAtIDE7IGogPiAtMTsgai0tKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpbmRleGVkW2ldLmZyb20gPj0gaW5kZXhlZFtqXS5mcm9tKSAmIChpbmRleGVkW2ldLnRvIDw9IGluZGV4ZWRbal0udG8pKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coaSwgXCIgaXMgbmVzdGVkIGluIFwiLCBqKTtcbiAgICAgICAgICAgICAgICBvdXQyLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgaW4gb3V0Mikge1xuICAgICAgICB0MiA9IHQyLnJlcGxhY2Uob3V0MltpXSwgc3ViTWUyKTsgLy9zb21ldGhpbmcgdGhhdCdsbCBuZXZlciBiZSBhIHZhcmlhYmxlIG5hbWVcbiAgICAgICAgazIgPSBrMiArIDE7XG4gICAgICAgIHN1Yk1lMiA9IFwiX3RyYW5zdmFyXCIuY29uY2F0KGsyKTtcbiAgICB9XG5cbiAgICBpZiAob3V0Mi5sZW5ndGggPiAwKSB7XG4gICAgICAgIG91dDIucHVzaCh0Mik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibmV3IG91dCBcIiwgb3V0Mik7XG4gICAgICAgIHJldHVybiAob3V0Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWxlcnQoXCJObyB2YXJpYWJsZSBuYW1lIGZvdW5kLiBQZXJoYXBzIGNoZWNrIHlvdXIgc3BlbGxpbmc/XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShuLCB0LCB0eXBlVHJhbnNmb3JtKSB7XG4gICAgaWYgKHByb2R1Y3Rpb24gJiYgenBhcmFtcy56c2Vzc2lvbmlkID09IFwiXCIpIHtcbiAgICAgICAgYWxlcnQoXCJXYXJuaW5nOiBEYXRhIGRvd25sb2FkIGlzIG5vdCBjb21wbGV0ZS4gVHJ5IGFnYWluIHNvb24uXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlVHJhbnNmb3JtKSB7XG4gICAgICAgIHQgPSB0LnJlcGxhY2UoXCIrXCIsIFwiX3BsdXNfXCIpOyAvLyBjYW4ndCBzZW5kIHRoZSBwbHVzIG9wZXJhdG9yXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2cobik7XG4gICAgY29uc29sZS5sb2codCk7XG5cbiAgICB2YXIgYnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bkVzdGltYXRlJyk7XG5cbiAgICB2YXIgbXluID0gYWxsTm9kZXNbZmluZE5vZGVJbmRleChuWzBdKV07XG4gICAgaWYgKHR5cGVvZiBteW4gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIG15biA9IGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgobildO1xuICAgIH1cblxuICAgIHZhciBvdXR0eXBlcyA9IHtcbiAgICAgICAgdmFybmFtZXNUeXBlczogbixcbiAgICAgICAgaW50ZXJ2YWw6IG15bi5pbnRlcnZhbCxcbiAgICAgICAgbnVtY2hhcjogbXluLm51bWNoYXIsXG4gICAgICAgIG5hdHVyZTogbXluLm5hdHVyZSxcbiAgICAgICAgYmluYXJ5OiBteW4uYmluYXJ5XG4gICAgfTtcblxuICAgIGNvbnNvbGUubG9nKG15bik7XG4gICAgLy8gaWYgdHlwZVRyYW5zZm9ybSBidXQgd2UgYWxyZWFkeSBoYXZlIHRoZSBtZXRhZGF0YVxuICAgIGlmICh0eXBlVHJhbnNmb3JtKSB7XG4gICAgICAgIGlmIChteW4ubmF0dXJlID09IFwibm9taW5hbFwiICYgdHlwZW9mIG15bi5wbG90dmFsdWVzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBteW4ucGxvdHR5cGUgPSBcImJhclwiO1xuICAgICAgICAgICAgYmFyc05vZGUobXluKTtcbiAgICAgICAgICAgIHBvcHVsYXRlUG9wb3ZlcigpO1xuICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKG15bi5uYXR1cmUgIT0gXCJub21pbmFsXCIgJiB0eXBlb2YgbXluLnBsb3R4ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBteW4ucGxvdHR5cGUgPSBcImNvbnRpbnVvdXNcIjtcbiAgICAgICAgICAgIGRlbnNpdHlOb2RlKG15bik7XG4gICAgICAgICAgICBwb3B1bGF0ZVBvcG92ZXIoKTtcbiAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vcGFja2FnZSB0aGUgb3V0cHV0IGFzIEpTT05cbiAgICB2YXIgdHJhbnNmb3Jtc3R1ZmYgPSB7XG4gICAgICAgIHpkYXRhdXJsOiBkYXRhdXJsLFxuICAgICAgICB6dmFyczogbixcbiAgICAgICAgenNlc3Npb25pZDogenBhcmFtcy56c2Vzc2lvbmlkLFxuICAgICAgICB0cmFuc2Zvcm06IHQsXG4gICAgICAgIGNhbGxIaXN0b3J5OiBjYWxsSGlzdG9yeSxcbiAgICAgICAgdHlwZVRyYW5zZm9ybTogdHlwZVRyYW5zZm9ybSxcbiAgICAgICAgdHlwZVN0dWZmOiBvdXR0eXBlc1xuICAgIH07XG4gICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1zdHVmZik7XG4gICAgLy92YXIgYmFzZSA9IHJhcHBVUkwrXCJ0cmFuc2Zvcm1hcHA/c29sYUpTT049XCJcblxuICAgIHVybGNhbGwgPSByYXBwVVJMICsgXCJ0cmFuc2Zvcm1hcHBcIjsgLy9iYXNlLmNvbmNhdChqc29ub3V0KTtcbiAgICB2YXIgc29sYWpzb25vdXQgPSBcInNvbGFKU09OPVwiICsganNvbm91dDtcbiAgICBjb25zb2xlLmxvZyhcInVybGNhbGwgb3V0OiBcIiwgdXJsY2FsbCk7XG4gICAgY29uc29sZS5sb2coXCJQT1NUIG91dDogXCIsIHNvbGFqc29ub3V0KTtcblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImpzb24gaW46IFwiLCBqc29uKTtcblxuICAgICAgICBpZiAoanNvbi50eXBlVHJhbnNmb3JtWzBdKSB7XG5cbiAgICAgICAgICAgIGQzLmpzb24oanNvbi51cmwsIGZ1bmN0aW9uKGVycm9yLCBqc29uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgICAgICAgICAgICB2YXIganNvbmRhdGEgPSBqc29uO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGpzb25kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBteUluZGV4ID0gZmluZE5vZGVJbmRleChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIGFsbE5vZGVzW215SW5kZXhdLCBqc29uZGF0YVtrZXldKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsTm9kZXNbbXlJbmRleF0ucGxvdHR5cGUgPT09IFwiY29udGludW91c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5zaXR5Tm9kZShhbGxOb2Rlc1tteUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXNbbXlJbmRleF0ucGxvdHR5cGUgPT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcnNOb2RlKGFsbE5vZGVzW215SW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZha2VDbGljaygpO1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlUG9wb3ZlcigpO1xuICAgICAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhhbGxOb2Rlc1tteUluZGV4XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxIaXN0b3J5LnB1c2goe1xuICAgICAgICAgICAgICAgIGZ1bmM6IFwidHJhbnNmb3JtXCIsXG4gICAgICAgICAgICAgICAgenZhcnM6IG4sXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHN1YnNldGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgckNhbGwgPSBbXTtcbiAgICAgICAgICAgIHJDYWxsWzBdID0ganNvbi5jYWxsO1xuICAgICAgICAgICAgdmFyIG5ld1ZhciA9IHJDYWxsWzBdWzBdO1xuICAgICAgICAgICAgdHJhbnMucHVzaChuZXdWYXIpO1xuXG4gICAgICAgICAgICBkMy5qc29uKGpzb24udXJsLCBmdW5jdGlvbihlcnJvciwganNvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgICAgICAgICAgdmFyIGpzb25kYXRhID0ganNvbjtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBqc29uZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXlJbmRleCA9IGZpbmROb2RlSW5kZXgoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBteUluZGV4ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChcIkludmFsaWQgdHJhbnNmb3JtYXRpb246IHRoaXMgdmFyaWFibGUgbmFtZSBhbHJlYWR5IGV4aXN0cy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRyYW5zZm9ybWVkIHZhcmlhYmxlIHRvIHRoZSBjdXJyZW50IHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gYWxsTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqMSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmbGV4aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxhYmxcIjogXCJ0cmFuc2Zvcm1sYWJlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogWzUsIDE1LCAyMCwgMCwgNSwgMTUsIDIwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBbLjYsIC4yLCAuOSwgLjgsIC4xLCAuMywgLjRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJub2RlQ29sXCI6IGNvbG9ycyhpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFzZUNvbFwiOiBjb2xvcnMoaSksXG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cm9rZUNvbG9yXCI6IHNlbFZhckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VXaWR0aFwiOiBcIjFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3Vic2V0cGxvdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3Vic2V0cmFuZ2VcIjogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzZXR4cGxvdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic2V0eHZhbHNcIjogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJncmF5b3V0XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkZWZhdWx0SW50ZXJ2YWxcIjoganNvbmRhdGFba2V5XVtcImludGVydmFsXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkZWZhdWx0TnVtY2hhclwiOiBqc29uZGF0YVtrZXldW1wibnVtY2hhclwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVmYXVsdE5hdHVyZVwiOiBqc29uZGF0YVtrZXldW1wibmF0dXJlXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkZWZhdWx0QmluYXJ5XCI6IGpzb25kYXRhW2tleV1bXCJiaW5hcnlcIl1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIG9iajEsIGpzb25kYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICBhbGxOb2Rlcy5wdXNoKG9iajEpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNjYWZmb2xkaW5nUHVzaChyQ2FsbFswXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlS2V5LnB1c2gobmV3VmFyKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChhbGxOb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGZha2VDbGljaygpO1xuICAgICAgICAgICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbE5vZGVzW2ldLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVuc2l0eU5vZGUoYWxsTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFsbE5vZGVzW2ldLnBsb3R0eXBlID09PSBcImJhclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJzTm9kZShhbGxOb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vZm9yXG5cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgbG9nXG4gICAgICAgICAgICBsb2dBcnJheS5wdXNoKFwidHJhbnNmb3JtOiBcIi5jb25jYXQockNhbGxbMF0pKTtcbiAgICAgICAgICAgIHNob3dMb2coKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUZhaWwoYnRuKSB7XG4gICAgICAgIGFsZXJ0KFwidHJhbnNmb3JtIGZhaWxcIik7XG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpO1xuICAgIH1cblxuICAgIGVzdGltYXRlTGFkZGEuc3RhcnQoKTsgLy8gc3RhcnQgc3Bpbm5lclxuICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBidG4sIHRyYW5zZm9ybVN1Y2Nlc3MsIHRyYW5zZm9ybUZhaWwsIHNvbGFqc29ub3V0KTtcbn1cblxuZnVuY3Rpb24gc2NhZmZvbGRpbmdQdXNoKHYpIHsgLy8gYWRkaW5nIGEgdmFyaWFibGUgdG8gdGhlIHZhcmlhYmxlIGxpc3QgYWZ0ZXIgYSB0cmFuc2Zvcm1hdGlvblxuICAgIGQzLnNlbGVjdChcIiN0YWIxXCIpXG4gICAgICAgIC5kYXRhKHYpXG4gICAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdlswXS5yZXBsYWNlKC9cXFcvZywgXCJfXCIpO1xuICAgICAgICB9KVxuICAgICAgICAudGV4dCh2WzBdKVxuICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpKVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGFpbmVyXCIsIFwiYm9keVwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdG9nZ2xlXCIsIFwicG9wb3ZlclwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdHJpZ2dlclwiLCBcImhvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1wbGFjZW1lbnRcIiwgXCJyaWdodFwiKVxuICAgICAgICAuYXR0cihcImRhdGEtaHRtbFwiLCBcInRydWVcIilcbiAgICAgICAgLmF0dHIoXCJvbm1vdXNlb3ZlclwiLCBcIiQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW91dFwiLCBcIiQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiLCBcIlN1bW1hcnkgU3RhdGlzdGljc1wiKVxuICAgICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbiB2YXJDbGljaygpIHsgLy8gd2UndmUgYWRkZWQgYSBuZXcgdmFyaWFibGUsIHNvIHdlIG5lZWQgdG8gYWRkIHRoZSBsaXN0ZW5lclxuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXlUZXh0ID0gZDMuc2VsZWN0KHRoaXMpLnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG15Q29sb3IgPSBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG15U0MgPSBhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KG15VGV4dCldLnN0cm9rZUNvbG9yO1xuXG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuenZhcnMgPSBbXTsgLy9lbXB0eSB0aGUgenZhcnMgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQzLnJnYihteUNvbG9yKS50b1N0cmluZygpID09PSB2YXJDb2xvci50b1N0cmluZygpKSB7IC8vIHdlIGFyZSBhZGRpbmcgYSB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goZmluZE5vZGUobXlUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbMF0ucmVmbGV4aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChmaW5kTm9kZShteVRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBkcm9wcGluZyBhIHZhcmlhYmxlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShmaW5kTm9kZShteVRleHQpW1wiaW5kZXhcIl0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaWNlTGlua3NGb3JOb2RlKGZpbmROb2RlKG15VGV4dCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXlTQyA9PSBkdkNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR2SW5kZXggPSB6cGFyYW1zLnpkdi5pbmRleE9mKG15VGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR2SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpkdi5zcGxpY2UoZHZJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChteVNDID09IGNzQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3NJbmRleCA9IHpwYXJhbXMuemNyb3NzLmluZGV4T2YobXlUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3NJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuemNyb3NzLnNwbGljZShjc0luZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG15U0MgPT0gdGltZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVJbmRleCA9IHpwYXJhbXMuenRpbWUuaW5kZXhPZihteVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnp0aW1lLnNwbGljZShkdkluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG15U0MgPT0gbm9tQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9tSW5kZXggPSB6cGFyYW1zLnpub20uaW5kZXhPZihteVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub21JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuem5vbS5zcGxpY2UoZHZJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlUmVzZXQoYWxsTm9kZXNbZmluZE5vZGVJbmRleChteVRleHQpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmYWtlQ2xpY2soKTtcbiAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgfSk7XG4gICAgcG9wdWxhdGVQb3BvdmVyKCk7IC8vIHBpcGVzIGluIHRoZSBzdW1tYXJ5IHN0YXRzXG5cbiAgICAvLyBkcm9wIGRvd24gbWVudSBmb3IgdHJhbmZvcm1hdGlvbiB0b29sYmFyXG4gICAgZDMuc2VsZWN0KFwiI3RyYW5zU2VsXCIpXG4gICAgICAgIC5kYXRhKHYpXG4gICAgICAgIC5hcHBlbmQoXCJvcHRpb25cIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0pO1xufVxuXG4vLyBiZWxvdyBmcm9tIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NvcnMvIGZvciBjcm9zcy1vcmlnaW4gcmVzb3VyY2Ugc2hhcmluZ1xuLy8gQ3JlYXRlIHRoZSBYSFIgb2JqZWN0LlxuZnVuY3Rpb24gY3JlYXRlQ09SU1JlcXVlc3QobWV0aG9kLCB1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIGlmIChcIndpdGhDcmVkZW50aWFsc1wiIGluIHhocikge1xuICAgICAgICAvLyBYSFIgZm9yIENocm9tZS9GaXJlZm94L09wZXJhL1NhZmFyaS5cbiAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIFhEb21haW5SZXF1ZXN0ICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gWERvbWFpblJlcXVlc3QgZm9yIElFLlxuICAgICAgICB4aHIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENPUlMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgeGhyID0gbnVsbDtcbiAgICB9XG4gICAgLy8gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3BsYWluJyk7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICByZXR1cm4geGhyO1xufVxuXG4vLyBNYWtlIHRoZSBhY3R1YWwgQ09SUyByZXF1ZXN0LlxuZnVuY3Rpb24gbWFrZUNvcnNSZXF1ZXN0KHVybCwgYnRuLCBjYWxsYmFjaywgd2FybmluZ2NhbGxiYWNrLCBqc29uc3RyaW5nKSB7XG4gICAgdmFyIHhociA9IGNyZWF0ZUNPUlNSZXF1ZXN0KCdQT1NUJywgdXJsKTtcbiAgICBpZiAoIXhocikge1xuICAgICAgICBhbGVydCgnQ09SUyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVzcG9uc2UgaGFuZGxlcnMgZm9yIGFzeW5jaHJvbm91cyBsb2FkXG4gICAgLy8gb25sb2FkIG9yIG9ucmVhZHlzdGF0ZWNoYW5nZT9cblxuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRleHQgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICBjb25zb2xlLmxvZyhcInRleHQgXCIsIHRleHQpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIganNvbiA9IEpTT04ucGFyc2UodGV4dCk7IC8vIHNob3VsZCB3cmFwIGluIHRyeSAvIGNhdGNoXG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhqc29uKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0b3AoKTtcbiAgICAgICAgICAgIHNlbGVjdExhZGRhLnN0b3AoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICBhbGVydCgnRXJyb3I6IENvdWxkIG5vdCBwYXJzZSBpbmNvbWluZyBKU09OLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWVzWzBdID09IFwid2FybmluZ1wiKSB7XG4gICAgICAgICAgICB3YXJuaW5nY2FsbGJhY2soYnRuKTtcbiAgICAgICAgICAgIGFsZXJ0KFwiV2FybmluZzogXCIgKyBqc29uLndhcm5pbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soYnRuLCBqc29uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gbm90ZTogeGhyLnJlYWR5c3RhdGUgc2hvdWxkIGJlIDQsIGFuZCBzdGF0dXMgc2hvdWxkIGJlIDIwMC4gIGEgc3RhdHVzIG9mIDAgb2NjdXJzIHdoZW4gdGhlIHVybCBiZWNvbWVzIHRvbyBsYXJnZVxuICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSAwKSB7XG4gICAgICAgICAgICBhbGVydCgnVGhlcmUgd2FzIGFuIGVycm9yIG1ha2luZyB0aGUgcmVxdWVzdC4geG1saHR0cHJlcXVlc3Qgc3RhdHVzIGlzIDAuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoeGhyLnJlYWR5U3RhdGUgIT0gNCkge1xuICAgICAgICAgICAgYWxlcnQoJ1RoZXJlIHdhcyBhbiBlcnJvciBtYWtpbmcgdGhlIHJlcXVlc3QuIHhtbGh0dHByZXF1ZXN0IHJlYWR5c3RhdGUgaXMgbm90IDQuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGVydCgnV29vcHMsIHRoZXJlIHdhcyBhbiBlcnJvciBtYWtpbmcgdGhlIHJlcXVlc3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coeGhyKTtcbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgICAgIHNlbGVjdExhZGRhLnN0b3AoKTtcbiAgICB9O1xuICAgIHhoci5zZW5kKGpzb25zdHJpbmcpO1xufVxuXG5mdW5jdGlvbiBsZWdlbmQoYykgeyAvLyB0aGlzIGNvdWxkIGJlIG1hZGUgc21hcnRlclxuICAgIGlmICh6cGFyYW1zLnp0aW1lLmxlbmd0aCAhPSAwIHwgenBhcmFtcy56Y3Jvc3MubGVuZ3RoICE9IDAgfCB6cGFyYW1zLnpkdi5sZW5ndGggIT0gMCB8IHpwYXJhbXMuem5vbS5sZW5ndGggIT0gMCkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxlZ2VuZFwiKS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6YmxvY2tcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsZWdlbmRcIikuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJkaXNwbGF5Om5vbmVcIik7XG4gICAgfVxuXG4gICAgaWYgKHpwYXJhbXMuenRpbWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0aW1lQnV0dG9uXCIpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiY2xlYXJmaXggaGlkZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRpbWVCdXR0b25cIikuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJjbGVhcmZpeCBzaG93XCIpO1xuICAgIH1cbiAgICBpZiAoenBhcmFtcy56Y3Jvc3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjc0J1dHRvblwiKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImNsZWFyZml4IGhpZGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjc0J1dHRvblwiKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImNsZWFyZml4IHNob3dcIik7XG4gICAgfVxuICAgIGlmICh6cGFyYW1zLnpkdi5sZW5ndGggPT0gMCkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImR2QnV0dG9uXCIpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiY2xlYXJmaXggaGlkZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImR2QnV0dG9uXCIpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiY2xlYXJmaXggc2hvd1wiKTtcbiAgICB9XG4gICAgaWYgKHpwYXJhbXMuem5vbS5sZW5ndGggPT0gMCkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5vbUJ1dHRvblwiKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImNsZWFyZml4IGhpZGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJub21CdXR0b25cIikuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJjbGVhcmZpeCBzaG93XCIpO1xuICAgIH1cblxuICAgIGJvcmRlclN0YXRlKCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xufVxuXG4vLyBwcm9ncmFtbWF0aWNhbGx5IGRlc2VsZWN0aW5nIGV2ZXJ5IHNlbGVjdGVkIHZhcmlhYmxlLi4uXG5mdW5jdGlvbiBlcmFzZSgpIHtcbiAgICBsZWZ0cGFuZWxNZWRpdW0oKTtcbiAgICByaWdodHBhbmVsTWVkaXVtKCk7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsZWdlbmRcIikuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJkaXNwbGF5Om5vbmVcIik7XG5cbiAgICB0YWJMZWZ0KCd0YWIxJyk7XG5cbiAgICBqUXVlcnkuZm4uZDNDbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihpLCBlKSB7XG4gICAgICAgICAgICB2YXIgbXljb2wgPSBkMy5yZ2IodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAgICAgaWYgKG15Y29sLnRvU3RyaW5nKCkgPT09IHZhckNvbG9yLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcbiAgICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChcImNsaWNrXCIsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXG4gICAgICAgICAgICBlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAkKFwiI3RhYjFcIikuZDNDbGljaygpO1xufVxuXG5mdW5jdGlvbiBkZXNlbGVjdChkKSB7XG4gICAgY29uc29sZS5sb2coZCk7XG59XG5cbi8vIGh0dHA6Ly93d3cudHV0b3JpYWxzMmxlYXJuLmNvbS90dXRvcmlhbHMvc2NyaXB0cy9qYXZhc2NyaXB0L3htbC1wYXJzZXItamF2YXNjcmlwdC5odG1sXG5mdW5jdGlvbiBsb2FkWE1MRG9jKFhNTG5hbWUpIHtcbiAgICB2YXIgeG1sRG9jO1xuICAgIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgeG1sRG9jID0gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4bWxEb2Mub3BlbihcIkdFVFwiLCBYTUxuYW1lLCBmYWxzZSk7XG4gICAgICAgIHhtbERvYy5zZW5kKFwiXCIpO1xuICAgICAgICByZXR1cm4geG1sRG9jLnJlc3BvbnNlWE1MO1xuICAgIH1cbiAgICAvLyBJRSA1IGFuZCBJRSA2XG4gICAgZWxzZSBpZiAoQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIikpIHtcbiAgICAgICAgeG1sRG9jID0gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpO1xuICAgICAgICB4bWxEb2MuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgeG1sRG9jLmxvYWQoWE1MbmFtZSk7XG4gICAgICAgIHJldHVybiB4bWxEb2M7XG4gICAgfVxuICAgIGFsZXJ0KFwiRXJyb3IgbG9hZGluZyBkb2N1bWVudCFcIik7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cblxuZnVuY3Rpb24gdGFiTGVmdCh0YWIpIHtcblxuICAgIGlmICh0YWIgIT0gXCJ0YWIzXCIpIHtcbiAgICAgICAgbGVmdHRhYiA9IHRhYjtcbiAgICB9XG4gICAgdmFyIHRhYmkgPSB0YWIuc3Vic3RyaW5nKDMpO1xuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RhYjEnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0YWIyJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGFiMycpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICBpZiAodGFiID09PSBcInRhYjFcIikge1xuICAgICAgICBzdW1tYXJ5SG9sZCA9IGZhbHNlO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuU3Vic2V0Jykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5WYXJpYWJsZXMnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBhY3RpdmVcIik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnRuU2VsZWN0XCIpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI2xlZnRwYW5lbFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIik7XG4gICAgfSBlbHNlIGlmICh0YWIgPT09IFwidGFiMlwiKSB7XG4gICAgICAgIHN1bW1hcnlIb2xkID0gZmFsc2U7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5WYXJpYWJsZXMnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0blN1YnNldCcpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGFjdGl2ZVwiKTtcblxuICAgICAgICBkMy5zZWxlY3QoXCIjbGVmdHBhbmVsXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSA9PT0gXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4IGV4cGFuZHBhbmVsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJidG5TZWxlY3RcIikuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnRuU2VsZWN0XCIpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4IGV4cGFuZHBhbmVsXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0blN1YnNldCcpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuVmFyaWFibGVzJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYnRuLWRlZmF1bHRcIik7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI2xlZnRwYW5lbFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIik7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFiKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbn1cblxuZnVuY3Rpb24gdGFiUmlnaHQodGFiaWQpIHtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2RlbHMnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR4Jykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzdWx0cycpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICBpZiAodGFiaWQgPT0gXCJidG5Nb2RlbHNcIikge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuU2V0eCcpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuUmVzdWx0cycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuTW9kZWxzJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYWN0aXZlXCIpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kZWxzJykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI3JpZ2h0cGFuZWxcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCIpO1xuICAgIH0gZWxzZSBpZiAodGFiaWQgPT0gXCJidG5TZXR4XCIpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bk1vZGVscycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuUmVzdWx0cycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuU2V0eCcpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGFjdGl2ZVwiKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NldHgnKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgICBpZiAocmlnaHR0YWIgPT0gXCJidG5TZXR4XCIgfCBkMy5zZWxlY3QoXCIjcmlnaHRwYW5lbFwiKS5hdHRyKFwiY2xhc3NcIikgPT0gXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCIpIHtcbiAgICAgICAgICAgIHRvZ2dsZVIoKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGFiaWQgPT0gXCJidG5SZXN1bHRzXCIpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bk1vZGVscycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuU2V0eCcpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuUmVzdWx0cycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGFjdGl2ZVwiKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlc3VsdHMnKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgICBpZiAoZXN0aW1hdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3JpZ2h0cGFuZWxcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChyaWdodHRhYiA9PSBcImJ0blJlc3VsdHNcIiB8IGQzLnNlbGVjdChcIiNyaWdodHBhbmVsXCIpLmF0dHIoXCJjbGFzc1wiKSA9PSBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIikge1xuICAgICAgICAgICAgdG9nZ2xlUigpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmlnaHR0YWIgPSB0YWJpZDsgLy8gYSBnbG9iYWwgdGhhdCBtYXkgYmUgb2YgdXNlXG5cbiAgICBmdW5jdGlvbiB0b2dnbGVSKCkge1xuICAgICAgICBkMy5zZWxlY3QoXCIjcmlnaHRwYW5lbFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgPT09IFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeCBleHBhbmRwYW5lbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4IGV4cGFuZHBhbmVsXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIHZhclN1bW1hcnkoZCkge1xuXG4gICAgdmFyIHJpbnQgPSBkMy5mb3JtYXQoXCJyXCIpO1xuXG4gICAgdmFyIHN1bW1hcnlkYXRhID0gW10sXG4gICAgICAgIHRtcERhdGFzZXQgPSBbXSxcbiAgICAgICAgdDEgPSBbXCJNZWFuOlwiLCBcIk1lZGlhbjpcIiwgXCJNb3N0IEZyZXE6XCIsIFwiT2NjdXJyZW5jZXM6XCIsIFwiTWVkaWFuIEZyZXE6XCIsIFwiT2NjdXJyZW5jZXM6XCIsIFwiTGVhc3QgRnJlcTpcIiwgXCJPY2N1cnJlbmNlczpcIiwgXCJTdGFuZC5EZXY6XCIsIFwiTWluaW11bTpcIiwgXCJNYXhpbXVtOlwiLCBcIkludmFsaWQ6XCIsIFwiVmFsaWQ6XCIsIFwiVW5pcXVlczpcIiwgXCJIZXJmaW5kYWhsOlwiXSxcbiAgICAgICAgdDIgPSBbKCtkLm1lYW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCksICgrZC5tZWRpYW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCksIGQubW9kZSwgcmludChkLmZyZXFtb2RlKSwgZC5taWQsIHJpbnQoZC5mcmVxbWlkKSwgZC5mZXdlc3QsIHJpbnQoZC5mcmVxZmV3ZXN0KSwgKCtkLnNkKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpLCAoK2QubWluKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpLCAoK2QubWF4KS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpLCByaW50KGQuaW52YWxpZCksIHJpbnQoZC52YWxpZCksIHJpbnQoZC51bmlxdWVzKSwgKCtkLmhlcmZpbmRhaGwpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCldLFxuICAgICAgICBpLCBqO1xuICAgIGlmIChwcml2KSB7XG4gICAgICAgIGlmIChkLm1lYW5DSSkge1xuICAgICAgICAgICAgdDEgPSBbXCJNZWFuOlwiLCBcIk1lZGlhbjpcIiwgXCJNb3N0IEZyZXE6XCIsIFwiT2NjdXJyZW5jZXM6XCIsIFwiTWVkaWFuIEZyZXE6XCIsIFwiT2NjdXJyZW5jZXM6XCIsIFwiTGVhc3QgRnJlcTpcIiwgXCJPY2N1cnJlbmNlczpcIiwgXCJTdGFuZC5EZXY6XCIsIFwiTWluaW11bTpcIiwgXCJNYXhpbXVtOlwiLCBcIkludmFsaWQ6XCIsIFwiVmFsaWQ6XCIsIFwiVW5pcXVlczpcIiwgXCJIZXJmaW5kYWhsOlwiXSxcbiAgICAgICAgICAgICAgICB0MiA9IFsoK2QubWVhbikudG9QcmVjaXNpb24oMikudG9TdHJpbmcoKSArIFwiIChcIiArICgrZC5tZWFuQ0kubG93ZXJCb3VuZCkudG9QcmVjaXNpb24oMikudG9TdHJpbmcoKSArIFwiIC0gXCIgKyAoK2QubWVhbkNJLnVwcGVyQm91bmQpLnRvUHJlY2lzaW9uKDIpLnRvU3RyaW5nKCkgKyBcIilcIiwgKCtkLm1lZGlhbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSwgZC5tb2RlLCByaW50KGQuZnJlcW1vZGUpLCBkLm1pZCwgcmludChkLmZyZXFtaWQpLCBkLmZld2VzdCwgcmludChkLmZyZXFmZXdlc3QpLCAoK2Quc2QpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCksICgrZC5taW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCksICgrZC5tYXgpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCksIHJpbnQoZC5pbnZhbGlkKSwgcmludChkLnZhbGlkKSwgcmludChkLnVuaXF1ZXMpLCAoK2QuaGVyZmluZGFobCkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKV0sXG4gICAgICAgICAgICAgICAgaSwgajtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0MS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodDJbaV0uaW5kZXhPZihcIk5hTlwiKSA+IC0xIHwgdDJbaV0gPT0gXCJOQVwiIHwgdDJbaV0gPT0gXCJcIikgY29udGludWU7XG4gICAgICAgIHRtcERhdGFzZXQgPSBbXTtcbiAgICAgICAgdG1wRGF0YXNldC5wdXNoKHQxW2ldKTtcbiAgICAgICAgdG1wRGF0YXNldC5wdXNoKHQyW2ldKTtcbiAgICAgICAgc3VtbWFyeWRhdGEucHVzaCh0bXBEYXRhc2V0KTtcbiAgICB9O1xuXG4gICAgLy8gIGNvbnNvbGUubG9nKHN1bW1hcnlkYXRhKTtcbiAgICBkMy5zZWxlY3QoXCIjdGFiM1wiKSAvL3RhYiB3aGVuIHlvdSBtb3VzZW92ZXIgYSBwZWJibGVcbiAgICAgICAgLnNlbGVjdChcInBcIilcbiAgICAgICAgLmh0bWwoXCI8Y2VudGVyPjxiPlwiICsgZC5uYW1lICsgXCI8L2I+PGJyPjxpPlwiICsgZC5sYWJsICsgXCI8L2k+PC9jZW50ZXI+XCIpXG4gICAgICAgIC5hcHBlbmQoXCJ0YWJsZVwiKVxuICAgICAgICAuc2VsZWN0QWxsKFwidHJcIilcbiAgICAgICAgLmRhdGEoc3VtbWFyeWRhdGEpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcInRyXCIpXG4gICAgICAgIC5zZWxlY3RBbGwoXCJ0ZFwiKVxuICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSlcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidGRcIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgXCJhbGljZWJsdWVcIilcbiAgICAgICAgfSkgLy8gZm9yIG5vIGRpc2Nlcm5hYmxlIHJlYXNvblxuICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgXCIjRjlGOUY5XCIpXG4gICAgICAgIH0pOyAvLyhidXQgbWF5YmUgd2UnbGwgdGhpbmsgb2Ygb25lKVxuICAgIC8vICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIik7XG5cblxuICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KFwiI3RhYjNcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICBpZiAodHlwZW9mIGQucGxvdHR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHsgLy8gLnByb3BlcnRpZXMgaXMgdW5kZWZpbmVkIGZvciBzb21lIHZhcnNcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoZC5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIpIHtcbiAgICAgICAgZGVuc2l0eShkLCBkaXYgPSBcInZhclN1bW1hcnlcIiwgcHJpdik7XG4gICAgfSBlbHNlIGlmIChkLnBsb3R0eXBlID09PSBcImJhclwiKSB7XG4gICAgICAgIGJhcnMoZCwgZGl2ID0gXCJ2YXJTdW1tYXJ5XCIsIHByaXYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KFwiI3RhYjNcIikgLy8gbm8gZ3JhcGggdG8gZHJhdywgYnV0IHN0aWxsIG5lZWQgdG8gcmVtb3ZlIHByZXZpb3VzIGdyYXBoXG4gICAgICAgICAgICAuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcG9wdWxhdGVQb3BvdmVyKCkge1xuICAgIGQzLnNlbGVjdChcIiN0YWIxXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWNvbnRlbnRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIG9uTm9kZSA9IGZpbmROb2RlSW5kZXgoZCk7XG4gICAgICAgICAgICByZXR1cm4gcG9wb3ZlckNvbnRlbnQoYWxsTm9kZXNbb25Ob2RlXSk7XG4gICAgICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwb3BvdmVyQ29udGVudChkKSB7XG5cbiAgICB2YXIgcmludCA9IGQzLmZvcm1hdChcInJcIik7XG5cbiAgICB2YXIgb3V0dGV4dCA9IFwiXCI7XG5cbiAgICBpZiAoZC5sYWJsICE9IFwiXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TGFiZWw8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+PGk+XCIgKyBkLmxhYmwgKyBcIjwvaT48L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuXG4gICAgaWYgKGQubWVhbiAhPSBcIk5BXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWVhbjwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIlxuICAgICAgICBpZiAocHJpdiAmJiBkLm1lYW5DSSkge1xuICAgICAgICAgICAgb3V0dGV4dCArPSAoK2QubWVhbikudG9QcmVjaXNpb24oMikudG9TdHJpbmcoKSArIFwiIChcIiArICgrZC5tZWFuQ0kubG93ZXJCb3VuZCkudG9QcmVjaXNpb24oMikudG9TdHJpbmcoKSArIFwiIC0gXCIgKyAoK2QubWVhbkNJLnVwcGVyQm91bmQpLnRvUHJlY2lzaW9uKDIpLnRvU3RyaW5nKCkgKyBcIilcIlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0dGV4dCArPSAoK2QubWVhbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKVxuICAgICAgICB9XG4gICAgICAgIG91dHRleHQgKz0gXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuXG4gICAgaWYgKGQubWVkaWFuICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NZWRpYW48L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyAoK2QubWVkaWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuXG4gICAgaWYgKGQubW9kZSAhPSBcIk5BXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TW9zdCBGcmVxPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgZC5tb2RlICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuXG4gICAgaWYgKGQuZnJlcW1vZGUgIT0gXCJOQVwiKSB7XG4gICAgICAgIG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk9jY3VycmVuY2VzPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgcmludChkLmZyZXFtb2RlKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cblxuICAgIGlmIChkLm1pZCAhPSBcIk5BXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWVkaWFuIEZyZXE8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyBkLm1pZCArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cblxuICAgIGlmIChkLmZyZXFtaWQgIT0gXCJOQVwiKSB7XG4gICAgICAgIG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk9jY3VycmVuY2VzPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgcmludChkLmZyZXFtaWQpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIGlmIChkLmZld2VzdCAhPSBcIk5BXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TGVhc3QgRnJlcTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIGQuZmV3ZXN0ICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuXG4gICAgaWYgKGQuZnJlcWZld2VzdCAhPSBcIk5BXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+T2NjdXJyZW5jZXM8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyByaW50KGQuZnJlcWZld2VzdCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG5cbiAgICBpZiAoZC5zZCAhPSBcIk5BXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+U3RhbmQgRGV2PC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgKCtkLnNkKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuXG4gICAgaWYgKGQubWF4ICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NYXhpbXVtPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgKCtkLm1heCkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cblxuICAgIGlmIChkLm1pbiAhPSBcIk5BXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWluaW11bTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArICgrZC5taW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG4gICAgaWYgKGQuaW52YWxpZCAhPSBcIk5BXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+SW52YWxpZDwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHJpbnQoZC5pbnZhbGlkKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cbiAgICBpZiAoZC52YWxpZCAhPSBcIk5BXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+VmFsaWQ8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyByaW50KGQudmFsaWQpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuXG4gICAgaWYgKGQudW5pcXVlcyAhPSBcIk5BXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+VW5pcXVlczwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHJpbnQoZC51bmlxdWVzKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cbiAgICBpZiAoZC5oZXJmaW5kYWhsICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5IZXJmaW5kYWhsPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgKCtkLmhlcmZpbmRhaGwpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0dGV4dDtcbn1cblxuZnVuY3Rpb24gcG9wdXBYKGQpIHtcblxuICAgIHZhciB0c2YgPSBkMy5mb3JtYXQoXCIuNHJcIik7XG4gICAgdmFyIHJpbnQgPSBkMy5mb3JtYXQoXCJyXCIpO1xuXG4gICAgLy9DcmVhdGUgdGhlIHRvb2x0aXAgbGFiZWxcbiAgICBkMy5zZWxlY3QoXCIjdG9vbHRpcFwiKVxuICAgICAgICAuc3R5bGUoXCJsZWZ0XCIsIHRlbXBYICsgXCJweFwiKVxuICAgICAgICAuc3R5bGUoXCJ0b3BcIiwgdGVtcFkgKyBcInB4XCIpXG4gICAgICAgIC5zZWxlY3QoXCIjdG9vbHRpcHRleHRcIilcbiAgICAgICAgLmh0bWwoXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1lYW48L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyB0c2YoZC5tZWFuKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiICtcblxuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1lZGlhbjwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1lZGlhbikgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG5cbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5Nb2RlPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgZC5tb2RlICsgXCI8L3A+PC9kaXY+PC9kaXY+XCIgK1xuXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+U3RhbmQgRGV2PC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgdHNmKGQuc2QpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCIgK1xuXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWF4aW11bTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1heCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG5cbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NaW5pbXVtPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgdHNmKGQubWluKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiICtcblxuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPlZhbGlkPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgcmludChkLnZhbGlkKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiICtcblxuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPkludmFsaWQ8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyByaW50KGQuaW52YWxpZCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIlxuICAgICAgICApO1xufVxuXG5mdW5jdGlvbiBwYW5lbFBsb3RzKCkge1xuICAgIC8vIGJ1aWxkIGFycmF5cyBmcm9tIG5vZGVzIGluIG1haW5cbiAgICB2YXIgdmFyQXJyYXkgPSBbXTtcbiAgICB2YXIgaWRBcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXJBcnJheS5wdXNoKG5vZGVzW2pdLm5hbWUucmVwbGFjZSgvXFwofFxcKS9nLCBcIlwiKSk7XG4gICAgICAgIGlkQXJyYXkucHVzaChub2Rlc1tqXS5pZCk7XG4gICAgfVxuXG4gICAgLy9yZW1vdmUgYWxsIHBsb3RzLCBjb3VsZCBiZSBzbWFydGVyIGhlcmVcbiAgICBkMy5zZWxlY3QoXCIjc2V0eFwiKS5zZWxlY3RBbGwoXCJzdmdcIikucmVtb3ZlKCk7XG4gICAgZDMuc2VsZWN0KFwiI3RhYjJcIikuc2VsZWN0QWxsKFwic3ZnXCIpLnJlbW92ZSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhbGxOb2Rlc1tpZEFycmF5W2ldXS5zZXR4cGxvdCA9IGZhbHNlO1xuICAgICAgICBhbGxOb2Rlc1tpZEFycmF5W2ldXS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgIGlmIChhbGxOb2Rlc1tpZEFycmF5W2ldXS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIgJiBhbGxOb2Rlc1tpZEFycmF5W2ldXS5zZXR4cGxvdCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgYWxsTm9kZXNbaWRBcnJheVtpXV0uc2V0eHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS5sb2cocHJpdik7XG4gICAgICAgICAgICBkZW5zaXR5KGFsbE5vZGVzW2lkQXJyYXlbaV1dLCBkaXYgPSBcInNldHhcIiwgcHJpdik7XG4gICAgICAgICAgICBhbGxOb2Rlc1tpZEFycmF5W2ldXS5zdWJzZXRwbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbnNpdHkoYWxsTm9kZXNbaWRBcnJheVtpXV0sIGRpdiA9IFwic3Vic2V0XCIsIHByaXYpO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE5vZGVzW2lkQXJyYXlbaV1dLnBsb3R0eXBlID09PSBcImJhclwiICYgYWxsTm9kZXNbaWRBcnJheVtpXV0uc2V0eHBsb3QgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGFsbE5vZGVzW2lkQXJyYXlbaV1dLnNldHhwbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJhcnMoYWxsTm9kZXNbaWRBcnJheVtpXV0sIGRpdiA9IFwic2V0eFwiLCBwcml2KTtcbiAgICAgICAgICAgIGFsbE5vZGVzW2lkQXJyYXlbaV1dLnN1YnNldHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgYmFyc1N1YnNldChhbGxOb2Rlc1tpZEFycmF5W2ldXSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGQzLnNlbGVjdChcIiNzZXR4XCIpLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciByZWdzdHIgPSAvKC4rKV9zZXR4XyhcXGQrKS87XG4gICAgICAgICAgICB2YXIgbXluYW1lID0gcmVnc3RyLmV4ZWModGhpcy5pZCk7XG4gICAgICAgICAgICB2YXIgbm9kZWlkID0gbXluYW1lWzJdO1xuICAgICAgICAgICAgbXluYW1lID0gbXluYW1lWzFdO1xuICAgICAgICAgICAgdmFyIGogPSB2YXJBcnJheS5pbmRleE9mKG15bmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChqID09IC0xKSB7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbm9kZWlkXS5zZXR4cGxvdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gXCIjXCIuY29uY2F0KG15bmFtZSwgXCJfc2V0eF9cIiwgbm9kZWlkKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGVtcClcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbm9kZWlkXS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBcIiNcIi5jb25jYXQobXluYW1lLCBcIl90YWIyX1wiLCBub2RlaWQpO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0ZW1wKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xufVxuXG4vLyBlYXN5IGZ1bmN0aW9ucyB0byBjb2xsYXBzZSBwYW5lbHMgdG8gYmFzZVxuZnVuY3Rpb24gcmlnaHRwYW5lbE1lZGl1bSgpIHtcbiAgICBkMy5zZWxlY3QoXCIjcmlnaHRwYW5lbFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiKTtcbn1cblxuZnVuY3Rpb24gbGVmdHBhbmVsTWVkaXVtKCkge1xuICAgIGQzLnNlbGVjdChcIiNsZWZ0cGFuZWxcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIik7XG59XG5cbi8vIGZ1bmN0aW9uIHRvIGNvbnZlcnQgY29sb3IgY29kZXNcbmZ1bmN0aW9uIGhleFRvUmdiYShoZXgpIHtcbiAgICB2YXIgaCA9IGhleC5yZXBsYWNlKCcjJywgJycpO1xuXG4gICAgdmFyIGJpZ2ludCA9IHBhcnNlSW50KGgsIDE2KTtcbiAgICB2YXIgciA9IChiaWdpbnQgPj4gMTYpICYgMjU1O1xuICAgIHZhciBnID0gKGJpZ2ludCA+PiA4KSAmIDI1NTtcbiAgICB2YXIgYiA9IGJpZ2ludCAmIDI1NTtcbiAgICB2YXIgYSA9ICcwLjUnO1xuXG4gICAgcmV0dXJuIFwicmdiYShcIiArIHIgKyBcIixcIiArIGcgKyBcIixcIiArIGIgKyBcIixcIiArIGEgKyBcIilcIjtcbn1cblxuLy8gZnVuY3Rpb24gdGFrZXMgYSBub2RlIGFuZCBhIGNvbG9yIGFuZCB1cGRhdGVzIHpwYXJhbXNcbmZ1bmN0aW9uIHNldENvbG9ycyhuLCBjKSB7XG5cbiAgICBpZiAobi5zdHJva2VXaWR0aCA9PSAnMScpIHsgLy8gYWRkaW5nIHRpbWUsIGNzLCBkdiwgbm9tIHRvIGEgbm9kZSB3aXRoIG5vIHN0cm9rZVxuICAgICAgICBuLnN0cm9rZVdpZHRoID0gJzQnO1xuICAgICAgICBuLnN0cm9rZUNvbG9yID0gYztcbiAgICAgICAgbi5ub2RlQ29sID0gdGFnZ2VkQ29sb3I7XG4gICAgICAgIGlmIChkdkNvbG9yID09IGMpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFycmF5LCBpZiBub3QsIG1ha2UgaXQgYW4gYXJyYXlcbiAgICAgICAgICAgIC8vICBjb25zb2xlLmxvZyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoenBhcmFtcy56ZHYpKTtcbiAgICAgICAgICAgIHpwYXJhbXMuemR2ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHpwYXJhbXMuemR2KSA9PSBcIltvYmplY3QgQXJyYXldXCIgPyB6cGFyYW1zLnpkdiA6IFtdO1xuICAgICAgICAgICAgenBhcmFtcy56ZHYucHVzaChuLm5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNzQ29sb3IgPT0gYykge1xuICAgICAgICAgICAgenBhcmFtcy56Y3Jvc3MgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoenBhcmFtcy56Y3Jvc3MpID09IFwiW29iamVjdCBBcnJheV1cIiA/IHpwYXJhbXMuemNyb3NzIDogW107XG4gICAgICAgICAgICB6cGFyYW1zLnpjcm9zcy5wdXNoKG4ubmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZUNvbG9yID09IGMpIHtcbiAgICAgICAgICAgIHpwYXJhbXMuenRpbWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoenBhcmFtcy56dGltZSkgPT0gXCJbb2JqZWN0IEFycmF5XVwiID8genBhcmFtcy56dGltZSA6IFtdO1xuICAgICAgICAgICAgenBhcmFtcy56dGltZS5wdXNoKG4ubmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9tQ29sb3IgPT0gYykge1xuICAgICAgICAgICAgenBhcmFtcy56bm9tID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHpwYXJhbXMuem5vbSkgPT0gXCJbb2JqZWN0IEFycmF5XVwiID8genBhcmFtcy56bm9tIDogW107XG4gICAgICAgICAgICB6cGFyYW1zLnpub20ucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgYWxsTm9kZXNbZmluZE5vZGVJbmRleChuLm5hbWUpXS5uYXR1cmUgPSBcIm5vbWluYWxcIjtcbiAgICAgICAgICAgIHRyYW5zZm9ybShuLm5hbWUsIHQgPSBudWxsLCB0eXBlVHJhbnNmb3JtID0gdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkMy5zZWxlY3QoXCIjdGFiMVwiKS5zZWxlY3QoXCJwI1wiLmNvbmNhdChuLm5hbWUpKVxuICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKGMpKTtcbiAgICB9IGVsc2UgaWYgKG4uc3Ryb2tlV2lkdGggPT0gJzQnKSB7XG4gICAgICAgIGlmIChjID09IG4uc3Ryb2tlQ29sb3IpIHsgLy8gZGVzZWxlY3RpbmcgdGltZSwgY3MsIGR2LCBub21cbiAgICAgICAgICAgIG4uc3Ryb2tlV2lkdGggPSAnMSc7XG4gICAgICAgICAgICBuLnN0cm9rZUNvbG9yID0gc2VsVmFyQ29sb3I7XG4gICAgICAgICAgICBuLm5vZGVDb2wgPSBjb2xvcnMobi5pZCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjdGFiMVwiKS5zZWxlY3QoXCJwI1wiLmNvbmNhdChuLm5hbWUpKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGhleFRvUmdiYShzZWxWYXJDb2xvcikpO1xuXG4gICAgICAgICAgICBpZiAoZHZDb2xvciA9PSBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR2SW5kZXggPSB6cGFyYW1zLnpkdi5pbmRleE9mKG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGR2SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpkdi5zcGxpY2UoZHZJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjc0NvbG9yID09IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3NJbmRleCA9IHpwYXJhbXMuemNyb3NzLmluZGV4T2Yobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoY3NJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuemNyb3NzLnNwbGljZShjc0luZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRpbWVDb2xvciA9PSBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVJbmRleCA9IHpwYXJhbXMuenRpbWUuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnp0aW1lLnNwbGljZSh0aW1lSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9tQ29sb3IgPT0gYykge1xuICAgICAgICAgICAgICAgIHZhciBub21JbmRleCA9IHpwYXJhbXMuem5vbS5pbmRleE9mKG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vbUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56bm9tLnNwbGljZShub21JbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgobi5uYW1lKV0ubmF0dXJlID0gYWxsTm9kZXNbZmluZE5vZGVJbmRleChuLm5hbWUpXS5kZWZhdWx0TmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obi5uYW1lLCB0ID0gbnVsbCwgdHlwZVRyYW5zZm9ybSA9IHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gZGVzZWxlY3RpbmcgdGltZSwgY3MsIGR2LCBub20gQU5EIGNoYW5naW5nIGl0IHRvIHRpbWUsIGNzLCBkdiwgbm9tXG4gICAgICAgICAgICBpZiAoZHZDb2xvciA9PSBuLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR2SW5kZXggPSB6cGFyYW1zLnpkdi5pbmRleE9mKG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGR2SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpkdi5zcGxpY2UoZHZJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjc0NvbG9yID09IG4uc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3NJbmRleCA9IHpwYXJhbXMuemNyb3NzLmluZGV4T2Yobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoY3NJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuemNyb3NzLnNwbGljZShjc0luZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRpbWVDb2xvciA9PSBuLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVJbmRleCA9IHpwYXJhbXMuenRpbWUuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnp0aW1lLnNwbGljZSh0aW1lSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9tQ29sb3IgPT0gbi5zdHJva2VDb2xvcikge1xuICAgICAgICAgICAgICAgIHZhciBub21JbmRleCA9IHpwYXJhbXMuem5vbS5pbmRleE9mKG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vbUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56bm9tLnNwbGljZShub21JbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgobi5uYW1lKV0ubmF0dXJlID0gYWxsTm9kZXNbZmluZE5vZGVJbmRleChuLm5hbWUpXS5kZWZhdWx0TmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obi5uYW1lLCB0ID0gbnVsbCwgdHlwZVRyYW5zZm9ybSA9IHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4uc3Ryb2tlQ29sb3IgPSBjO1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3RhYjFcIikuc2VsZWN0KFwicCNcIi5jb25jYXQobi5uYW1lKSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEoYykpO1xuXG4gICAgICAgICAgICBpZiAoZHZDb2xvciA9PSBjKSB7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56ZHYucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjc0NvbG9yID09IGMpIHtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpjcm9zcy5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRpbWVDb2xvciA9PSBjKSB7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56dGltZS5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vbUNvbG9yID09IGMpIHtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpub20ucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgobi5uYW1lKV0ubmF0dXJlID0gXCJub21pbmFsXCI7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYm9yZGVyU3RhdGUoKSB7XG4gICAgaWYgKHpwYXJhbXMuemR2Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgJCgnI2R2QnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIGR2Q29sb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICQoJyNkdkJ1dHRvbicpLmNzcygnYm9yZGVyLWNvbG9yJywgJyNjY2MnKTtcbiAgICB9XG4gICAgaWYgKHpwYXJhbXMuemNyb3NzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgJCgnI2NzQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIGNzQ29sb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICQoJyNjc0J1dHRvbicpLmNzcygnYm9yZGVyLWNvbG9yJywgJyNjY2MnKTtcbiAgICB9XG4gICAgaWYgKHpwYXJhbXMuenRpbWUubGVuZ3RoID4gMCkge1xuICAgICAgICAkKCcjdGltZUJ1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCB0aW1lQ29sb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICQoJyN0aW1lQnV0dG9uJykuY3NzKCdib3JkZXItY29sb3InLCAnI2NjYycpO1xuICAgIH1cbiAgICBpZiAoenBhcmFtcy56bm9tLmxlbmd0aCA+IDApIHtcbiAgICAgICAgJCgnI25vbUJ1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCBub21Db2xvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgJCgnI25vbUJ1dHRvbicpLmNzcygnYm9yZGVyLWNvbG9yJywgJyNjY2MnKTtcbiAgICB9XG59XG5cbi8vIHNtYWxsIGFwcGVhcmFuY2UgcmVzZXRzLCBidXQgcGVyaGFwcyB0aGlzIHdpbGwgYmVjb21lIGEgaGFyZCByZXNldCBiYWNrIHRvIGFsbCBvcmlnaW5hbCBhbGxOb2RlIHZhbHVlcz9cbmZ1bmN0aW9uIG5vZGVSZXNldChuKSB7XG4gICAgbi5zdHJva2VDb2xvciA9IHNlbFZhckNvbG9yO1xuICAgIG4uc3Ryb2tlV2lkdGggPSBcIjFcIjtcbiAgICBuLm5vZGVDb2wgPSBuLmJhc2VDb2w7XG59XG5cbmZ1bmN0aW9uIHN1YnNldFNlbGVjdChidG4pIHtcbiAgICBpZiAoZGF0YXVybCkge1xuICAgICAgICB6cGFyYW1zLnpkYXRhdXJsID0gZGF0YXVybDtcbiAgICB9XG5cbiAgICBpZiAocHJvZHVjdGlvbiAmJiB6cGFyYW1zLnpzZXNzaW9uaWQgPT0gXCJcIikge1xuICAgICAgICBhbGVydChcIldhcm5pbmc6IERhdGEgZG93bmxvYWQgaXMgbm90IGNvbXBsZXRlLiBUcnkgYWdhaW4gc29vbi5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB6cGFyYW1zLnp2YXJzID0gW107XG4gICAgenBhcmFtcy56cGxvdCA9IFtdO1xuXG4gICAgdmFyIHN1YnNldEVtcHR5ID0gdHJ1ZTtcblxuICAgIC8vIGlzIHRoaXMgdGhlIHNhbWUgYXMgelBvcCgpP1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHsgLy9wb3B1bGF0ZSB6dmFycyBhbmQgenN1YnNldCBhcnJheXNcbiAgICAgICAgenBhcmFtcy56dmFycy5wdXNoKG5vZGVzW2pdLm5hbWUpO1xuICAgICAgICB2YXIgdGVtcCA9IG5vZGVzW2pdLmlkO1xuICAgICAgICB6cGFyYW1zLnpzdWJzZXRbal0gPSBhbGxOb2Rlc1t0ZW1wXS5zdWJzZXRyYW5nZTtcbiAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoenBhcmFtcy56c3Vic2V0W2pdWzBdICE9IFwiXCIpIHtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpzdWJzZXRbal1bMF0gPSBOdW1iZXIoenBhcmFtcy56c3Vic2V0W2pdWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh6cGFyYW1zLnpzdWJzZXRbal1bMV0gIT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHpwYXJhbXMuenN1YnNldFtqXVsxXSA9IE51bWJlcih6cGFyYW1zLnpzdWJzZXRbal1bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHpwYXJhbXMuenBsb3QucHVzaChhbGxOb2Rlc1t0ZW1wXS5wbG90dHlwZSk7XG4gICAgICAgIGlmICh6cGFyYW1zLnpzdWJzZXRbal1bMV0gIT0gXCJcIikge1xuICAgICAgICAgICAgc3Vic2V0RW1wdHkgPSBmYWxzZTtcbiAgICAgICAgfSAvL29ubHkgbmVlZCB0byBjaGVjayBvbmVcbiAgICB9XG5cbiAgICBpZiAoc3Vic2V0RW1wdHkgPT0gdHJ1ZSkge1xuICAgICAgICBhbGVydChcIldhcm5pbmc6IE5vIG5ldyBzdWJzZXQgc2VsZWN0ZWQuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG91dHR5cGVzID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbGxOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBvdXR0eXBlcy5wdXNoKHtcbiAgICAgICAgICAgIHZhcm5hbWVzVHlwZXM6IGFsbE5vZGVzW2pdLm5hbWUsXG4gICAgICAgICAgICBuYXR1cmU6IGFsbE5vZGVzW2pdLm5hdHVyZSxcbiAgICAgICAgICAgIG51bWNoYXI6IGFsbE5vZGVzW2pdLm51bWNoYXIsXG4gICAgICAgICAgICBiaW5hcnk6IGFsbE5vZGVzW2pdLmJpbmFyeSxcbiAgICAgICAgICAgIGludGVydmFsOiBhbGxOb2Rlc1tqXS5pbnRlcnZhbFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgc3Vic2V0c3R1ZmYgPSB7XG4gICAgICAgIHpkYXRhdXJsOiB6cGFyYW1zLnpkYXRhdXJsLFxuICAgICAgICB6dmFyczogenBhcmFtcy56dmFycyxcbiAgICAgICAgenN1YnNldDogenBhcmFtcy56c3Vic2V0LFxuICAgICAgICB6c2Vzc2lvbmlkOiB6cGFyYW1zLnpzZXNzaW9uaWQsXG4gICAgICAgIHpwbG90OiB6cGFyYW1zLnpwbG90LFxuICAgICAgICBjYWxsSGlzdG9yeTogY2FsbEhpc3RvcnksXG4gICAgICAgIHR5cGVTdHVmZjogb3V0dHlwZXNcbiAgICB9O1xuXG4gICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeShzdWJzZXRzdHVmZik7XG4gICAgLy92YXIgYmFzZSA9IHJhcHBVUkwrXCJzdWJzZXRhcHA/c29sYUpTT049XCJcbiAgICB1cmxjYWxsID0gcmFwcFVSTCArIFwic3Vic2V0YXBwXCI7IC8vYmFzZS5jb25jYXQoanNvbm91dCk7XG4gICAgdmFyIHNvbGFqc29ub3V0ID0gXCJzb2xhSlNPTj1cIiArIGpzb25vdXQ7XG4gICAgY29uc29sZS5sb2coXCJ1cmxjYWxsIG91dDogXCIsIHVybGNhbGwpO1xuICAgIGNvbnNvbGUubG9nKFwiUE9TVCBvdXQ6IFwiLCBzb2xhanNvbm91dCk7XG5cbiAgICBmdW5jdGlvbiBzdWJzZXRTZWxlY3RTdWNjZXNzKGJ0biwganNvbikge1xuICAgICAgICBzZWxlY3RMYWRkYS5zdG9wKCk7IC8vIHN0b3AgbW90aW9uXG4gICAgICAgICQoXCIjYnRuVmFyaWFibGVzXCIpLnRyaWdnZXIoXCJjbGlja1wiKTsgLy8gcHJvZ3JhbW1hdGljIGNsaWNrc1xuICAgICAgICAkKFwiI2J0bk1vZGVsc1wiKS50cmlnZ2VyKFwiY2xpY2tcIik7XG5cbiAgICAgICAgdmFyIGdyYXlPdXRzID0gW107XG5cbiAgICAgICAgdmFyIHJDYWxsID0gW107XG4gICAgICAgIHJDYWxsWzBdID0ganNvbi5jYWxsO1xuXG4gICAgICAgIC8vIHN0b3JlIGNvbnRlbnRzIG9mIHRoZSBwcmUtc3Vic2V0IHNwYWNlXG4gICAgICAgIHpQb3AoKTtcbiAgICAgICAgdmFyIG15Tm9kZXMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBhbGxOb2Rlcyk7XG4gICAgICAgIHZhciBteVBhcmFtcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwge30sIHpwYXJhbXMpO1xuICAgICAgICB2YXIgbXlUcmFucyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHRyYW5zKTtcbiAgICAgICAgdmFyIG15Rm9yY2UgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBmb3JjZXRvZ2dsZSk7XG4gICAgICAgIHZhciBteVByZXByb2Nlc3MgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCBwcmVwcm9jZXNzKTtcbiAgICAgICAgdmFyIG15TG9nID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgbG9nQXJyYXkpO1xuICAgICAgICB2YXIgbXlIaXN0b3J5ID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgY2FsbEhpc3RvcnkpO1xuXG4gICAgICAgIHNwYWNlc1tteXNwYWNlXSA9IHtcbiAgICAgICAgICAgIFwiYWxsTm9kZXNcIjogbXlOb2RlcyxcbiAgICAgICAgICAgIFwienBhcmFtc1wiOiBteVBhcmFtcyxcbiAgICAgICAgICAgIFwidHJhbnNcIjogbXlUcmFucyxcbiAgICAgICAgICAgIFwiZm9yY2VcIjogbXlGb3JjZSxcbiAgICAgICAgICAgIFwicHJlcHJvY2Vzc1wiOiBteVByZXByb2Nlc3MsXG4gICAgICAgICAgICBcImxvZ0FycmF5XCI6IG15TG9nLFxuICAgICAgICAgICAgXCJjYWxsSGlzdG9yeVwiOiBteUhpc3RvcnlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZW1vdmUgcHJlLXN1YnNldCBzdmdcbiAgICAgICAgdmFyIHNlbGVjdE1lID0gXCIjbVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5hdHRyKCdjbGFzcycsICdpdGVtJyk7XG4gICAgICAgIHNlbGVjdE1lID0gXCIjd2hpdGVzcGFjZVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5yZW1vdmUoKTtcblxuICAgICAgICBteXNwYWNlID0gc3BhY2VzLmxlbmd0aDtcbiAgICAgICAgY2FsbEhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICBmdW5jOiBcInN1YnNldFwiLFxuICAgICAgICAgICAgenZhcnM6IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHpwYXJhbXMuenZhcnMpLFxuICAgICAgICAgICAgenN1YnNldDogalF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgenBhcmFtcy56c3Vic2V0KSxcbiAgICAgICAgICAgIHpwbG90OiBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCB6cGFyYW1zLnpwbG90KVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0aGlzIGlzIHRvIGJlIHVzZWQgdG8gZ3JheSBvdXQgYW5kIHJlbW92ZSBsaXN0ZW5lcnMgZm9yIHZhcmlhYmxlcyB0aGF0IGhhdmUgYmVlbiBzdWJzZXR0ZWQgb3V0IG9mIHRoZSBkYXRhXG4gICAgICAgIGZ1bmN0aW9uIHZhck91dCh2KSB7XG4gICAgICAgICAgICAvLyBpZiBpbiBub2RlcywgcmVtb3ZlXG4gICAgICAgICAgICAvLyBncmF5IG91dCBpbiBsZWZ0IHBhbmVsXG4gICAgICAgICAgICAvLyBtYWtlIHVuY2xpY2thYmxlIGluIGxlZnQgcGFuZWxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RNZSA9IHZbaV0ucmVwbGFjZSgvXFxXL2csIFwiX1wiKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3RNZSkuc3R5bGUuY29sb3IgPSBoZXhUb1JnYmEoZ3JheUNvbG9yKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RNZSA9IFwicCNcIi5jb25jYXQoc2VsZWN0TWUpO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsb2dBcnJheS5wdXNoKFwic3Vic2V0OiBcIi5jb25jYXQockNhbGxbMF0pKTtcbiAgICAgICAgc2hvd0xvZygpO1xuICAgICAgICByZVdyaXRlTG9nKCk7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI2lubmVyY2Fyb3VzZWxcIilcbiAgICAgICAgICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaXRlbSBhY3RpdmUnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibVwiLmNvbmNhdChteXNwYWNlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hcHBlbmQoJ3N2ZycpXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnd2hpdGVzcGFjZScpO1xuICAgICAgICBzdmcgPSBkMy5zZWxlY3QoXCIjd2hpdGVzcGFjZVwiKTtcblxuICAgICAgICBkMy5qc29uKGpzb24udXJsLCBmdW5jdGlvbihlcnJvciwganNvbikge1xuICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgICAgICAgIHZhciBqc29uZGF0YSA9IGpzb247XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBqc29uZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBteUluZGV4ID0gZmluZE5vZGVJbmRleChrZXkpO1xuXG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5wbG90dHlwZSA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIGFsbE5vZGVzW215SW5kZXhdLCBqc29uZGF0YVtrZXldKTtcblxuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnN1YnNldHBsb3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zdWJzZXRyYW5nZSA9IFtcIlwiLCBcIlwiXTtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zZXR4cGxvdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnNldHh2YWxzID0gW1wiXCIsIFwiXCJdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFsbE5vZGVzW215SW5kZXhdLnZhbGlkID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JheU91dHMucHVzaChhbGxOb2Rlc1tteUluZGV4XS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0uZ3JheW91dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZVBsb3QoKTtcbiAgICAgICAgICAgIHBvcHVsYXRlUG9wb3ZlcigpO1xuICAgICAgICAgICAgbGF5b3V0KHYgPSBcImFkZFwiKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICB2YXJPdXQoZ3JheU91dHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YnNldFNlbGVjdEZhaWwoYnRuKSB7XG4gICAgICAgIHNlbGVjdExhZGRhLnN0b3AoKTsgLy9zdG9wIG1vdGlvblxuICAgIH1cblxuICAgIHNlbGVjdExhZGRhLnN0YXJ0KCk7IC8vc3RhcnQgYnV0dG9uIG1vdGlvblxuICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBidG4sIHN1YnNldFNlbGVjdFN1Y2Nlc3MsIHN1YnNldFNlbGVjdEZhaWwsIHNvbGFqc29ub3V0KTtcbn1cblxuZnVuY3Rpb24gcmVhZFByZXByb2Nlc3ModXJsLCBwLCB2LCBjYWxsYmFjaykge1xuICAgIGNvbnNvbGUubG9nKHVybCk7XG4gICAgZDMuanNvbih1cmwsIGZ1bmN0aW9uKGVycm9yLCBqc29uKSB7XG4gICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgIHZhciBqc29uZGF0YSA9IGpzb247XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJpbnNpZGUgcmVhZFByZXByb2Nlc3MgZnVuY3Rpb25cIik7XG4gICAgICAgIGNvbnNvbGUubG9nKGpzb25kYXRhKTtcbiAgICAgICAgY29uc29sZS5sb2coanNvbmRhdGFbXCJ2YXJpYWJsZXNcIl0pO1xuXG4gICAgICAgIGlmIChqc29uZGF0YS5kYXRhc2V0LnByaXYpIHtcbiAgICAgICAgICAgIHByaXYgPSBqc29uZGF0YVtcImRhdGFzZXRcIl1bXCJwcml2XCJdO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vY29weWluZyB0aGUgb2JqZWN0XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBqc29uZGF0YVtcInZhcmlhYmxlc1wiXSkge1xuICAgICAgICAgICAgcFtrZXldID0ganNvbmRhdGFbXCJ2YXJpYWJsZXNcIl1ba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBhYm91dCgpIHtcbiAgICAkKCcjYWJvdXQnKS5zaG93KCk7XG59XG5cbmZ1bmN0aW9uIGNsb3NlYWJvdXQoKSB7XG4gICAgJCgnI2Fib3V0JykuaGlkZSgpO1xufVxuXG5mdW5jdGlvbiBvcGVuY2l0ZSgpIHtcbiAgICAkKCcjY2l0ZScpLnNob3coKTtcbn1cblxuZnVuY3Rpb24gY2xvc2VjaXRlKHRvZ2dsZSkge1xuICAgIGlmICh0b2dnbGUgPT0gZmFsc2UpIHtcbiAgICAgICAgJCgnI2NpdGUnKS5oaWRlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjbGlja2NpdGUodG9nZ2xlKSB7XG4gICAgaWYgKHRvZ2dsZSA9PSBmYWxzZSkge1xuICAgICAgICAkKCcjY2l0ZScpLnNob3coKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgJCgnI2NpdGUnKS5oaWRlKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIGZ1bmN0aW9uIHRvIHJlbW92ZSBhbGwgdGhlIGNoaWxkcmVuIHN2Z3MgaW5zaWRlIHN1YnNldCBhbmQgc2V0eCBkaXZzXG5mdW5jdGlvbiByZVBsb3QoKSB7XG4gICAgZDMuc2VsZWN0KFwiI3RhYjJcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICBkMy5zZWxlY3QoXCIjc2V0eFwiKVxuICAgICAgICAuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgIC5yZW1vdmUoKTtcblxuICAgIC8vIG1ha2UgdGhpcyBzbWFydGVyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhbGxOb2Rlc1tpXS5zZXR4cGxvdCA9IGZhbHNlO1xuICAgICAgICBhbGxOb2Rlc1tpXS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzaG93TG9nKCkge1xuICAgIGlmIChsb2dBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2dkaXYnKS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6YmxvY2tcIik7XG4gICAgICAgIGQzLnNlbGVjdChcIiNjb2xsYXBzZUxvZyBkaXYucGFuZWwtYm9keVwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgICAgICAuZGF0YShsb2dBcnJheSlcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZ2RpdicpLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZGlzcGxheTpub25lXCIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVXcml0ZUxvZygpIHtcbiAgICBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAucmVtb3ZlKCk7XG4gICAgZDMuc2VsZWN0KFwiI2NvbGxhcHNlTG9nIGRpdi5wYW5lbC1ib2R5XCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgLmRhdGEobG9nQXJyYXkpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KTtcbn1cblxuLy8gYWN0cyBhcyBpZiB0aGUgdXNlciBjbGlja2VkIGluIHdoaXRlc3BhY2UuIHVzZWZ1bCB3aGVuIHJlc3RhcnQoKSBpcyBvdXRzaWRlIG9mIHNjb3BlXG5mdW5jdGlvbiBmYWtlQ2xpY2soKSB7XG4gICAgdmFyIG15d3MgPSBcIiN3aGl0ZXNwYWNlXCIuY29uY2F0KG15c3BhY2UpO1xuICAgIC8vIGQzIGFuZCBwcm9ncmFtbWF0aWMgZXZlbnRzIGRvbid0IG1lc2ggd2VsbCwgaGVyZSdzIGEgU08gd29ya2Fyb3VuZCB0aGF0IGxvb2tzIGdvb2QgYnV0IHVzZXMganF1ZXJ5Li4uXG4gICAgalF1ZXJ5LmZuLmQzQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGksIGUpIHtcbiAgICAgICAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuICAgICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KFwibW91c2Vkb3duXCIsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXG4gICAgICAgICAgICBlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAkKG15d3MpLmQzQ2xpY2soKTtcblxuICAgIGQzLnNlbGVjdChteXdzKVxuICAgICAgICAuY2xhc3NlZCgnYWN0aXZlJywgZmFsc2UpOyAvLyByZW1vdmUgYWN0aXZlIGNsYXNzXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYXBwX2RkaS5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUdBO0FBR0E7QUFFQTtBQUdBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFyQ0E7QUF1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFJQTtBQUlBO0FBSUE7QUFJQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQWpCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQVdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQWpCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!********************************************!*\
  !*** ./Ladda/dist/ladda-themeless.min.css ***!
  \********************************************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL0xhZGRhL2Rpc3QvbGFkZGEtdGhlbWVsZXNzLm1pbi5jc3M/MWY5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vTGFkZGEvZGlzdC9sYWRkYS10aGVtZWxlc3MubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 3 */
/* unknown exports provided */
/* all exports used */
/*!*****************!*\
  !*** ./app.css ***!
  \*****************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FwcC5jc3M/N2YyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwLmNzc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 4 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** ./bootstrap/css/bootstrap-theme.min.css ***!
  \***********************************************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Jvb3RzdHJhcC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3M/OTBiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYm9vdHN0cmFwL2Nzcy9ib290c3RyYXAtdGhlbWUubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 5 */
/* unknown exports provided */
/* all exports used */
/*!******************************!*\
  !*** ./~/mithril/mithril.js ***!
  \******************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(setImmediate, global) {;(function() {\n\"use strict\"\nfunction Vnode(tag, key, attrs0, children, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode(\"[\", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node != null && typeof node !== \"object\") return Vnode(\"#\", undefined, undefined, node === false ? \"\" : node, undefined, undefined)\n\treturn node\n}\nVnode.normalizeChildren = function normalizeChildren(children) {\n\tfor (var i = 0; i < children.length; i++) {\n\t\tchildren[i] = Vnode.normalize(children[i])\n\t}\n\treturn children\n}\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*(\"|'|)((?:\\\\[\"'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = {}\nvar hasOwn = {}.hasOwnProperty\nfunction compileSelector(selector) {\n\tvar match, tag = \"div\", classes = [], attrs = {}\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === \"\" && value !== \"\") tag = value\n\t\telse if (type === \"#\") attrs.id = value\n\t\telse if (type === \".\") classes.push(value)\n\t\telse if (match[3][0] === \"[\") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\([\"'])/g, \"$1\").replace(/\\\\\\\\/g, \"\\\\\")\n\t\t\tif (match[4] === \"class\") classes.push(attrValue)\n\t\t\telse attrs[match[4]] = attrValue || true\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(\" \")\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs}\n}\nfunction execSelector(state, attrs, children) {\n\tvar hasAttrs = false, childList, text\n\tvar className = attrs.className || attrs.class\n\tfor (var key in state.attrs) {\n\t\tif (hasOwn.call(state.attrs, key)) {\n\t\t\tattrs[key] = state.attrs[key]\n\t\t}\n\t}\n\tif (className !== undefined) {\n\t\tif (attrs.class !== undefined) {\n\t\t\tattrs.class = undefined\n\t\t\tattrs.className = className\n\t\t}\n\t\tif (state.attrs.className != null) {\n\t\t\tattrs.className = state.attrs.className + \" \" + className\n\t\t}\n\t}\n\tfor (var key in attrs) {\n\t\tif (hasOwn.call(attrs, key) && key !== \"key\") {\n\t\t\thasAttrs = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === \"#\") {\n\t\ttext = children[0].children\n\t} else {\n\t\tchildList = children\n\t}\n\treturn Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)\n}\nfunction hyperscript(selector) {\n\t// Because sloppy mode sucks\n\tvar attrs = arguments[1], start = 2, children\n\tif (selector == null || typeof selector !== \"string\" && typeof selector !== \"function\" && typeof selector.view !== \"function\") {\n\t\tthrow Error(\"The selector must be either a string or a component.\");\n\t}\n\tif (typeof selector === \"string\") {\n\t\tvar cached = selectorCache[selector] || compileSelector(selector)\n\t}\n\tif (attrs == null) {\n\t\tattrs = {}\n\t} else if (typeof attrs !== \"object\" || attrs.tag != null || Array.isArray(attrs)) {\n\t\tattrs = {}\n\t\tstart = 1\n\t}\n\tif (arguments.length === start + 1) {\n\t\tchildren = arguments[start]\n\t\tif (!Array.isArray(children)) children = [children]\n\t} else {\n\t\tchildren = []\n\t\twhile (start < arguments.length) children.push(arguments[start++])\n\t}\n\tvar normalized = Vnode.normalizeChildren(children)\n\tif (typeof selector === \"string\") {\n\t\treturn execSelector(cached, attrs, normalized)\n\t} else {\n\t\treturn Vnode(selector, attrs.key, attrs, normalized)\n\t}\n}\nhyperscript.trust = function(html) {\n\tif (html == null) html = \"\"\n\treturn Vnode(\"<\", undefined, undefined, html, undefined, undefined)\n}\nhyperscript.fragment = function(attrs1, children) {\n\treturn Vnode(\"[\", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)\n}\nvar m = hyperscript\n/** @constructor */\nvar PromisePolyfill = function(executor) {\n\tif (!(this instanceof PromisePolyfill)) throw new Error(\"Promise must be called with `new`\")\n\tif (typeof executor !== \"function\") throw new TypeError(\"executor must be a function\")\n\tvar self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)\n\tvar instance = self._instance = {resolvers: resolvers, rejectors: rejectors}\n\tvar callAsync = typeof setImmediate === \"function\" ? setImmediate : setTimeout\n\tfunction handler(list, shouldAbsorb) {\n\t\treturn function execute(value) {\n\t\t\tvar then\n\t\t\ttry {\n\t\t\t\tif (shouldAbsorb && value != null && (typeof value === \"object\" || typeof value === \"function\") && typeof (then = value.then) === \"function\") {\n\t\t\t\t\tif (value === self) throw new TypeError(\"Promise can't be resolved w/ itself\")\n\t\t\t\t\texecuteOnce(then.bind(value))\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallAsync(function() {\n\t\t\t\t\t\tif (!shouldAbsorb && list.length === 0) console.error(\"Possible unhandled promise rejection:\", value)\n\t\t\t\t\t\tfor (var i = 0; i < list.length; i++) list[i](value)\n\t\t\t\t\t\tresolvers.length = 0, rejectors.length = 0\n\t\t\t\t\t\tinstance.state = shouldAbsorb\n\t\t\t\t\t\tinstance.retry = function() {execute(value)}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\trejectCurrent(e)\n\t\t\t}\n\t\t}\n\t}\n\tfunction executeOnce(then) {\n\t\tvar runs = 0\n\t\tfunction run(fn) {\n\t\t\treturn function(value) {\n\t\t\t\tif (runs++ > 0) return\n\t\t\t\tfn(value)\n\t\t\t}\n\t\t}\n\t\tvar onerror = run(rejectCurrent)\n\t\ttry {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}\n\t}\n\texecuteOnce(executor)\n}\nPromisePolyfill.prototype.then = function(onFulfilled, onRejection) {\n\tvar self = this, instance = self._instance\n\tfunction handle(callback, list, next, state) {\n\t\tlist.push(function(value) {\n\t\t\tif (typeof callback !== \"function\") next(value)\n\t\t\telse try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}\n\t\t})\n\t\tif (typeof instance.retry === \"function\" && state === instance.state) instance.retry()\n\t}\n\tvar resolveNext, rejectNext\n\tvar promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})\n\thandle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)\n\treturn promise\n}\nPromisePolyfill.prototype.catch = function(onRejection) {\n\treturn this.then(null, onRejection)\n}\nPromisePolyfill.resolve = function(value) {\n\tif (value instanceof PromisePolyfill) return value\n\treturn new PromisePolyfill(function(resolve) {resolve(value)})\n}\nPromisePolyfill.reject = function(value) {\n\treturn new PromisePolyfill(function(resolve, reject) {reject(value)})\n}\nPromisePolyfill.all = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tvar total = list.length, count = 0, values = []\n\t\tif (list.length === 0) resolve([])\n\t\telse for (var i = 0; i < list.length; i++) {\n\t\t\t(function(i) {\n\t\t\t\tfunction consume(value) {\n\t\t\t\t\tcount++\n\t\t\t\t\tvalues[i] = value\n\t\t\t\t\tif (count === total) resolve(values)\n\t\t\t\t}\n\t\t\t\tif (list[i] != null && (typeof list[i] === \"object\" || typeof list[i] === \"function\") && typeof list[i].then === \"function\") {\n\t\t\t\t\tlist[i].then(consume, reject)\n\t\t\t\t}\n\t\t\t\telse consume(list[i])\n\t\t\t})(i)\n\t\t}\n\t})\n}\nPromisePolyfill.race = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tlist[i].then(resolve, reject)\n\t\t}\n\t})\n}\nif (typeof window !== \"undefined\") {\n\tif (typeof window.Promise === \"undefined\") window.Promise = PromisePolyfill\n\tvar PromisePolyfill = window.Promise\n} else if (typeof global !== \"undefined\") {\n\tif (typeof global.Promise === \"undefined\") global.Promise = PromisePolyfill\n\tvar PromisePolyfill = global.Promise\n} else {\n}\nvar buildQueryString = function(object) {\n\tif (Object.prototype.toString.call(object) !== \"[object Object]\") return \"\"\n\tvar args = []\n\tfor (var key0 in object) {\n\t\tdestructure(key0, object[key0])\n\t}\n\treturn args.join(\"&\")\n\tfunction destructure(key0, value) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tdestructure(key0 + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse if (Object.prototype.toString.call(value) === \"[object Object]\") {\n\t\t\tfor (var i in value) {\n\t\t\t\tdestructure(key0 + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse args.push(encodeURIComponent(key0) + (value != null && value !== \"\" ? \"=\" + encodeURIComponent(value) : \"\"))\n\t}\n}\nvar FILE_PROTOCOL_REGEX = new RegExp(\"^file://\", \"i\")\nvar _8 = function($window, Promise) {\n\tvar callbackCount = 0\n\tvar oncompletion\n\tfunction setCompletionCallback(callback) {oncompletion = callback}\n\tfunction finalizer() {\n\t\tvar count = 0\n\t\tfunction complete() {if (--count === 0 && typeof oncompletion === \"function\") oncompletion()}\n\t\treturn function finalize(promise0) {\n\t\t\tvar then0 = promise0.then\n\t\t\tpromise0.then = function() {\n\t\t\t\tcount++\n\t\t\t\tvar next = then0.apply(promise0, arguments)\n\t\t\t\tnext.then(complete, function(e) {\n\t\t\t\t\tcomplete()\n\t\t\t\t\tif (count === 0) throw e\n\t\t\t\t})\n\t\t\t\treturn finalize(next)\n\t\t\t}\n\t\t\treturn promise0\n\t\t}\n\t}\n\tfunction normalize(args, extra) {\n\t\tif (typeof args === \"string\") {\n\t\t\tvar url = args\n\t\t\targs = extra || {}\n\t\t\tif (args.url == null) args.url = url\n\t\t}\n\t\treturn args\n\t}\n\tfunction request(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tif (args.method == null) args.method = \"GET\"\n\t\t\targs.method = args.method.toUpperCase()\n\t\t\tvar useBody = (args.method === \"GET\" || args.method === \"TRACE\") ? false : (typeof args.useBody === \"boolean\" ? args.useBody : true)\n\t\t\tif (typeof args.serialize !== \"function\") args.serialize = typeof FormData !== \"undefined\" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify\n\t\t\tif (typeof args.deserialize !== \"function\") args.deserialize = deserialize\n\t\t\tif (typeof args.extract !== \"function\") args.extract = extract\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\tif (useBody) args.data = args.serialize(args.data)\n\t\t\telse args.url = assemble(args.url, args.data)\n\t\t\tvar xhr = new $window.XMLHttpRequest(),\n\t\t\t\taborted = false,\n\t\t\t\t_abort = xhr.abort\n\t\t\txhr.abort = function abort() {\n\t\t\t\taborted = true\n\t\t\t\t_abort.call(xhr)\n\t\t\t}\n\t\t\txhr.open(args.method, args.url, typeof args.async === \"boolean\" ? args.async : true, typeof args.user === \"string\" ? args.user : undefined, typeof args.password === \"string\" ? args.password : undefined)\n\t\t\tif (args.serialize === JSON.stringify && useBody) {\n\t\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\t\t}\n\t\t\tif (args.deserialize === deserialize) {\n\t\t\t\txhr.setRequestHeader(\"Accept\", \"application/json, text/*\")\n\t\t\t}\n\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials\n\t\t\tfor (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {\n\t\t\t\txhr.setRequestHeader(key, args.headers[key])\n\t\t\t}\n\t\t\tif (typeof args.config === \"function\") xhr = args.config(xhr, args) || xhr\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t// Don't throw errors on xhr.abort().\n\t\t\t\tif(aborted) return\n\t\t\t\tif (xhr.readyState === 4) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))\n\t\t\t\t\t\tif ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {\n\t\t\t\t\t\t\tresolve(cast(args.type, response))\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar error = new Error(xhr.responseText)\n\t\t\t\t\t\t\tfor (var key in response) error[key] = response[key]\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (useBody && (args.data != null)) xhr.send(args.data)\n\t\t\telse xhr.send()\n\t\t})\n\t\treturn args.background === true ? promise0 : finalize(promise0)\n\t}\n\tfunction jsonp(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tvar callbackName = args.callbackName || \"_mithril_\" + Math.round(Math.random() * 1e16) + \"_\" + callbackCount++\n\t\t\tvar script = $window.document.createElement(\"script\")\n\t\t\t$window[callbackName] = function(data) {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\tresolve(cast(args.type, data))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tscript.onerror = function() {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\treject(new Error(\"JSONP request failed\"))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tif (args.data == null) args.data = {}\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\targs.data[args.callbackKey || \"callback\"] = callbackName\n\t\t\tscript.src = assemble(args.url, args.data)\n\t\t\t$window.document.documentElement.appendChild(script)\n\t\t})\n\t\treturn args.background === true? promise0 : finalize(promise0)\n\t}\n\tfunction interpolate(url, data) {\n\t\tif (data == null) return url\n\t\tvar tokens = url.match(/:[^\\/]+/gi) || []\n\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\tvar key = tokens[i].slice(1)\n\t\t\tif (data[key] != null) {\n\t\t\t\turl = url.replace(tokens[i], data[key])\n\t\t\t}\n\t\t}\n\t\treturn url\n\t}\n\tfunction assemble(url, data) {\n\t\tvar querystring = buildQueryString(data)\n\t\tif (querystring !== \"\") {\n\t\t\tvar prefix = url.indexOf(\"?\") < 0 ? \"?\" : \"&\"\n\t\t\turl += prefix + querystring\n\t\t}\n\t\treturn url\n\t}\n\tfunction deserialize(data) {\n\t\ttry {return data !== \"\" ? JSON.parse(data) : null}\n\t\tcatch (e) {throw new Error(data)}\n\t}\n\tfunction extract(xhr) {return xhr.responseText}\n\tfunction cast(type0, data) {\n\t\tif (typeof type0 === \"function\") {\n\t\t\tif (Array.isArray(data)) {\n\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\tdata[i] = new type0(data[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\telse return new type0(data)\n\t\t}\n\t\treturn data\n\t}\n\treturn {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}\n}\nvar requestService = _8(window, PromisePolyfill)\nvar coreRenderer = function($window) {\n\tvar $doc = $window.document\n\tvar $emptyFragment = $doc.createDocumentFragment()\n\tvar onevent\n\tfunction setEventCallback(callback) {return onevent = callback}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tif (typeof tag === \"string\") {\n\t\t\tvnode.state = {}\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase \"#\": return createText(parent, vnode, nextSibling)\n\t\t\t\tcase \"<\": return createHTML(parent, vnode, nextSibling)\n\t\t\t\tcase \"[\": return createFragment(parent, vnode, hooks, ns, nextSibling)\n\t\t\t\tdefault: return createElement(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse return createComponent(parent, vnode, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode, nextSibling) {\n\t\tvnode.dom = $doc.createTextNode(vnode.children)\n\t\tinsertNode(parent, vnode.dom, nextSibling)\n\t\treturn vnode.dom\n\t}\n\tfunction createHTML(parent, vnode, nextSibling) {\n\t\tvar match1 = vnode.children.match(/^\\s*?<(\\w+)/im) || []\n\t\tvar parent1 = {caption: \"table\", thead: \"table\", tbody: \"table\", tfoot: \"table\", tr: \"tbody\", th: \"tr\", td: \"tr\", colgroup: \"table\", col: \"colgroup\"}[match1[1]] || \"div\"\n\t\tvar temp = $doc.createElement(parent1)\n\t\ttemp.innerHTML = vnode.children\n\t\tvnode.dom = temp.firstChild\n\t\tvnode.domSize = temp.childNodes.length\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tif (vnode.children != null) {\n\t\t\tvar children = vnode.children\n\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns)\n\t\t}\n\t\tvnode.dom = fragment.firstChild\n\t\tvnode.domSize = fragment.childNodes.length\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tswitch (vnode.tag) {\n\t\t\tcase \"svg\": ns = \"http://www.w3.org/2000/svg\"; break\n\t\t\tcase \"math\": ns = \"http://www.w3.org/1998/Math/MathML\"; break\n\t\t}\n\t\tvar attrs2 = vnode.attrs\n\t\tvar is = attrs2 && attrs2.is\n\t\tvar element = ns ?\n\t\t\tis ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :\n\t\t\tis ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)\n\t\tvnode.dom = element\n\t\tif (attrs2 != null) {\n\t\t\tsetAttrs(vnode, attrs2, ns)\n\t\t}\n\t\tinsertNode(parent, element, nextSibling)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse {\n\t\t\tif (vnode.text != null) {\n\t\t\t\tif (vnode.text !== \"\") element.textContent = vnode.text\n\t\t\t\telse vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\t}\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children\n\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns)\n\t\t\t\tsetLateAttrs(vnode)\n\t\t\t}\n\t\t}\n\t\treturn element\n\t}\n\tfunction initComponent(vnode, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode.tag.view === \"function\") {\n\t\t\tvnode.state = Object.create(vnode.tag)\n\t\t\tsentinel = vnode.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode.state = void 0\n\t\t\tsentinel = vnode.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === \"function\") ? new vnode.tag(vnode) : vnode.tag(vnode)\n\t\t}\n\t\tvnode._state = vnode.state\n\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\tinitLifecycle(vnode._state, vnode, hooks)\n\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tvar element = createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0\n\t\t\tinsertNode(parent, element, nextSibling)\n\t\t\treturn element\n\t\t}\n\t\telse {\n\t\t\tvnode.domSize = 0\n\t\t\treturn $emptyFragment\n\t\t}\n\t}\n\t//update\n\tfunction updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, undefined)\n\t\telse if (vnodes == null) removeNodes(old, 0, old.length, vnodes)\n\t\telse {\n\t\t\tif (old.length === vnodes.length) {\n\t\t\t\tvar isUnkeyed = false\n\t\t\t\tfor (var i = 0; i < vnodes.length; i++) {\n\t\t\t\t\tif (vnodes[i] != null && old[i] != null) {\n\t\t\t\t\t\tisUnkeyed = vnodes[i].key == null && old[i].key == null\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isUnkeyed) {\n\t\t\t\t\tfor (var i = 0; i < old.length; i++) {\n\t\t\t\t\t\tif (old[i] === vnodes[i]) continue\n\t\t\t\t\t\telse if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))\n\t\t\t\t\t\telse if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)\n\t\t\t\t\t\telse updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\trecycling = recycling || isRecyclable(old, vnodes)\n\t\t\tif (recycling) {\n\t\t\t\tvar pool = old.pool\n\t\t\t\told = old.concat(old.pool)\n\t\t\t}\n\t\t\tvar oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldStart], v = vnodes[start]\n\t\t\t\tif (o === v && !recycling) oldStart++, start++\n\t\t\t\telse if (o == null) oldStart++\n\t\t\t\telse if (v == null) start++\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar o = old[oldEnd]\n\t\t\t\t\tif (o === v && !recycling) oldEnd--, start++\n\t\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\t\telse if (v == null) start++\n\t\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\t\tif (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))\n\t\t\t\t\t\toldEnd--, start++\n\t\t\t\t\t}\n\t\t\t\t\telse break\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldEnd], v = vnodes[end]\n\t\t\t\tif (o === v && !recycling) oldEnd--, end--\n\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\telse if (v == null) end--\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t\tif (o.dom != null) nextSibling = o.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!map) map = getKeyMap(old, oldEnd)\n\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\tvar oldIndex = map[v.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tvar movable = old[oldIndex]\n\t\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\t\tupdateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)\n\t\t\t\t\t\t\tinsertNode(parent, toFragment(movable), nextSibling)\n\t\t\t\t\t\t\told[oldIndex].skip = true\n\t\t\t\t\t\t\tif (movable.dom != null) nextSibling = movable.dom\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar dom = createNode(parent, v, hooks, undefined, nextSibling)\n\t\t\t\t\t\t\tnextSibling = dom\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tend--\n\t\t\t\t}\n\t\t\t\tif (end < start) break\n\t\t\t}\n\t\t\tcreateNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\tremoveNodes(old, oldStart, oldEnd + 1, vnodes)\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode.tag\n\t\tif (oldTag === tag) {\n\t\t\tvnode.state = old.state\n\t\t\tvnode._state = old._state\n\t\t\tvnode.events = old.events\n\t\t\tif (!recycling && shouldNotUpdate(vnode, old)) return\n\t\t\tif (typeof oldTag === \"string\") {\n\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\tif (recycling) {\n\t\t\t\t\t\tvnode.state = {}\n\t\t\t\t\t\tinitLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t\t}\n\t\t\t\t\telse updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase \"#\": updateText(old, vnode); break\n\t\t\t\t\tcase \"<\": updateHTML(parent, old, vnode, nextSibling); break\n\t\t\t\t\tcase \"[\": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode, recycling, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(old, null)\n\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode) {\n\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\told.dom.nodeValue = vnode.children\n\t\t}\n\t\tvnode.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode, nextSibling) {\n\t\tif (old.children !== vnode.children) {\n\t\t\ttoFragment(old)\n\t\t\tcreateHTML(parent, vnode, nextSibling)\n\t\t}\n\t\telse vnode.dom = old.dom, vnode.domSize = old.domSize\n\t}\n\tfunction updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children = vnode.children\n\t\tvnode.dom = null\n\t\tif (children != null) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (domSize !== 1) vnode.domSize = domSize\n\t\t}\n\t}\n\tfunction updateElement(old, vnode, recycling, hooks, ns) {\n\t\tvar element = vnode.dom = old.dom\n\t\tswitch (vnode.tag) {\n\t\t\tcase \"svg\": ns = \"http://www.w3.org/2000/svg\"; break\n\t\t\tcase \"math\": ns = \"http://www.w3.org/1998/Math/MathML\"; break\n\t\t}\n\t\tif (vnode.tag === \"textarea\") {\n\t\t\tif (vnode.attrs == null) vnode.attrs = {}\n\t\t\tif (vnode.text != null) {\n\t\t\t\tvnode.attrs.value = vnode.text //FIXME handle0 multiple children\n\t\t\t\tvnode.text = undefined\n\t\t\t}\n\t\t}\n\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse if (old.text != null && vnode.text != null && vnode.text !== \"\") {\n\t\t\tif (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text\n\t\t}\n\t\telse {\n\t\t\tif (old.text != null) old.children = [Vnode(\"#\", undefined, undefined, old.text, undefined, old.dom.firstChild)]\n\t\t\tif (vnode.text != null) vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\tupdateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tif (recycling) {\n\t\t\tinitComponent(vnode, hooks)\n\t\t} else {\n\t\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tupdateLifecycle(vnode._state, vnode, hooks)\n\t\t}\n\t\tif (vnode.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse if (old.instance != null) {\n\t\t\tremoveNode(old.instance, null)\n\t\t\tvnode.dom = undefined\n\t\t\tvnode.domSize = 0\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction isRecyclable(old, vnodes) {\n\t\tif (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {\n\t\t\tvar oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0\n\t\t\tvar poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0\n\t\t\tvar vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0\n\t\t\tif (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tfunction getKeyMap(vnodes, end) {\n\t\tvar map = {}, i = 0\n\t\tfor (var i = 0; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tvar key2 = vnode.key\n\t\t\t\tif (key2 != null) map[key2] = i\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\tfunction toFragment(vnode) {\n\t\tvar count0 = vnode.domSize\n\t\tif (count0 != null || vnode.dom == null) {\n\t\t\tvar fragment = $doc.createDocumentFragment()\n\t\t\tif (count0 > 0) {\n\t\t\t\tvar dom = vnode.dom\n\t\t\t\twhile (--count0) fragment.appendChild(dom.nextSibling)\n\t\t\t\tfragment.insertBefore(dom, fragment.firstChild)\n\t\t\t}\n\t\t\treturn fragment\n\t\t}\n\t\telse return vnode.dom\n\t}\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\tfunction insertNode(parent, dom, nextSibling) {\n\t\tif (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\tfunction setContentEditable(vnode) {\n\t\tvar children = vnode.children\n\t\tif (children != null && children.length === 1 && children[0].tag === \"<\") {\n\t\t\tvar content = children[0].children\n\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content\n\t\t}\n\t\telse if (vnode.text != null || children != null && children.length !== 0) throw new Error(\"Child node of a contenteditable must be trusted\")\n\t}\n\t//remove\n\tfunction removeNodes(vnodes, start, end, context) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tif (vnode.skip) vnode.skip = false\n\t\t\t\telse removeNode(vnode, context)\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNode(vnode, context) {\n\t\tvar expected = 1, called = 0\n\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === \"function\") {\n\t\t\tvar result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onbeforeremove === \"function\") {\n\t\t\tvar result = vnode._state.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tcontinuation()\n\t\tfunction continuation() {\n\t\t\tif (++called === expected) {\n\t\t\t\tonremove(vnode)\n\t\t\t\tif (vnode.dom) {\n\t\t\t\t\tvar count0 = vnode.domSize || 1\n\t\t\t\t\tif (count0 > 1) {\n\t\t\t\t\t\tvar dom = vnode.dom\n\t\t\t\t\t\twhile (--count0) {\n\t\t\t\t\t\t\tremoveNodeFromDOM(dom.nextSibling)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tremoveNodeFromDOM(vnode.dom)\n\t\t\t\t\tif (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === \"string\") { //TODO test custom elements\n\t\t\t\t\t\tif (!context.pool) context.pool = [vnode]\n\t\t\t\t\t\telse context.pool.push(vnode)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNodeFromDOM(node) {\n\t\tvar parent = node.parentNode\n\t\tif (parent != null) parent.removeChild(node)\n\t}\n\tfunction onremove(vnode) {\n\t\tif (vnode.attrs && typeof vnode.attrs.onremove === \"function\") vnode.attrs.onremove.call(vnode.state, vnode)\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onremove === \"function\") vnode._state.onremove.call(vnode.state, vnode)\n\t\tif (vnode.instance != null) onremove(vnode.instance)\n\t\telse {\n\t\t\tvar children = vnode.children\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//attrs2\n\tfunction setAttrs(vnode, attrs2, ns) {\n\t\tfor (var key2 in attrs2) {\n\t\t\tsetAttr(vnode, key2, null, attrs2[key2], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode, key2, old, value, ns) {\n\t\tvar element = vnode.dom\n\t\tif (key2 === \"key\" || key2 === \"is\" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== \"object\" || typeof value === \"undefined\" || isLifecycleMethod(key2)) return\n\t\tvar nsLastIndex = key2.indexOf(\":\")\n\t\tif (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === \"xlink\") {\n\t\t\telement.setAttributeNS(\"http://www.w3.org/1999/xlink\", key2.slice(nsLastIndex + 1), value)\n\t\t}\n\t\telse if (key2[0] === \"o\" && key2[1] === \"n\" && typeof value === \"function\") updateEvent(vnode, key2, value)\n\t\telse if (key2 === \"style\") updateStyle(element, old, value)\n\t\telse if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {\n\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\tif (vnode.tag === \"input\" && key2 === \"value\" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return\n\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\tif (vnode.tag === \"select\" && key2 === \"value\" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return\n\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\tif (vnode.tag === \"option\" && key2 === \"value\" && vnode.dom.value == value) return\n\t\t\t// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.\n\t\t\tif (vnode.tag === \"input\" && key2 === \"type\") {\n\t\t\t\telement.setAttribute(key2, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t\telement[key2] = value\n\t\t}\n\t\telse {\n\t\t\tif (typeof value === \"boolean\") {\n\t\t\t\tconsole.log(element, key2);\n\t\t\t\tif (value) element.setAttribute(key2, \"\")\n\t\t\t\telse element.removeAttribute(key2)\n\t\t\t}\n\t\t\telse element.setAttribute(key2 === \"className\" ? \"class\" : key2, value)\n\t\t}\n\t}\n\tfunction setLateAttrs(vnode) {\n\t\tvar attrs2 = vnode.attrs\n\t\tif (vnode.tag === \"select\" && attrs2 != null) {\n\t\t\tif (\"value\" in attrs2) setAttr(vnode, \"value\", null, attrs2.value, undefined)\n\t\t\tif (\"selectedIndex\" in attrs2) setAttr(vnode, \"selectedIndex\", null, attrs2.selectedIndex, undefined)\n\t\t}\n\t}\n\tfunction updateAttrs(vnode, old, attrs2, ns) {\n\t\tif (attrs2 != null) {\n\t\t\tfor (var key2 in attrs2) {\n\t\t\t\tsetAttr(vnode, key2, old && old[key2], attrs2[key2], ns)\n\t\t\t}\n\t\t}\n\t\tif (old != null) {\n\t\t\tfor (var key2 in old) {\n\t\t\t\tif (attrs2 == null || !(key2 in attrs2)) {\n\t\t\t\t\tif (key2 === \"className\") key2 = \"class\"\n\t\t\t\t\tif (key2[0] === \"o\" && key2[1] === \"n\" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)\n\t\t\t\t\telse if (key2 !== \"key\") vnode.dom.removeAttribute(key2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode, attr) {\n\t\treturn attr === \"value\" || attr === \"checked\" || attr === \"selectedIndex\" || attr === \"selected\" && vnode.dom === $doc.activeElement\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === \"oninit\" || attr === \"oncreate\" || attr === \"onupdate\" || attr === \"onremove\" || attr === \"onbeforeremove\" || attr === \"onbeforeupdate\"\n\t}\n\tfunction isAttribute(attr) {\n\t\treturn attr === \"href\" || attr === \"list\" || attr === \"form\" || attr === \"width\" || attr === \"height\"// || attr === \"type\"\n\t}\n\tfunction isCustomElement(vnode){\n\t\treturn vnode.attrs.is || vnode.tag.indexOf(\"-\") > -1\n\t}\n\tfunction hasIntegrationMethods(source) {\n\t\treturn source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)\n\t}\n\t//style\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) element.style.cssText = \"\", old = null\n\t\tif (style == null) element.style.cssText = \"\"\n\t\telse if (typeof style === \"string\") element.style.cssText = style\n\t\telse {\n\t\t\tif (typeof old === \"string\") element.style.cssText = \"\"\n\t\t\tfor (var key2 in style) {\n\t\t\t\telement.style[key2] = style[key2]\n\t\t\t}\n\t\t\tif (old != null && typeof old !== \"string\") {\n\t\t\t\tfor (var key2 in old) {\n\t\t\t\t\tif (!(key2 in style)) element.style[key2] = \"\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//event\n\tfunction updateEvent(vnode, key2, value) {\n\t\tvar element = vnode.dom\n\t\tvar callback = typeof onevent !== \"function\" ? value : function(e) {\n\t\t\tvar result = value.call(element, e)\n\t\t\tonevent.call(element, e)\n\t\t\treturn result\n\t\t}\n\t\tif (key2 in element) element[key2] = typeof value === \"function\" ? callback : null\n\t\telse {\n\t\t\tvar eventName = key2.slice(2)\n\t\t\tif (vnode.events === undefined) vnode.events = {}\n\t\t\tif (vnode.events[key2] === callback) return\n\t\t\tif (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)\n\t\t\tif (typeof value === \"function\") {\n\t\t\t\tvnode.events[key2] = callback\n\t\t\t\telement.addEventListener(eventName, vnode.events[key2], false)\n\t\t\t}\n\t\t}\n\t}\n\t//lifecycle\n\tfunction initLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.oninit === \"function\") source.oninit.call(vnode.state, vnode)\n\t\tif (typeof source.oncreate === \"function\") hooks.push(source.oncreate.bind(vnode.state, vnode))\n\t}\n\tfunction updateLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.onupdate === \"function\") hooks.push(source.onupdate.bind(vnode.state, vnode))\n\t}\n\tfunction shouldNotUpdate(vnode, old) {\n\t\tvar forceVnodeUpdate, forceComponentUpdate\n\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === \"function\") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onbeforeupdate === \"function\") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t\tvnode.instance = old.instance\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\tfunction render(dom, vnodes) {\n\t\tif (!dom) throw new Error(\"Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.\")\n\t\tvar hooks = []\n\t\tvar active = $doc.activeElement\n\t\t// First time0 rendering into a node clears it out\n\t\tif (dom.vnodes == null) dom.textContent = \"\"\n\t\tif (!Array.isArray(vnodes)) vnodes = [vnodes]\n\t\tupdateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, undefined)\n\t\tdom.vnodes = vnodes\n\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t\tif ($doc.activeElement !== active) active.focus()\n\t}\n\treturn {render: render, setEventCallback: setEventCallback}\n}\nfunction throttle(callback) {\n\t//60fps translates to 16.6ms, round it down since setTimeout requires int\n\tvar time = 16\n\tvar last = 0, pending = null\n\tvar timeout = typeof requestAnimationFrame === \"function\" ? requestAnimationFrame : setTimeout\n\treturn function() {\n\t\tvar now = Date.now()\n\t\tif (last === 0 || now - last >= time) {\n\t\t\tlast = now\n\t\t\tcallback()\n\t\t}\n\t\telse if (pending === null) {\n\t\t\tpending = timeout(function() {\n\t\t\t\tpending = null\n\t\t\t\tcallback()\n\t\t\t\tlast = Date.now()\n\t\t\t}, time - (now - last))\n\t\t}\n\t}\n}\nvar _11 = function($window) {\n\tvar renderService = coreRenderer($window)\n\trenderService.setEventCallback(function(e) {\n\t\tif (e.redraw !== false) redraw()\n\t})\n\tvar callbacks = []\n\tfunction subscribe(key1, callback) {\n\t\tunsubscribe(key1)\n\t\tcallbacks.push(key1, throttle(callback))\n\t}\n\tfunction unsubscribe(key1) {\n\t\tvar index = callbacks.indexOf(key1)\n\t\tif (index > -1) callbacks.splice(index, 2)\n\t}\n\tfunction redraw() {\n\t\tfor (var i = 1; i < callbacks.length; i += 2) {\n\t\t\tcallbacks[i]()\n\t\t}\n\t}\n\treturn {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}\n}\nvar redrawService = _11(window)\nrequestService.setCompletionCallback(redrawService.redraw)\nvar _16 = function(redrawService0) {\n\treturn function(root, component) {\n\t\tif (component === null) {\n\t\t\tredrawService0.render(root, [])\n\t\t\tredrawService0.unsubscribe(root)\n\t\t\treturn\n\t\t}\n\t\t\n\t\tif (component.view == null && typeof component !== \"function\") throw new Error(\"m.mount(element, component) expects a component, not a vnode\")\n\t\t\n\t\tvar run0 = function() {\n\t\t\tredrawService0.render(root, Vnode(component))\n\t\t}\n\t\tredrawService0.subscribe(root, run0)\n\t\tredrawService0.redraw()\n\t}\n}\nm.mount = _16(redrawService)\nvar Promise = PromisePolyfill\nvar parseQueryString = function(string) {\n\tif (string === \"\" || string == null) return {}\n\tif (string.charAt(0) === \"?\") string = string.slice(1)\n\tvar entries = string.split(\"&\"), data0 = {}, counters = {}\n\tfor (var i = 0; i < entries.length; i++) {\n\t\tvar entry = entries[i].split(\"=\")\n\t\tvar key5 = decodeURIComponent(entry[0])\n\t\tvar value = entry.length === 2 ? decodeURIComponent(entry[1]) : \"\"\n\t\tif (value === \"true\") value = true\n\t\telse if (value === \"false\") value = false\n\t\tvar levels = key5.split(/\\]\\[?|\\[/)\n\t\tvar cursor = data0\n\t\tif (key5.indexOf(\"[\") > -1) levels.pop()\n\t\tfor (var j = 0; j < levels.length; j++) {\n\t\t\tvar level = levels[j], nextLevel = levels[j + 1]\n\t\t\tvar isNumber = nextLevel == \"\" || !isNaN(parseInt(nextLevel, 10))\n\t\t\tvar isValue = j === levels.length - 1\n\t\t\tif (level === \"\") {\n\t\t\t\tvar key5 = levels.slice(0, j).join()\n\t\t\t\tif (counters[key5] == null) counters[key5] = 0\n\t\t\t\tlevel = counters[key5]++\n\t\t\t}\n\t\t\tif (cursor[level] == null) {\n\t\t\t\tcursor[level] = isValue ? value : isNumber ? [] : {}\n\t\t\t}\n\t\t\tcursor = cursor[level]\n\t\t}\n\t}\n\treturn data0\n}\nvar coreRouter = function($window) {\n\tvar supportsPushState = typeof $window.history.pushState === \"function\"\n\tvar callAsync0 = typeof setImmediate === \"function\" ? setImmediate : setTimeout\n\tfunction normalize1(fragment0) {\n\t\tvar data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)\n\t\tif (fragment0 === \"pathname\" && data[0] !== \"/\") data = \"/\" + data\n\t\treturn data\n\t}\n\tvar asyncId\n\tfunction debounceAsync(callback0) {\n\t\treturn function() {\n\t\t\tif (asyncId != null) return\n\t\t\tasyncId = callAsync0(function() {\n\t\t\t\tasyncId = null\n\t\t\t\tcallback0()\n\t\t\t})\n\t\t}\n\t}\n\tfunction parsePath(path, queryData, hashData) {\n\t\tvar queryIndex = path.indexOf(\"?\")\n\t\tvar hashIndex = path.indexOf(\"#\")\n\t\tvar pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length\n\t\tif (queryIndex > -1) {\n\t\t\tvar queryEnd = hashIndex > -1 ? hashIndex : path.length\n\t\t\tvar queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))\n\t\t\tfor (var key4 in queryParams) queryData[key4] = queryParams[key4]\n\t\t}\n\t\tif (hashIndex > -1) {\n\t\t\tvar hashParams = parseQueryString(path.slice(hashIndex + 1))\n\t\t\tfor (var key4 in hashParams) hashData[key4] = hashParams[key4]\n\t\t}\n\t\treturn path.slice(0, pathEnd)\n\t}\n\tvar router = {prefix: \"#!\"}\n\trouter.getPath = function() {\n\t\tvar type2 = router.prefix.charAt(0)\n\t\tswitch (type2) {\n\t\t\tcase \"#\": return normalize1(\"hash\").slice(router.prefix.length)\n\t\t\tcase \"?\": return normalize1(\"search\").slice(router.prefix.length) + normalize1(\"hash\")\n\t\t\tdefault: return normalize1(\"pathname\").slice(router.prefix.length) + normalize1(\"search\") + normalize1(\"hash\")\n\t\t}\n\t}\n\trouter.setPath = function(path, data, options) {\n\t\tvar queryData = {}, hashData = {}\n\t\tpath = parsePath(path, queryData, hashData)\n\t\tif (data != null) {\n\t\t\tfor (var key4 in data) queryData[key4] = data[key4]\n\t\t\tpath = path.replace(/:([^\\/]+)/g, function(match2, token) {\n\t\t\t\tdelete queryData[token]\n\t\t\t\treturn data[token]\n\t\t\t})\n\t\t}\n\t\tvar query = buildQueryString(queryData)\n\t\tif (query) path += \"?\" + query\n\t\tvar hash = buildQueryString(hashData)\n\t\tif (hash) path += \"#\" + hash\n\t\tif (supportsPushState) {\n\t\t\tvar state = options ? options.state : null\n\t\t\tvar title = options ? options.title : null\n\t\t\t$window.onpopstate()\n\t\t\tif (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)\n\t\t\telse $window.history.pushState(state, title, router.prefix + path)\n\t\t}\n\t\telse $window.location.href = router.prefix + path\n\t}\n\trouter.defineRoutes = function(routes, resolve, reject) {\n\t\tfunction resolveRoute() {\n\t\t\tvar path = router.getPath()\n\t\t\tvar params = {}\n\t\t\tvar pathname = parsePath(path, params, params)\n\t\t\tvar state = $window.history.state\n\t\t\tif (state != null) {\n\t\t\t\tfor (var k in state) params[k] = state[k]\n\t\t\t}\n\t\t\tfor (var route0 in routes) {\n\t\t\t\tvar matcher = new RegExp(\"^\" + route0.replace(/:[^\\/]+?\\.{3}/g, \"(.*?)\").replace(/:[^\\/]+/g, \"([^\\\\/]+)\") + \"\\/?$\")\n\t\t\t\tif (matcher.test(pathname)) {\n\t\t\t\t\tpathname.replace(matcher, function() {\n\t\t\t\t\t\tvar keys = route0.match(/:[^\\/]+/g) || []\n\t\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2)\n\t\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\tparams[keys[i].replace(/:|\\./g, \"\")] = decodeURIComponent(values[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(routes[route0], params, path, route0)\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\treject(path, params)\n\t\t}\n\t\tif (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)\n\t\telse if (router.prefix.charAt(0) === \"#\") $window.onhashchange = resolveRoute\n\t\tresolveRoute()\n\t}\n\treturn router\n}\nvar _20 = function($window, redrawService0) {\n\tvar routeService = coreRouter($window)\n\tvar identity = function(v) {return v}\n\tvar render1, component, attrs3, currentPath, lastUpdate\n\tvar route = function(root, defaultRoute, routes) {\n\t\tif (root == null) throw new Error(\"Ensure the DOM element that was passed to `m.route` is not undefined\")\n\t\tvar run1 = function() {\n\t\t\tif (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))\n\t\t}\n\t\tvar bail = function(path) {\n\t\t\tif (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})\n\t\t\telse throw new Error(\"Could not resolve default route \" + defaultRoute)\n\t\t}\n\t\trouteService.defineRoutes(routes, function(payload, params, path) {\n\t\t\tvar update = lastUpdate = function(routeResolver, comp) {\n\t\t\t\tif (update !== lastUpdate) return\n\t\t\t\tcomponent = comp != null && (typeof comp.view === \"function\" || typeof comp === \"function\")? comp : \"div\"\n\t\t\t\tattrs3 = params, currentPath = path, lastUpdate = null\n\t\t\t\trender1 = (routeResolver.render || identity).bind(routeResolver)\n\t\t\t\trun1()\n\t\t\t}\n\t\t\tif (payload.view || typeof payload === \"function\") update({}, payload)\n\t\t\telse {\n\t\t\t\tif (payload.onmatch) {\n\t\t\t\t\tPromise.resolve(payload.onmatch(params, path)).then(function(resolved) {\n\t\t\t\t\t\tupdate(payload, resolved)\n\t\t\t\t\t}, bail)\n\t\t\t\t}\n\t\t\t\telse update(payload, \"div\")\n\t\t\t}\n\t\t}, bail)\n\t\tredrawService0.subscribe(root, run1)\n\t}\n\troute.set = function(path, data, options) {\n\t\tif (lastUpdate != null) options = {replace: true}\n\t\tlastUpdate = null\n\t\trouteService.setPath(path, data, options)\n\t}\n\troute.get = function() {return currentPath}\n\troute.prefix = function(prefix0) {routeService.prefix = prefix0}\n\troute.link = function(vnode1) {\n\t\tvnode1.dom.setAttribute(\"href\", routeService.prefix + vnode1.attrs.href)\n\t\tvnode1.dom.onclick = function(e) {\n\t\t\tif (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return\n\t\t\te.preventDefault()\n\t\t\te.redraw = false\n\t\t\tvar href = this.getAttribute(\"href\")\n\t\t\tif (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)\n\t\t\troute.set(href, undefined, undefined)\n\t\t}\n\t}\n\troute.param = function(key3) {\n\t\tif(typeof attrs3 !== \"undefined\" && typeof key3 !== \"undefined\") return attrs3[key3]\n\t\treturn attrs3\n\t}\n\treturn route\n}\nm.route = _20(window, redrawService)\nm.withAttr = function(attrName, callback1, context) {\n\treturn function(e) {\n\t\tcallback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))\n\t}\n}\nvar _28 = coreRenderer(window)\nm.render = _28.render\nm.redraw = redrawService.redraw\nm.request = requestService.request\nm.jsonp = requestService.jsonp\nm.parseQueryString = parseQueryString\nm.buildQueryString = buildQueryString\nm.version = \"1.1.1\"\nm.vnode = Vnode\nif (true) module[\"exports\"] = m\nelse window.m = m\n}());\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../timers-browserify/main.js */ 9).setImmediate, __webpack_require__(/*! ./../webpack/buildin/global.js */ 0)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbWl0aHJpbC9taXRocmlsLmpzP2JkNDIiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG9uZXZlbnRcblx0ZnVuY3Rpb24gc2V0RXZlbnRDYWxsYmFjayhjYWxsYmFjaykge3JldHVybiBvbmV2ZW50ID0gY2FsbGJhY2t9XG5cdC8vY3JlYXRlXG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRzd2l0Y2ggKHRhZykge1xuXHRcdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIjxcIjogcmV0dXJuIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCJbXCI6IHJldHVybiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHJldHVybiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dm5vZGUuZG9tID0gJGRvYy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS5jaGlsZHJlbilcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgdm5vZGUuZG9tLCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZhciBtYXRjaDEgPSB2bm9kZS5jaGlsZHJlbi5tYXRjaCgvXlxccyo/PChcXHcrKS9pbSkgfHwgW11cblx0XHR2YXIgcGFyZW50MSA9IHtjYXB0aW9uOiBcInRhYmxlXCIsIHRoZWFkOiBcInRhYmxlXCIsIHRib2R5OiBcInRhYmxlXCIsIHRmb290OiBcInRhYmxlXCIsIHRyOiBcInRib2R5XCIsIHRoOiBcInRyXCIsIHRkOiBcInRyXCIsIGNvbGdyb3VwOiBcInRhYmxlXCIsIGNvbDogXCJjb2xncm91cFwifVttYXRjaDFbMV1dIHx8IFwiZGl2XCJcblx0XHR2YXIgdGVtcCA9ICRkb2MuY3JlYXRlRWxlbWVudChwYXJlbnQxKVxuXHRcdHRlbXAuaW5uZXJIVE1MID0gdm5vZGUuY2hpbGRyZW5cblx0XHR2bm9kZS5kb20gPSB0ZW1wLmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gdGVtcC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0dmFyIGNoaWxkXG5cdFx0d2hpbGUgKGNoaWxkID0gdGVtcC5maXJzdENoaWxkKSB7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZClcblx0XHR9XG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGNyZWF0ZU5vZGVzKGZyYWdtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IGZyYWdtZW50LmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdHZhciBpcyA9IGF0dHJzMiAmJiBhdHRyczIuaXNcblx0XHR2YXIgZWxlbWVudCA9IG5zID9cblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZykgOlxuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnKVxuXHRcdHZub2RlLmRvbSA9IGVsZW1lbnRcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdHNldEF0dHJzKHZub2RlLCBhdHRyczIsIG5zKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS50ZXh0ICE9PSBcIlwiKSBlbGVtZW50LnRleHRDb250ZW50ID0gdm5vZGUudGV4dFxuXHRcdFx0XHRlbHNlIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0fVxuXHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdFx0Y3JlYXRlTm9kZXMoZWxlbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdFx0XHRzZXRMYXRlQXR0cnModm5vZGUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpIHtcblx0XHR2YXIgc2VudGluZWxcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZy52aWV3ID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gT2JqZWN0LmNyZWF0ZSh2bm9kZS50YWcpXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnN0YXRlLnZpZXdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHZvaWQgMFxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS50YWdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdFx0dm5vZGUuc3RhdGUgPSAodm5vZGUudGFnLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS50YWcucHJvdG90eXBlLnZpZXcgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgdm5vZGUudGFnKHZub2RlKSA6IHZub2RlLnRhZyh2bm9kZSlcblx0XHR9XG5cdFx0dm5vZGUuX3N0YXRlID0gdm5vZGUuc3RhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdGluaXRMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSBudWxsXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5kb20gIT0gbnVsbCA/IHZub2RlLmluc3RhbmNlLmRvbVNpemUgOiAwXG5cdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRyZXR1cm4gZWxlbWVudFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0XHRyZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHR9XG5cdH1cblx0Ly91cGRhdGVcblx0ZnVuY3Rpb24gdXBkYXRlTm9kZXMocGFyZW50LCBvbGQsIHZub2RlcywgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0aWYgKG9sZCA9PT0gdm5vZGVzIHx8IG9sZCA9PSBudWxsICYmIHZub2RlcyA9PSBudWxsKSByZXR1cm5cblx0XHRlbHNlIGlmIChvbGQgPT0gbnVsbCkgY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIDAsIHZub2Rlcy5sZW5ndGgsIGhvb2tzLCBuZXh0U2libGluZywgdW5kZWZpbmVkKVxuXHRcdGVsc2UgaWYgKHZub2RlcyA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIDAsIG9sZC5sZW5ndGgsIHZub2Rlcylcblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQubGVuZ3RoID09PSB2bm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpc1Vua2V5ZWQgPSBmYWxzZVxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiBvbGRbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aXNVbmtleWVkID0gdm5vZGVzW2ldLmtleSA9PSBudWxsICYmIG9sZFtpXS5rZXkgPT0gbnVsbFxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzVW5rZXllZCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkW2ldID09PSB2bm9kZXNbaV0pIGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChvbGRbaV0gPT0gbnVsbCAmJiB2bm9kZXNbaV0gIT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2Rlc1tpXSwgaG9va3MsIG5zLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRlbHNlIGlmICh2bm9kZXNbaV0gPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCBpLCBpICsgMSwgdm5vZGVzKVxuXHRcdFx0XHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkW2ldLCB2bm9kZXNbaV0sIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWN5Y2xpbmcgPSByZWN5Y2xpbmcgfHwgaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKVxuXHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHR2YXIgcG9vbCA9IG9sZC5wb29sXG5cdFx0XHRcdG9sZCA9IG9sZC5jb25jYXQob2xkLnBvb2wpXG5cdFx0XHR9XG5cdFx0XHR2YXIgb2xkU3RhcnQgPSAwLCBzdGFydCA9IDAsIG9sZEVuZCA9IG9sZC5sZW5ndGggLSAxLCBlbmQgPSB2bm9kZXMubGVuZ3RoIC0gMSwgbWFwXG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRTdGFydF0sIHYgPSB2bm9kZXNbc3RhcnRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRTdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkU3RhcnQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdXG5cdFx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdFx0aWYgKHJlY3ljbGluZyB8fCBzdGFydCA8IGVuZCkgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgYnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXSwgdiA9IHZub2Rlc1tlbmRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRpZiAoby5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBvLmRvbVxuXHRcdFx0XHRcdG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICghbWFwKSBtYXAgPSBnZXRLZXlNYXAob2xkLCBvbGRFbmQpXG5cdFx0XHRcdFx0aWYgKHYgIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dmFyIG9sZEluZGV4ID0gbWFwW3Yua2V5XVxuXHRcdFx0XHRcdFx0aWYgKG9sZEluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG1vdmFibGUgPSBvbGRbb2xkSW5kZXhdXG5cdFx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRJbmRleCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBtb3ZhYmxlLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0XHRcdGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG1vdmFibGUpLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0b2xkW29sZEluZGV4XS5za2lwID0gdHJ1ZVxuXHRcdFx0XHRcdFx0XHRpZiAobW92YWJsZS5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBtb3ZhYmxlLmRvbVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkb20gPSBjcmVhdGVOb2RlKHBhcmVudCwgdiwgaG9va3MsIHVuZGVmaW5lZCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdGlmICh2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikge1xuXHRcdFx0aWYgKHZub2RlLmF0dHJzID09IG51bGwpIHZub2RlLmF0dHJzID0ge31cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuYXR0cnMudmFsdWUgPSB2bm9kZS50ZXh0IC8vRklYTUUgaGFuZGxlMCBtdWx0aXBsZSBjaGlsZHJlblxuXHRcdFx0XHR2bm9kZS50ZXh0ID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQuYXR0cnMsIHZub2RlLmF0dHJzLCBucylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9PSBcIlwiKSB7XG5cdFx0XHRpZiAob2xkLnRleHQudG9TdHJpbmcoKSAhPT0gdm5vZGUudGV4dC50b1N0cmluZygpKSBvbGQuZG9tLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdm5vZGUudGV4dFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQudGV4dCAhPSBudWxsKSBvbGQuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGQudGV4dCwgdW5kZWZpbmVkLCBvbGQuZG9tLmZpcnN0Q2hpbGQpXVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkgdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR1cGRhdGVOb2RlcyhlbGVtZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHR1cGRhdGVMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0fVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAob2xkLmluc3RhbmNlID09IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZC5pbnN0YW5jZSwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmluc3RhbmNlLmRvbVNpemVcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLmluc3RhbmNlLCBudWxsKVxuXHRcdFx0dm5vZGUuZG9tID0gdW5kZWZpbmVkXG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpIHtcblx0XHRpZiAob2xkLnBvb2wgIT0gbnVsbCAmJiBNYXRoLmFicyhvbGQucG9vbC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSA8PSBNYXRoLmFicyhvbGQubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBvbGRDaGlsZHJlbkxlbmd0aCA9IG9sZFswXSAmJiBvbGRbMF0uY2hpbGRyZW4gJiYgb2xkWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgcG9vbENoaWxkcmVuTGVuZ3RoID0gb2xkLnBvb2xbMF0gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciB2bm9kZXNDaGlsZHJlbkxlbmd0aCA9IHZub2Rlc1swXSAmJiB2bm9kZXNbMF0uY2hpbGRyZW4gJiYgdm5vZGVzWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHRpZiAoTWF0aC5hYnMocG9vbENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpIDw9IE1hdGguYWJzKG9sZENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIGdldEtleU1hcCh2bm9kZXMsIGVuZCkge1xuXHRcdHZhciBtYXAgPSB7fSwgaSA9IDBcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBrZXkyID0gdm5vZGUua2V5XG5cdFx0XHRcdGlmIChrZXkyICE9IG51bGwpIG1hcFtrZXkyXSA9IGlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG5cdGZ1bmN0aW9uIHRvRnJhZ21lbnQodm5vZGUpIHtcblx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZVxuXHRcdGlmIChjb3VudDAgIT0gbnVsbCB8fCB2bm9kZS5kb20gPT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRcdGlmIChjb3VudDAgPiAwKSB7XG5cdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdGZyYWdtZW50Lmluc2VydEJlZm9yZShkb20sIGZyYWdtZW50LmZpcnN0Q2hpbGQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnJhZ21lbnRcblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcodm5vZGVzLCBpLCBuZXh0U2libGluZykge1xuXHRcdGZvciAoOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgdm5vZGVzW2ldLmRvbSAhPSBudWxsKSByZXR1cm4gdm5vZGVzW2ldLmRvbVxuXHRcdH1cblx0XHRyZXR1cm4gbmV4dFNpYmxpbmdcblx0fVxuXHRmdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudCwgZG9tLCBuZXh0U2libGluZykge1xuXHRcdGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnROb2RlKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9tKVxuXHR9XG5cdGZ1bmN0aW9uIHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCI8XCIpIHtcblx0XHRcdHZhciBjb250ZW50ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0XHRcdGlmICh2bm9kZS5kb20uaW5uZXJIVE1MICE9PSBjb250ZW50KSB2bm9kZS5kb20uaW5uZXJIVE1MID0gY29udGVudFxuXHRcdH1cblx0XHRlbHNlIGlmICh2bm9kZS50ZXh0ICE9IG51bGwgfHwgY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG5vZGUgb2YgYSBjb250ZW50ZWRpdGFibGUgbXVzdCBiZSB0cnVzdGVkXCIpXG5cdH1cblx0Ly9yZW1vdmVcblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZXModm5vZGVzLCBzdGFydCwgZW5kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnNraXApIHZub2RlLnNraXAgPSBmYWxzZVxuXHRcdFx0XHRlbHNlIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpIHtcblx0XHR2YXIgZXhwZWN0ZWQgPSAxLCBjYWxsZWQgPSAwXG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnRpbnVhdGlvbigpXG5cdFx0ZnVuY3Rpb24gY29udGludWF0aW9uKCkge1xuXHRcdFx0aWYgKCsrY2FsbGVkID09PSBleHBlY3RlZCkge1xuXHRcdFx0XHRvbnJlbW92ZSh2bm9kZSlcblx0XHRcdFx0aWYgKHZub2RlLmRvbSkge1xuXHRcdFx0XHRcdHZhciBjb3VudDAgPSB2bm9kZS5kb21TaXplIHx8IDFcblx0XHRcdFx0XHRpZiAoY291bnQwID4gMSkge1xuXHRcdFx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00odm5vZGUuZG9tKVxuXHRcdFx0XHRcdGlmIChjb250ZXh0ICE9IG51bGwgJiYgdm5vZGUuZG9tU2l6ZSA9PSBudWxsICYmICFoYXNJbnRlZ3JhdGlvbk1ldGhvZHModm5vZGUuYXR0cnMpICYmIHR5cGVvZiB2bm9kZS50YWcgPT09IFwic3RyaW5nXCIpIHsgLy9UT0RPIHRlc3QgY3VzdG9tIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnRleHQucG9vbCkgY29udGV4dC5wb29sID0gW3Zub2RlXVxuXHRcdFx0XHRcdFx0ZWxzZSBjb250ZXh0LnBvb2wucHVzaCh2bm9kZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZUZyb21ET00obm9kZSkge1xuXHRcdHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGVcblx0XHRpZiAocGFyZW50ICE9IG51bGwpIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKVxuXHR9XG5cdGZ1bmN0aW9uIG9ucmVtb3ZlKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5hdHRycy5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLl9zdGF0ZS5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkgb25yZW1vdmUodm5vZGUuaW5zdGFuY2UpXG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsKSBvbnJlbW92ZShjaGlsZClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2F0dHJzMlxuXHRmdW5jdGlvbiBzZXRBdHRycyh2bm9kZSwgYXR0cnMyLCBucykge1xuXHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRzZXRBdHRyKHZub2RlLCBrZXkyLCBudWxsLCBhdHRyczJba2V5Ml0sIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRBdHRyKHZub2RlLCBrZXkyLCBvbGQsIHZhbHVlLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0aWYgKGtleTIgPT09IFwia2V5XCIgfHwga2V5MiA9PT0gXCJpc1wiIHx8IChvbGQgPT09IHZhbHVlICYmICFpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGtleTIpKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IGlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSByZXR1cm5cblx0XHR2YXIgbnNMYXN0SW5kZXggPSBrZXkyLmluZGV4T2YoXCI6XCIpXG5cdFx0aWYgKG5zTGFzdEluZGV4ID4gLTEgJiYga2V5Mi5zdWJzdHIoMCwgbnNMYXN0SW5kZXgpID09PSBcInhsaW5rXCIpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIGtleTIuc2xpY2UobnNMYXN0SW5kZXggKyAxKSwgdmFsdWUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGtleTJbMF0gPT09IFwib1wiICYmIGtleTJbMV0gPT09IFwiblwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5MiA9PT0gXCJzdHlsZVwiKSB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgaW4gZWxlbWVudCAmJiAhaXNBdHRyaWJ1dGUoa2V5MikgJiYgbnMgPT09IHVuZGVmaW5lZCAmJiAhaXNDdXN0b21FbGVtZW50KHZub2RlKSkge1xuXHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiAmJiBrZXkyID09PSBcInZhbHVlXCIgJiYgdm5vZGUuZG9tLnZhbHVlID09IHZhbHVlICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcInNlbGVjdFwiICYmIGtleTIgPT09IFwidmFsdWVcIiAmJiB2bm9kZS5kb20udmFsdWUgPT0gdmFsdWUgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0Ly9zZXR0aW5nIG9wdGlvblt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwib3B0aW9uXCIgJiYga2V5MiA9PT0gXCJ2YWx1ZVwiICYmIHZub2RlLmRvbS52YWx1ZSA9PSB2YWx1ZSkgcmV0dXJuXG5cdFx0XHQvLyBJZiB5b3UgYXNzaWduIGFuIGlucHV0IHR5cGUxIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRSAxMSB3aXRoIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiwgYW4gZXJyb3IwIHdpbGwgb2NjdXIuXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcImlucHV0XCIgJiYga2V5MiA9PT0gXCJ0eXBlXCIpIHtcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgdmFsdWUpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudFtrZXkyXSA9IHZhbHVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coZWxlbWVudCwga2V5Mik7XG5cdFx0XHRcdGlmICh2YWx1ZSkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgXCJcIilcblx0XHRcdFx0ZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyID09PSBcImNsYXNzTmFtZVwiID8gXCJjbGFzc1wiIDoga2V5MiwgdmFsdWUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldExhdGVBdHRycyh2bm9kZSkge1xuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYgYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGlmIChcInZhbHVlXCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInZhbHVlXCIsIG51bGwsIGF0dHJzMi52YWx1ZSwgdW5kZWZpbmVkKVxuXHRcdFx0aWYgKFwic2VsZWN0ZWRJbmRleFwiIGluIGF0dHJzMikgc2V0QXR0cih2bm9kZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwsIGF0dHJzMi5zZWxlY3RlZEluZGV4LCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQsIGF0dHJzMiwgbnMpIHtcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRcdHNldEF0dHIodm5vZGUsIGtleTIsIG9sZCAmJiBvbGRba2V5Ml0sIGF0dHJzMltrZXkyXSwgbnMpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChvbGQgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0aWYgKGF0dHJzMiA9PSBudWxsIHx8ICEoa2V5MiBpbiBhdHRyczIpKSB7XG5cdFx0XHRcdFx0aWYgKGtleTIgPT09IFwiY2xhc3NOYW1lXCIpIGtleTIgPSBcImNsYXNzXCJcblx0XHRcdFx0XHRpZiAoa2V5MlswXSA9PT0gXCJvXCIgJiYga2V5MlsxXSA9PT0gXCJuXCIgJiYgIWlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGVsc2UgaWYgKGtleTIgIT09IFwia2V5XCIpIHZub2RlLmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5Milcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJ2YWx1ZVwiIHx8IGF0dHIgPT09IFwiY2hlY2tlZFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRJbmRleFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRcIiAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGlzTGlmZWN5Y2xlTWV0aG9kKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJvbmluaXRcIiB8fCBhdHRyID09PSBcIm9uY3JlYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnVwZGF0ZVwiIHx8IGF0dHIgPT09IFwib25yZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JlcmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXVwZGF0ZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNBdHRyaWJ1dGUoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcImhyZWZcIiB8fCBhdHRyID09PSBcImxpc3RcIiB8fCBhdHRyID09PSBcImZvcm1cIiB8fCBhdHRyID09PSBcIndpZHRoXCIgfHwgYXR0ciA9PT0gXCJoZWlnaHRcIi8vIHx8IGF0dHIgPT09IFwidHlwZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNDdXN0b21FbGVtZW50KHZub2RlKXtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMuaXMgfHwgdm5vZGUudGFnLmluZGV4T2YoXCItXCIpID4gLTFcblx0fVxuXHRmdW5jdGlvbiBoYXNJbnRlZ3JhdGlvbk1ldGhvZHMoc291cmNlKSB7XG5cdFx0cmV0dXJuIHNvdXJjZSAhPSBudWxsICYmIChzb3VyY2Uub25jcmVhdGUgfHwgc291cmNlLm9udXBkYXRlIHx8IHNvdXJjZS5vbmJlZm9yZXJlbW92ZSB8fCBzb3VyY2Uub25yZW1vdmUpXG5cdH1cblx0Ly9zdHlsZVxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHN0eWxlKSB7XG5cdFx0aWYgKG9sZCA9PT0gc3R5bGUpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCIsIG9sZCA9IG51bGxcblx0XHRpZiAoc3R5bGUgPT0gbnVsbCkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVcblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIHN0eWxlKSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5Ml0gPSBzdHlsZVtrZXkyXVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9sZCAhPSBudWxsICYmIHR5cGVvZiBvbGQgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0XHRpZiAoIShrZXkyIGluIHN0eWxlKSkgZWxlbWVudC5zdHlsZVtrZXkyXSA9IFwiXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2V2ZW50XG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB2YWx1ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0dmFyIGNhbGxiYWNrID0gdHlwZW9mIG9uZXZlbnQgIT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlIDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZhbHVlLmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdG9uZXZlbnQuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdH1cblx0XHRpZiAoa2V5MiBpbiBlbGVtZW50KSBlbGVtZW50W2tleTJdID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYWxsYmFjayA6IG51bGxcblx0XHRlbHNlIHtcblx0XHRcdHZhciBldmVudE5hbWUgPSBrZXkyLnNsaWNlKDIpXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzID09PSB1bmRlZmluZWQpIHZub2RlLmV2ZW50cyA9IHt9XG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdID09PSBjYWxsYmFjaykgcmV0dXJuXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdICE9IG51bGwpIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXkyXSwgZmFsc2UpXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dm5vZGUuZXZlbnRzW2tleTJdID0gY2FsbGJhY2tcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9saWZlY3ljbGVcblx0ZnVuY3Rpb24gaW5pdExpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uaW5pdCA9PT0gXCJmdW5jdGlvblwiKSBzb3VyY2Uub25pbml0LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9uY3JlYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbnVwZGF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpIHtcblx0XHR2YXIgZm9yY2VWbm9kZVVwZGF0ZSwgZm9yY2VDb21wb25lbnRVcGRhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VWbm9kZVVwZGF0ZSA9IHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICghKGZvcmNlVm5vZGVVcGRhdGUgPT09IHVuZGVmaW5lZCAmJiBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSAmJiAhZm9yY2VWbm9kZVVwZGF0ZSAmJiAhZm9yY2VDb21wb25lbnRVcGRhdGUpIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBvbGQuaW5zdGFuY2Vcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIHJlbmRlcihkb20sIHZub2Rlcykge1xuXHRcdGlmICghZG9tKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIilcblx0XHR2YXIgaG9va3MgPSBbXVxuXHRcdHZhciBhY3RpdmUgPSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0XHQvLyBGaXJzdCB0aW1lMCByZW5kZXJpbmcgaW50byBhIG5vZGUgY2xlYXJzIGl0IG91dFxuXHRcdGlmIChkb20udm5vZGVzID09IG51bGwpIGRvbS50ZXh0Q29udGVudCA9IFwiXCJcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkodm5vZGVzKSkgdm5vZGVzID0gW3Zub2Rlc11cblx0XHR1cGRhdGVOb2Rlcyhkb20sIGRvbS52bm9kZXMsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlcyksIGZhbHNlLCBob29rcywgbnVsbCwgdW5kZWZpbmVkKVxuXHRcdGRvbS52bm9kZXMgPSB2bm9kZXNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSBob29rc1tpXSgpXG5cdFx0aWYgKCRkb2MuYWN0aXZlRWxlbWVudCAhPT0gYWN0aXZlKSBhY3RpdmUuZm9jdXMoKVxuXHR9XG5cdHJldHVybiB7cmVuZGVyOiByZW5kZXIsIHNldEV2ZW50Q2FsbGJhY2s6IHNldEV2ZW50Q2FsbGJhY2t9XG59XG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaykge1xuXHQvLzYwZnBzIHRyYW5zbGF0ZXMgdG8gMTYuNm1zLCByb3VuZCBpdCBkb3duIHNpbmNlIHNldFRpbWVvdXQgcmVxdWlyZXMgaW50XG5cdHZhciB0aW1lID0gMTZcblx0dmFyIGxhc3QgPSAwLCBwZW5kaW5nID0gbnVsbFxuXHR2YXIgdGltZW91dCA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwiZnVuY3Rpb25cIiA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHNldFRpbWVvdXRcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpXG5cdFx0aWYgKGxhc3QgPT09IDAgfHwgbm93IC0gbGFzdCA+PSB0aW1lKSB7XG5cdFx0XHRsYXN0ID0gbm93XG5cdFx0XHRjYWxsYmFjaygpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcblx0XHRcdHBlbmRpbmcgPSB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwZW5kaW5nID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjaygpXG5cdFx0XHRcdGxhc3QgPSBEYXRlLm5vdygpXG5cdFx0XHR9LCB0aW1lIC0gKG5vdyAtIGxhc3QpKVxuXHRcdH1cblx0fVxufVxudmFyIF8xMSA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHJlbmRlclNlcnZpY2UgPSBjb3JlUmVuZGVyZXIoJHdpbmRvdylcblx0cmVuZGVyU2VydmljZS5zZXRFdmVudENhbGxiYWNrKGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZS5yZWRyYXcgIT09IGZhbHNlKSByZWRyYXcoKVxuXHR9KVxuXHR2YXIgY2FsbGJhY2tzID0gW11cblx0ZnVuY3Rpb24gc3Vic2NyaWJlKGtleTEsIGNhbGxiYWNrKSB7XG5cdFx0dW5zdWJzY3JpYmUoa2V5MSlcblx0XHRjYWxsYmFja3MucHVzaChrZXkxLCB0aHJvdHRsZShjYWxsYmFjaykpXG5cdH1cblx0ZnVuY3Rpb24gdW5zdWJzY3JpYmUoa2V5MSkge1xuXHRcdHZhciBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGtleTEpXG5cdFx0aWYgKGluZGV4ID4gLTEpIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDIpXG5cdH1cblx0ZnVuY3Rpb24gcmVkcmF3KCkge1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0XHRjYWxsYmFja3NbaV0oKVxuXHRcdH1cblx0fVxuXHRyZXR1cm4ge3N1YnNjcmliZTogc3Vic2NyaWJlLCB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUsIHJlZHJhdzogcmVkcmF3LCByZW5kZXI6IHJlbmRlclNlcnZpY2UucmVuZGVyfVxufVxudmFyIHJlZHJhd1NlcnZpY2UgPSBfMTEod2luZG93KVxucmVxdWVzdFNlcnZpY2Uuc2V0Q29tcGxldGlvbkNhbGxiYWNrKHJlZHJhd1NlcnZpY2UucmVkcmF3KVxudmFyIF8xNiA9IGZ1bmN0aW9uKHJlZHJhd1NlcnZpY2UwKSB7XG5cdHJldHVybiBmdW5jdGlvbihyb290LCBjb21wb25lbnQpIHtcblx0XHRpZiAoY29tcG9uZW50ID09PSBudWxsKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgW10pXG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC51bnN1YnNjcmliZShyb290KVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdFxuXHRcdGlmIChjb21wb25lbnQudmlldyA9PSBudWxsICYmIHR5cGVvZiBjb21wb25lbnQgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwibS5tb3VudChlbGVtZW50LCBjb21wb25lbnQpIGV4cGVjdHMgYSBjb21wb25lbnQsIG5vdCBhIHZub2RlXCIpXG5cdFx0XG5cdFx0dmFyIHJ1bjAgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCBWbm9kZShjb21wb25lbnQpKVxuXHRcdH1cblx0XHRyZWRyYXdTZXJ2aWNlMC5zdWJzY3JpYmUocm9vdCwgcnVuMClcblx0XHRyZWRyYXdTZXJ2aWNlMC5yZWRyYXcoKVxuXHR9XG59XG5tLm1vdW50ID0gXzE2KHJlZHJhd1NlcnZpY2UpXG52YXIgUHJvbWlzZSA9IFByb21pc2VQb2x5ZmlsbFxudmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0aWYgKHN0cmluZyA9PT0gXCJcIiB8fCBzdHJpbmcgPT0gbnVsbCkgcmV0dXJuIHt9XG5cdGlmIChzdHJpbmcuY2hhckF0KDApID09PSBcIj9cIikgc3RyaW5nID0gc3RyaW5nLnNsaWNlKDEpXG5cdHZhciBlbnRyaWVzID0gc3RyaW5nLnNwbGl0KFwiJlwiKSwgZGF0YTAgPSB7fSwgY291bnRlcnMgPSB7fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZW50cnkgPSBlbnRyaWVzW2ldLnNwbGl0KFwiPVwiKVxuXHRcdHZhciBrZXk1ID0gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5WzBdKVxuXHRcdHZhciB2YWx1ZSA9IGVudHJ5Lmxlbmd0aCA9PT0gMiA/IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVsxXSkgOiBcIlwiXG5cdFx0aWYgKHZhbHVlID09PSBcInRydWVcIikgdmFsdWUgPSB0cnVlXG5cdFx0ZWxzZSBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikgdmFsdWUgPSBmYWxzZVxuXHRcdHZhciBsZXZlbHMgPSBrZXk1LnNwbGl0KC9cXF1cXFs/fFxcWy8pXG5cdFx0dmFyIGN1cnNvciA9IGRhdGEwXG5cdFx0aWYgKGtleTUuaW5kZXhPZihcIltcIikgPiAtMSkgbGV2ZWxzLnBvcCgpXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdHZhciBsZXZlbCA9IGxldmVsc1tqXSwgbmV4dExldmVsID0gbGV2ZWxzW2ogKyAxXVxuXHRcdFx0dmFyIGlzTnVtYmVyID0gbmV4dExldmVsID09IFwiXCIgfHwgIWlzTmFOKHBhcnNlSW50KG5leHRMZXZlbCwgMTApKVxuXHRcdFx0dmFyIGlzVmFsdWUgPSBqID09PSBsZXZlbHMubGVuZ3RoIC0gMVxuXHRcdFx0aWYgKGxldmVsID09PSBcIlwiKSB7XG5cdFx0XHRcdHZhciBrZXk1ID0gbGV2ZWxzLnNsaWNlKDAsIGopLmpvaW4oKVxuXHRcdFx0XHRpZiAoY291bnRlcnNba2V5NV0gPT0gbnVsbCkgY291bnRlcnNba2V5NV0gPSAwXG5cdFx0XHRcdGxldmVsID0gY291bnRlcnNba2V5NV0rK1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnNvcltsZXZlbF0gPT0gbnVsbCkge1xuXHRcdFx0XHRjdXJzb3JbbGV2ZWxdID0gaXNWYWx1ZSA/IHZhbHVlIDogaXNOdW1iZXIgPyBbXSA6IHt9XG5cdFx0XHR9XG5cdFx0XHRjdXJzb3IgPSBjdXJzb3JbbGV2ZWxdXG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhMFxufVxudmFyIGNvcmVSb3V0ZXIgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9IHR5cGVvZiAkd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID09PSBcImZ1bmN0aW9uXCJcblx0dmFyIGNhbGxBc3luYzAgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZTEoZnJhZ21lbnQwKSB7XG5cdFx0dmFyIGRhdGEgPSAkd2luZG93LmxvY2F0aW9uW2ZyYWdtZW50MF0ucmVwbGFjZSgvKD86JVthLWY4OV1bYS1mMC05XSkrL2dpbSwgZGVjb2RlVVJJQ29tcG9uZW50KVxuXHRcdGlmIChmcmFnbWVudDAgPT09IFwicGF0aG5hbWVcIiAmJiBkYXRhWzBdICE9PSBcIi9cIikgZGF0YSA9IFwiL1wiICsgZGF0YVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0dmFyIGFzeW5jSWRcblx0ZnVuY3Rpb24gZGVib3VuY2VBc3luYyhjYWxsYmFjazApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoYXN5bmNJZCAhPSBudWxsKSByZXR1cm5cblx0XHRcdGFzeW5jSWQgPSBjYWxsQXN5bmMwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRhc3luY0lkID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjazAoKVxuXHRcdFx0fSlcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgsIHF1ZXJ5RGF0YSwgaGFzaERhdGEpIHtcblx0XHR2YXIgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIilcblx0XHR2YXIgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiI1wiKVxuXHRcdHZhciBwYXRoRW5kID0gcXVlcnlJbmRleCA+IC0xID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogcGF0aC5sZW5ndGhcblx0XHRpZiAocXVlcnlJbmRleCA+IC0xKSB7XG5cdFx0XHR2YXIgcXVlcnlFbmQgPSBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHBhdGgubGVuZ3RoXG5cdFx0XHR2YXIgcXVlcnlQYXJhbXMgPSBwYXJzZVF1ZXJ5U3RyaW5nKHBhdGguc2xpY2UocXVlcnlJbmRleCArIDEsIHF1ZXJ5RW5kKSlcblx0XHRcdGZvciAodmFyIGtleTQgaW4gcXVlcnlQYXJhbXMpIHF1ZXJ5RGF0YVtrZXk0XSA9IHF1ZXJ5UGFyYW1zW2tleTRdXG5cdFx0fVxuXHRcdGlmIChoYXNoSW5kZXggPiAtMSkge1xuXHRcdFx0dmFyIGhhc2hQYXJhbXMgPSBwYXJzZVF1ZXJ5U3RyaW5nKHBhdGguc2xpY2UoaGFzaEluZGV4ICsgMSkpXG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIGhhc2hQYXJhbXMpIGhhc2hEYXRhW2tleTRdID0gaGFzaFBhcmFtc1trZXk0XVxuXHRcdH1cblx0XHRyZXR1cm4gcGF0aC5zbGljZSgwLCBwYXRoRW5kKVxuXHR9XG5cdHZhciByb3V0ZXIgPSB7cHJlZml4OiBcIiMhXCJ9XG5cdHJvdXRlci5nZXRQYXRoID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHR5cGUyID0gcm91dGVyLnByZWZpeC5jaGFyQXQoMClcblx0XHRzd2l0Y2ggKHR5cGUyKSB7XG5cdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gbm9ybWFsaXplMShcImhhc2hcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpXG5cdFx0XHRjYXNlIFwiP1wiOiByZXR1cm4gbm9ybWFsaXplMShcInNlYXJjaFwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aCkgKyBub3JtYWxpemUxKFwiaGFzaFwiKVxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIG5vcm1hbGl6ZTEoXCJwYXRobmFtZVwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aCkgKyBub3JtYWxpemUxKFwic2VhcmNoXCIpICsgbm9ybWFsaXplMShcImhhc2hcIilcblx0XHR9XG5cdH1cblx0cm91dGVyLnNldFBhdGggPSBmdW5jdGlvbihwYXRoLCBkYXRhLCBvcHRpb25zKSB7XG5cdFx0dmFyIHF1ZXJ5RGF0YSA9IHt9LCBoYXNoRGF0YSA9IHt9XG5cdFx0cGF0aCA9IHBhcnNlUGF0aChwYXRoLCBxdWVyeURhdGEsIGhhc2hEYXRhKVxuXHRcdGlmIChkYXRhICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTQgaW4gZGF0YSkgcXVlcnlEYXRhW2tleTRdID0gZGF0YVtrZXk0XVxuXHRcdFx0cGF0aCA9IHBhdGgucmVwbGFjZSgvOihbXlxcL10rKS9nLCBmdW5jdGlvbihtYXRjaDIsIHRva2VuKSB7XG5cdFx0XHRcdGRlbGV0ZSBxdWVyeURhdGFbdG9rZW5dXG5cdFx0XHRcdHJldHVybiBkYXRhW3Rva2VuXVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0dmFyIHF1ZXJ5ID0gYnVpbGRRdWVyeVN0cmluZyhxdWVyeURhdGEpXG5cdFx0aWYgKHF1ZXJ5KSBwYXRoICs9IFwiP1wiICsgcXVlcnlcblx0XHR2YXIgaGFzaCA9IGJ1aWxkUXVlcnlTdHJpbmcoaGFzaERhdGEpXG5cdFx0aWYgKGhhc2gpIHBhdGggKz0gXCIjXCIgKyBoYXNoXG5cdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSB7XG5cdFx0XHR2YXIgc3RhdGUgPSBvcHRpb25zID8gb3B0aW9ucy5zdGF0ZSA6IG51bGxcblx0XHRcdHZhciB0aXRsZSA9IG9wdGlvbnMgPyBvcHRpb25zLnRpdGxlIDogbnVsbFxuXHRcdFx0JHdpbmRvdy5vbnBvcHN0YXRlKClcblx0XHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVwbGFjZSkgJHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHJvdXRlci5wcmVmaXggKyBwYXRoKVxuXHRcdFx0ZWxzZSAkd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgcm91dGVyLnByZWZpeCArIHBhdGgpXG5cdFx0fVxuXHRcdGVsc2UgJHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcm91dGVyLnByZWZpeCArIHBhdGhcblx0fVxuXHRyb3V0ZXIuZGVmaW5lUm91dGVzID0gZnVuY3Rpb24ocm91dGVzLCByZXNvbHZlLCByZWplY3QpIHtcblx0XHRmdW5jdGlvbiByZXNvbHZlUm91dGUoKSB7XG5cdFx0XHR2YXIgcGF0aCA9IHJvdXRlci5nZXRQYXRoKClcblx0XHRcdHZhciBwYXJhbXMgPSB7fVxuXHRcdFx0dmFyIHBhdGhuYW1lID0gcGFyc2VQYXRoKHBhdGgsIHBhcmFtcywgcGFyYW1zKVxuXHRcdFx0dmFyIHN0YXRlID0gJHdpbmRvdy5oaXN0b3J5LnN0YXRlXG5cdFx0XHRpZiAoc3RhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKHZhciBrIGluIHN0YXRlKSBwYXJhbXNba10gPSBzdGF0ZVtrXVxuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgcm91dGUwIGluIHJvdXRlcykge1xuXHRcdFx0XHR2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoXCJeXCIgKyByb3V0ZTAucmVwbGFjZSgvOlteXFwvXSs/XFwuezN9L2csIFwiKC4qPylcIikucmVwbGFjZSgvOlteXFwvXSsvZywgXCIoW15cXFxcL10rKVwiKSArIFwiXFwvPyRcIilcblx0XHRcdFx0aWYgKG1hdGNoZXIudGVzdChwYXRobmFtZSkpIHtcblx0XHRcdFx0XHRwYXRobmFtZS5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIGtleXMgPSByb3V0ZTAubWF0Y2goLzpbXlxcL10rL2cpIHx8IFtdXG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEsIC0yKVxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHBhcmFtc1trZXlzW2ldLnJlcGxhY2UoLzp8XFwuL2csIFwiXCIpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZXNbaV0pXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJvdXRlc1tyb3V0ZTBdLCBwYXJhbXMsIHBhdGgsIHJvdXRlMClcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWplY3QocGF0aCwgcGFyYW1zKVxuXHRcdH1cblx0XHRpZiAoc3VwcG9ydHNQdXNoU3RhdGUpICR3aW5kb3cub25wb3BzdGF0ZSA9IGRlYm91bmNlQXN5bmMocmVzb2x2ZVJvdXRlKVxuXHRcdGVsc2UgaWYgKHJvdXRlci5wcmVmaXguY2hhckF0KDApID09PSBcIiNcIikgJHdpbmRvdy5vbmhhc2hjaGFuZ2UgPSByZXNvbHZlUm91dGVcblx0XHRyZXNvbHZlUm91dGUoKVxuXHR9XG5cdHJldHVybiByb3V0ZXJcbn1cbnZhciBfMjAgPSBmdW5jdGlvbigkd2luZG93LCByZWRyYXdTZXJ2aWNlMCkge1xuXHR2YXIgcm91dGVTZXJ2aWNlID0gY29yZVJvdXRlcigkd2luZG93KVxuXHR2YXIgaWRlbnRpdHkgPSBmdW5jdGlvbih2KSB7cmV0dXJuIHZ9XG5cdHZhciByZW5kZXIxLCBjb21wb25lbnQsIGF0dHJzMywgY3VycmVudFBhdGgsIGxhc3RVcGRhdGVcblx0dmFyIHJvdXRlID0gZnVuY3Rpb24ocm9vdCwgZGVmYXVsdFJvdXRlLCByb3V0ZXMpIHtcblx0XHRpZiAocm9vdCA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IHRoYXQgd2FzIHBhc3NlZCB0byBgbS5yb3V0ZWAgaXMgbm90IHVuZGVmaW5lZFwiKVxuXHRcdHZhciBydW4xID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAocmVuZGVyMSAhPSBudWxsKSByZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgcmVuZGVyMShWbm9kZShjb21wb25lbnQsIGF0dHJzMy5rZXksIGF0dHJzMykpKVxuXHRcdH1cblx0XHR2YXIgYmFpbCA9IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdGlmIChwYXRoICE9PSBkZWZhdWx0Um91dGUpIHJvdXRlU2VydmljZS5zZXRQYXRoKGRlZmF1bHRSb3V0ZSwgbnVsbCwge3JlcGxhY2U6IHRydWV9KVxuXHRcdFx0ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSBkZWZhdWx0IHJvdXRlIFwiICsgZGVmYXVsdFJvdXRlKVxuXHRcdH1cblx0XHRyb3V0ZVNlcnZpY2UuZGVmaW5lUm91dGVzKHJvdXRlcywgZnVuY3Rpb24ocGF5bG9hZCwgcGFyYW1zLCBwYXRoKSB7XG5cdFx0XHR2YXIgdXBkYXRlID0gbGFzdFVwZGF0ZSA9IGZ1bmN0aW9uKHJvdXRlUmVzb2x2ZXIsIGNvbXApIHtcblx0XHRcdFx0aWYgKHVwZGF0ZSAhPT0gbGFzdFVwZGF0ZSkgcmV0dXJuXG5cdFx0XHRcdGNvbXBvbmVudCA9IGNvbXAgIT0gbnVsbCAmJiAodHlwZW9mIGNvbXAudmlldyA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBjb21wID09PSBcImZ1bmN0aW9uXCIpPyBjb21wIDogXCJkaXZcIlxuXHRcdFx0XHRhdHRyczMgPSBwYXJhbXMsIGN1cnJlbnRQYXRoID0gcGF0aCwgbGFzdFVwZGF0ZSA9IG51bGxcblx0XHRcdFx0cmVuZGVyMSA9IChyb3V0ZVJlc29sdmVyLnJlbmRlciB8fCBpZGVudGl0eSkuYmluZChyb3V0ZVJlc29sdmVyKVxuXHRcdFx0XHRydW4xKClcblx0XHRcdH1cblx0XHRcdGlmIChwYXlsb2FkLnZpZXcgfHwgdHlwZW9mIHBheWxvYWQgPT09IFwiZnVuY3Rpb25cIikgdXBkYXRlKHt9LCBwYXlsb2FkKVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmIChwYXlsb2FkLm9ubWF0Y2gpIHtcblx0XHRcdFx0XHRQcm9taXNlLnJlc29sdmUocGF5bG9hZC5vbm1hdGNoKHBhcmFtcywgcGF0aCkpLnRoZW4oZnVuY3Rpb24ocmVzb2x2ZWQpIHtcblx0XHRcdFx0XHRcdHVwZGF0ZShwYXlsb2FkLCByZXNvbHZlZClcblx0XHRcdFx0XHR9LCBiYWlsKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgdXBkYXRlKHBheWxvYWQsIFwiZGl2XCIpXG5cdFx0XHR9XG5cdFx0fSwgYmFpbClcblx0XHRyZWRyYXdTZXJ2aWNlMC5zdWJzY3JpYmUocm9vdCwgcnVuMSlcblx0fVxuXHRyb3V0ZS5zZXQgPSBmdW5jdGlvbihwYXRoLCBkYXRhLCBvcHRpb25zKSB7XG5cdFx0aWYgKGxhc3RVcGRhdGUgIT0gbnVsbCkgb3B0aW9ucyA9IHtyZXBsYWNlOiB0cnVlfVxuXHRcdGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0cm91dGVTZXJ2aWNlLnNldFBhdGgocGF0aCwgZGF0YSwgb3B0aW9ucylcblx0fVxuXHRyb3V0ZS5nZXQgPSBmdW5jdGlvbigpIHtyZXR1cm4gY3VycmVudFBhdGh9XG5cdHJvdXRlLnByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeDApIHtyb3V0ZVNlcnZpY2UucHJlZml4ID0gcHJlZml4MH1cblx0cm91dGUubGluayA9IGZ1bmN0aW9uKHZub2RlMSkge1xuXHRcdHZub2RlMS5kb20uc2V0QXR0cmlidXRlKFwiaHJlZlwiLCByb3V0ZVNlcnZpY2UucHJlZml4ICsgdm5vZGUxLmF0dHJzLmhyZWYpXG5cdFx0dm5vZGUxLmRvbS5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSB8fCBlLndoaWNoID09PSAyKSByZXR1cm5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKVxuXHRcdFx0ZS5yZWRyYXcgPSBmYWxzZVxuXHRcdFx0dmFyIGhyZWYgPSB0aGlzLmdldEF0dHJpYnV0ZShcImhyZWZcIilcblx0XHRcdGlmIChocmVmLmluZGV4T2Yocm91dGVTZXJ2aWNlLnByZWZpeCkgPT09IDApIGhyZWYgPSBocmVmLnNsaWNlKHJvdXRlU2VydmljZS5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0cm91dGUuc2V0KGhyZWYsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRyb3V0ZS5wYXJhbSA9IGZ1bmN0aW9uKGtleTMpIHtcblx0XHRpZih0eXBlb2YgYXR0cnMzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBrZXkzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gYXR0cnMzW2tleTNdXG5cdFx0cmV0dXJuIGF0dHJzM1xuXHR9XG5cdHJldHVybiByb3V0ZVxufVxubS5yb3V0ZSA9IF8yMCh3aW5kb3csIHJlZHJhd1NlcnZpY2UpXG5tLndpdGhBdHRyID0gZnVuY3Rpb24oYXR0ck5hbWUsIGNhbGxiYWNrMSwgY29udGV4dCkge1xuXHRyZXR1cm4gZnVuY3Rpb24oZSkge1xuXHRcdGNhbGxiYWNrMS5jYWxsKGNvbnRleHQgfHwgdGhpcywgYXR0ck5hbWUgaW4gZS5jdXJyZW50VGFyZ2V0ID8gZS5jdXJyZW50VGFyZ2V0W2F0dHJOYW1lXSA6IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKVxuXHR9XG59XG52YXIgXzI4ID0gY29yZVJlbmRlcmVyKHdpbmRvdylcbm0ucmVuZGVyID0gXzI4LnJlbmRlclxubS5yZWRyYXcgPSByZWRyYXdTZXJ2aWNlLnJlZHJhd1xubS5yZXF1ZXN0ID0gcmVxdWVzdFNlcnZpY2UucmVxdWVzdFxubS5qc29ucCA9IHJlcXVlc3RTZXJ2aWNlLmpzb25wXG5tLnBhcnNlUXVlcnlTdHJpbmcgPSBwYXJzZVF1ZXJ5U3RyaW5nXG5tLmJ1aWxkUXVlcnlTdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nXG5tLnZlcnNpb24gPSBcIjEuMS4xXCJcbm0udm5vZGUgPSBWbm9kZVxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBtXG5lbHNlIHdpbmRvdy5tID0gbVxufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9taXRocmlsL21pdGhyaWwuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! ../bootstrap/css/bootstrap-theme.min.css */ 4);\n\n__webpack_require__(/*! ../app.css */ 3);\n\n__webpack_require__(/*! ../Ladda/dist/ladda-themeless.min.css */ 2);\n\nvar _mithril = __webpack_require__(/*! mithril */ 5);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app_ddi = __webpack_require__(/*! ../app_ddi.js */ 1);\n\nvar _app_ddi2 = _interopRequireDefault(_app_ddi);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction leftpanel() {\n    return (0, _mithril2.default)(\".sidepanel.container.clearfix[id='leftpanel']\", [(0, _mithril2.default)(\".panelbar[id='toggleLpanelicon']\", (0, _mithril2.default)(\"span\", [_mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\")])), (0, _mithril2.default)(\".panel-heading.text-center[id='leftpaneltitle']\", (0, _mithril2.default)(\"h3.panel-title\", \"Data Selection\")), (0, _mithril2.default)(\".btn-toolbar[role='toolbar']\", {\n        style: {\n            \"margin-left\": \".5em\",\n            \"margin-top\": \".5em\"\n        }\n    }, [(0, _mithril2.default)(\".btn-group\", {\n        style: {\n            \"margin-left\": \"0\"\n        }\n    }, [(0, _mithril2.default)(\"button.btn.active[id='btnVariables'][onclick='tabLeft(\\'tab1\\');'][title='Click variable name to add or remove the variable pebble from the modeling space.'][type='button']\", \"Variables\"), (0, _mithril2.default)(\"button.btn.btn-default[id='btnSubset'][onclick='tabLeft(\\'tab2\\');'][type='button']\", \"Subset\")]), (0, _mithril2.default)(\"button.btn.btn-default.ladda-button[data-spinner-color='#000000'][data-style='zoom-in'][id='btnSelect'][onclick='subsetSelect(\\'btnSelect\\');'][title='Subset data by the intersection of all selected values.'][type='button']\", {\n        style: {\n            \"display\": \"none\",\n            \"float\": \"right\",\n            \"margin-right\": \"10px\"\n        }\n    }, (0, _mithril2.default)(\"span.ladda-label\", {\n        style: {\n            \"pointer-events\": \"none\"\n        }\n    }, \"Select\"))]), (0, _mithril2.default)(\".row-fluid\", (0, _mithril2.default)(\"[id='leftpanelcontent']\", (0, _mithril2.default)(\"[id='leftContentArea']\", {\n        style: {\n            \"overflow\": \"scroll\",\n            \"height\": \"488px\"\n        }\n    }, [(0, _mithril2.default)(\"[id='tab1']\", {\n        style: {\n            \"display\": \"block\",\n            \"padding\": \"6px 12px\",\n            \"text-align\": \"center\"\n        }\n    }), (0, _mithril2.default)(\"[id='tab2']\", {\n        style: {\n            \"display\": \"none\",\n            \"margin-top\": \".5em\"\n        }\n    }), (0, _mithril2.default)(\"[id='tab3']\", (0, _mithril2.default)(\"p\", {\n        style: {\n            \"padding\": \".5em 1em\"\n        }\n    }, \"Select a variable from within the visualization in the center panel to view its summary statistics.\"))])))]);\n}\n\nfunction rightpanel() {\n    return (0, _mithril2.default)(\".sidepanel.container.clearfix[id='rightpanel']\", [(0, _mithril2.default)(\".panelbar[id='toggleRpanelicon']\", (0, _mithril2.default)(\"span\", [_mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\")])), (0, _mithril2.default)(\".panel-heading.text-center[id='rightpaneltitle']\", (0, _mithril2.default)(\"h3.panel-title\", \"Model Selection\")), (0, _mithril2.default)(\".btn-group.btn-group-justified[aria-label='...'][role='group']\", {\n        style: {\n            \"margin-top\": \".5em\"\n        }\n    }, [(0, _mithril2.default)(\"button.btn.active[id='btnModels'][onclick='tabRight(\\'btnModels\\');'][type='button']\", {\n        style: {\n            \"width\": \"33%\"\n        }\n    }, \"Models\"), (0, _mithril2.default)(\"button.btn.btn-default[id='btnSetx'][onclick='tabRight(\\'btnSetx\\');'][type='button']\", {\n        style: {\n            \"width\": \"34%\"\n        }\n    }, \"Set Covar.\"), (0, _mithril2.default)(\"button.btn.btn-default[id='btnResults'][onclick='tabRight(\\'btnResults\\');'][type='button']\", {\n        style: {\n            \"width\": \"33%\"\n        }\n    }, \"Results\")]), (0, _mithril2.default)(\".row-fluid\", (0, _mithril2.default)(\"[id='rightpanelcontent']\", (0, _mithril2.default)(\"[id='rightContentArea']\", {\n        style: {\n            \"overflow\": \"scroll\",\n            \"height\": \"488px\"\n        }\n    }, [(0, _mithril2.default)(\"[id='results']\", {\n        style: {\n            \"margin-top\": \".5em\"\n        }\n    }, [(0, _mithril2.default)(\".container[id='resultsView']\", {\n        style: {\n            \"width\": \"80%\",\n            \"background-color\": \"white\",\n            \"display\": \"none\",\n            \"float\": \"right\",\n            \"overflow\": \"auto\",\n            \"white-space\": \"nowrap\"\n        }\n    }), (0, _mithril2.default)(\"[id='modelView']\", {\n        style: {\n            \"width\": \"20%\",\n            \"background-color\": \"white\",\n            \"display\": \"none\",\n            \"float\": \"left\"\n        }\n    }), (0, _mithril2.default)(\"p[id='resultsHolder']\", {\n        style: {\n            \"padding\": \".5em 1em\"\n        }\n    })]), (0, _mithril2.default)(\"[id='setx']\", {\n        style: {\n            \"display\": \"none\"\n        }\n    }), (0, _mithril2.default)(\"[id='models']\", {\n        style: {\n            \"display\": \"block\",\n            \"padding\": \"6px 12px\",\n            \"text-align\": \"center\"\n        }\n    })])))]);\n}\n\nvar fileid = \"\";\nvar hostname = \"\";\nvar apikey = \"\";\nvar ddiurl = \"\";\nvar dataurl = \"\";\n\nvar Body = function () {\n    function Body() {\n        _classCallCheck(this, Body);\n    }\n\n    _createClass(Body, [{\n        key: 'oncreate',\n        value: function oncreate() {\n            $('#leftpanel span').click(function () {\n                if (!$('#leftpanel').hasClass('forceclosepanel')) {\n                    $('#leftpanel').removeClass('expandpanel');\n                    $('#leftpanel > div.row-fluid').toggleClass('closepanel');\n                    $('#leftpanel').toggleClass('closepanel');\n                    $('#main').toggleClass('svg-leftpanel');\n                    $('#btnSelect').css('display', 'none');\n                }\n            });\n            $('#rightpanel span').click(function () {\n                if (!$('#leftpanel').hasClass('forceclosepanel')) {\n                    $('#rightpanel').removeClass('expandpanel');\n                    $('#rightpanel > div.row-fluid').toggleClass('closepanel');\n                    $('#rightpanel').toggleClass('closepanel');\n                    $('#main').toggleClass('svg-rightpanel');\n                }\n            });\n\n            var myurl = window.location.toString();\n            var cindex = 0;\n            if (myurl.indexOf(\"dfId=\") > 0) {\n                fileid = myurl.substring(myurl.indexOf(\"dfId=\") + 5);\n                cindex = fileid.indexOf(\"&\");\n                if (cindex > 0) {\n                    fileid = fileid.substring(0, cindex);\n                };\n            };\n            if (myurl.indexOf(\"host=\") > 0) {\n                hostname = myurl.substring(myurl.indexOf(\"host=\") + 5);\n                cindex = hostname.indexOf(\"&\");\n                if (cindex > 0) {\n                    hostname = hostname.substring(0, cindex);\n                };\n            };\n            if (myurl.indexOf(\"key=\") > 0) {\n                apikey = myurl.substring(myurl.indexOf(\"key=\") + 4);\n                cindex = apikey.indexOf(\"&\");\n                if (cindex > 0) {\n                    apikey = apikey.substring(0, cindex);\n                };\n            };\n            if (myurl.indexOf(\"ddiurl=\") > 0) {\n                ddiurl = myurl.substring(myurl.indexOf(\"ddiurl=\") + 7);\n                ddiurl = ddiurl.replace(/%25/g, \"%\");\n                ddiurl = ddiurl.replace(/%3A/g, \":\");\n                ddiurl = ddiurl.replace(/%2F/g, \"/\");\n                cindex = ddiurl.indexOf(\"&\");\n                if (cindex > 0) {\n                    ddiurl = ddiurl.substring(0, cindex);\n                };\n            };\n            if (myurl.indexOf(\"dataurl=\") > 0) {\n                dataurl = myurl.substring(myurl.indexOf(\"dataurl=\") + 8);\n                dataurl = dataurl.replace(/%25/g, \"%\");\n                dataurl = dataurl.replace(/%3A/g, \":\");\n                dataurl = dataurl.replace(/%2F/g, \"/\");\n                cindex = dataurl.indexOf(\"&\");\n                if (cindex > 0) {\n                    dataurl = dataurl.substring(0, cindex);\n                };\n            };\n\n            console.log(\"fileid: \" + fileid);\n            console.log(\"hostname: \" + hostname);\n            console.log(\"apikey: \" + apikey);\n            console.log(\"ddiurl: \" + ddiurl);\n            console.log(\"dataurl: \" + dataurl);\n\n            (0, _app_ddi2.default)(fileid, hostname, ddiurl, dataurl);\n        }\n    }, {\n        key: 'view',\n        value: function view() {\n            return (0, _mithril2.default)('main', (0, _mithril2.default)(\"nav.navbar.navbar-default[id='option'][role='navigation']\", (0, _mithril2.default)(\"div\", [(0, _mithril2.default)(\".navbar-header[id='navbarheader']\", [(0, _mithril2.default)(\"img[alt='TwoRavens'][onmouseout='closeabout();'][onmouseover='about();'][src='images/TwoRavens.png'][width='100']\", {\n                style: {\n                    \"margin-left\": \"2em\",\n                    \"margin-top\": \"-0.5em\"\n                }\n            }), (0, _mithril2.default)(\".panel.panel-default[id='about']\", {\n                style: {\n                    \"position\": \"absolute\",\n                    \"left\": \"140px\",\n                    \"width\": \"380px\",\n                    \"display\": \"none\",\n                    \"z-index\": \"50\"\n                }\n            }, (0, _mithril2.default)(\".panel-body\"))]), (0, _mithril2.default)(\".field[id='dataField']\", {\n                style: {\n                    \"text-align\": \"center\",\n                    \"margin-top\": \"0.5em\"\n                }\n            }, [(0, _mithril2.default)(\"h4[id='dataName'][onclick='citetoggle=clickcite(citetoggle);'][onmouseout='closecite(citetoggle);'][onmouseover='opencite();']\", {\n                style: {\n                    \"display\": \"inline\"\n                }\n            }, \"Dataset Name\"), (0, _mithril2.default)(\".panel.panel-default[id='cite']\", {\n                style: {\n                    \"position\": \"absolute\",\n                    \"right\": \"50%\",\n                    \"width\": \"380px\",\n                    \"display\": \"none\",\n                    \"z-index\": \"50\",\n                    \"text-align\": \"left\"\n                }\n            }, (0, _mithril2.default)(\".panel-body\")), (0, _mithril2.default)(\"button.btn.btn-default.ladda-button.navbar-right[data-spinner-color='#000000'][data-style='zoom-in'][id='btnEstimate'][onclick='estimate(\\'btnEstimate\\')']\", {\n                style: {\n                    \"margin-left\": \"2em\",\n                    \"margin-right\": \"1em\"\n                }\n            }, (0, _mithril2.default)(\"span.ladda-label\", \"Estimate\")), (0, _mithril2.default)(\"button.btn.btn-default.navbar-right[id='btnReset'][onclick='reset()'][title='Reset']\", {\n                style: {\n                    \"margin-left\": \"2.0em\"\n                }\n            }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-repeat\", {\n                style: {\n                    \"font-size\": \"1em\",\n                    \"color\": \"#818181\",\n                    \"pointer-events\": \"none\"\n                }\n            })), (0, _mithril2.default)(\".transformTool[id='transformations'][title='Construct transformations of existing variables using valid R syntax. For example, assuming a variable named d, you could enter \\'log(d)\\' or \\'d^2\\'.']\")])])), (0, _mithril2.default)(\".left.svg-leftpanel.svg-rightpanel.carousel.slide[id='main']\", [(0, _mithril2.default)(\".carousel-inner\"), (0, _mithril2.default)(\".spaceTool[id='spacetools']\", {\n                style: {\n                    \"z-index\": \"16\"\n                }\n            }, [(0, _mithril2.default)(\"button.btn.btn-default[id='btnForce'][onclick='forceSwitch()'][title='Pin the variable pebbles to the page.']\", (0, _mithril2.default)(\"span.glyphicon.glyphicon-pushpin\")), (0, _mithril2.default)(\"button.btn.btn-default[id='btnEraser'][onclick='erase()'][title='Wipe all variables from the modeling space.']\", (0, _mithril2.default)(\"span.glyphicon.glyphicon-magnet\"))]), (0, _mithril2.default)(\".legendary.panel.panel-default[id='legend']\", {\n                style: {\n                    \"display\": \"none\"\n                }\n            }, [(0, _mithril2.default)(\".panel-heading\", (0, _mithril2.default)(\"h3.panel-title\", [\"Legend  \", (0, _mithril2.default)(\"span.glyphicon.glyphicon-large.glyphicon-chevron-down.pull-right[data-target='#collapseLegend'][data-toggle='collapse'][href='#collapseLegend'][onclick='$(this).toggleClass(\\'glyphicon-chevron-up\\').toggleClass(\\'glyphicon-chevron-down\\');']\", {\n                style: _defineProperty({\n                    \"cursor\": \"pointer\"\n                }, 'cursor', \"hand\")\n            })])), (0, _mithril2.default)(\".panel-collapse.collapse.in[id='collapseLegend']\", (0, _mithril2.default)(\".panel-body\", [(0, _mithril2.default)(\".clearfix.hide[id='timeButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Time\")]), (0, _mithril2.default)(\".clearfix.hide[id='csButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Cross Sec\")]), (0, _mithril2.default)(\".clearfix.hide[id='dvButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Dep Var\")]), (0, _mithril2.default)(\".clearfix.hide[id='nomButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Nom Var\")])]))]), (0, _mithril2.default)(\".logbox.panel.panel-default[id='logdiv']\", {\n                style: {\n                    \"display\": \"none\"\n                }\n            }, [(0, _mithril2.default)(\".panel-heading\", (0, _mithril2.default)(\"h3.panel-title\", [\"History \", (0, _mithril2.default)(\"span.glyphicon.glyphicon-large.glyphicon-chevron-down.pull-right[data-target='#collapseLog'][data-toggle='collapse'][href='#collapseLog'][id='logicon'][onclick='$(this).toggleClass(\\'glyphicon-chevron-down\\').toggleClass(\\'glyphicon-chevron-up\\');']\", {\n                style: _defineProperty({\n                    \"cursor\": \"pointer\"\n                }, 'cursor', \"hand\")\n            })])), (0, _mithril2.default)(\".panel-collapse.collapse.in[id='collapseLog']\", (0, _mithril2.default)(\".panel-body\"))]), (0, _mithril2.default)(\"[id='ticker']\", {\n                style: {\n                    \"position\": \"fixed\",\n                    \"height\": \"50px\",\n                    \"width\": \"100%\",\n                    \"background\": \"#F9F9F9\",\n                    \"bottom\": \"0\"\n                }\n            }, (0, _mithril2.default)(\"a[href='somelink'][id='logID'][target='_blank']\", \"Replication\")), leftpanel(), rightpanel()]));\n        }\n    }]);\n\n    return Body;\n}();\n\n_mithril2.default.mount(document.body, Body);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvaW5kZXguanM/MWZkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4uL2Jvb3RzdHJhcC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3MnO1xuaW1wb3J0ICcuLi9hcHAuY3NzJztcbmltcG9ydCAnLi4vTGFkZGEvZGlzdC9sYWRkYS10aGVtZWxlc3MubWluLmNzcyc7XG5cbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgbWFpbiBmcm9tICcuLi9hcHBfZGRpLmpzJztcblxuZnVuY3Rpb24gbGVmdHBhbmVsKCkge1xuICAgIHJldHVybiBtKFwiLnNpZGVwYW5lbC5jb250YWluZXIuY2xlYXJmaXhbaWQ9J2xlZnRwYW5lbCddXCIsIFtcbiAgICAgICAgbShcIi5wYW5lbGJhcltpZD0ndG9nZ2xlTHBhbmVsaWNvbiddXCIsXG4gICAgICAgICAgICBtKFwic3BhblwiLCBbXG4gICAgICAgICAgICAgICAgbS50cnVzdChcIiYjOTY3OTtcIiksXG4gICAgICAgICAgICAgICAgbShcImJyXCIpLFxuICAgICAgICAgICAgICAgIG0udHJ1c3QoXCImIzk2Nzk7XCIpLFxuICAgICAgICAgICAgICAgIG0oXCJiclwiKSxcbiAgICAgICAgICAgICAgICBtLnRydXN0KFwiJiM5Njc5O1wiKSxcbiAgICAgICAgICAgICAgICBtKFwiYnJcIiksXG4gICAgICAgICAgICAgICAgbS50cnVzdChcIiYjOTY3OTtcIilcbiAgICAgICAgICAgIF0pXG4gICAgICAgICksXG4gICAgICAgIG0oXCIucGFuZWwtaGVhZGluZy50ZXh0LWNlbnRlcltpZD0nbGVmdHBhbmVsdGl0bGUnXVwiLFxuICAgICAgICAgICAgbShcImgzLnBhbmVsLXRpdGxlXCIsXG4gICAgICAgICAgICAgICAgXCJEYXRhIFNlbGVjdGlvblwiXG4gICAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIG0oXCIuYnRuLXRvb2xiYXJbcm9sZT0ndG9vbGJhciddXCIsIHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBcIi41ZW1cIixcbiAgICAgICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogXCIuNWVtXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW1xuICAgICAgICAgICAgbShcIi5idG4tZ3JvdXBcIiwge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLWxlZnRcIjogXCIwXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbXG4gICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYWN0aXZlW2lkPSdidG5WYXJpYWJsZXMnXVtvbmNsaWNrPSd0YWJMZWZ0KFxcJ3RhYjFcXCcpOyddW3RpdGxlPSdDbGljayB2YXJpYWJsZSBuYW1lIHRvIGFkZCBvciByZW1vdmUgdGhlIHZhcmlhYmxlIHBlYmJsZSBmcm9tIHRoZSBtb2RlbGluZyBzcGFjZS4nXVt0eXBlPSdidXR0b24nXVwiLFxuICAgICAgICAgICAgICAgICAgICBcIlZhcmlhYmxlc1wiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdFtpZD0nYnRuU3Vic2V0J11bb25jbGljaz0ndGFiTGVmdChcXCd0YWIyXFwnKTsnXVt0eXBlPSdidXR0b24nXVwiLFxuICAgICAgICAgICAgICAgICAgICBcIlN1YnNldFwiXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdC5sYWRkYS1idXR0b25bZGF0YS1zcGlubmVyLWNvbG9yPScjMDAwMDAwJ11bZGF0YS1zdHlsZT0nem9vbS1pbiddW2lkPSdidG5TZWxlY3QnXVtvbmNsaWNrPSdzdWJzZXRTZWxlY3QoXFwnYnRuU2VsZWN0XFwnKTsnXVt0aXRsZT0nU3Vic2V0IGRhdGEgYnkgdGhlIGludGVyc2VjdGlvbiBvZiBhbGwgc2VsZWN0ZWQgdmFsdWVzLiddW3R5cGU9J2J1dHRvbiddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxvYXRcIjogXCJyaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tcmlnaHRcIjogXCIxMHB4XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbShcInNwYW4ubGFkZGEtbGFiZWxcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBvaW50ZXItZXZlbnRzXCI6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiU2VsZWN0XCJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgIF0pLFxuICAgICAgICBtKFwiLnJvdy1mbHVpZFwiLFxuICAgICAgICAgICAgbShcIltpZD0nbGVmdHBhbmVsY29udGVudCddXCIsXG4gICAgICAgICAgICAgICAgbShcIltpZD0nbGVmdENvbnRlbnRBcmVhJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJvdmVyZmxvd1wiOiBcInNjcm9sbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCI0ODhweFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXG4gICAgICAgICAgICAgICAgICAgIG0oXCJbaWQ9J3RhYjEnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImJsb2NrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nXCI6IFwiNnB4IDEycHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRleHQtYWxpZ25cIjogXCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbShcIltpZD0ndGFiMiddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLXRvcFwiOiBcIi41ZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCApLFxuICAgICAgICAgICAgICAgICAgICBtKFwiW2lkPSd0YWIzJ11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJwXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZ1wiOiBcIi41ZW0gMWVtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTZWxlY3QgYSB2YXJpYWJsZSBmcm9tIHdpdGhpbiB0aGUgdmlzdWFsaXphdGlvbiBpbiB0aGUgY2VudGVyIHBhbmVsIHRvIHZpZXcgaXRzIHN1bW1hcnkgc3RhdGlzdGljcy5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKVxuICAgIF0pO1xufVxuXG5mdW5jdGlvbiByaWdodHBhbmVsKCkge1xuICAgIHJldHVybiBtKFwiLnNpZGVwYW5lbC5jb250YWluZXIuY2xlYXJmaXhbaWQ9J3JpZ2h0cGFuZWwnXVwiLCBbXG4gICAgICAgIG0oXCIucGFuZWxiYXJbaWQ9J3RvZ2dsZVJwYW5lbGljb24nXVwiLFxuICAgICAgICAgICAgbShcInNwYW5cIiwgW1xuICAgICAgICAgICAgICAgIG0udHJ1c3QoXCImIzk2Nzk7XCIpLFxuICAgICAgICAgICAgICAgIG0oXCJiclwiKSxcbiAgICAgICAgICAgICAgICBtLnRydXN0KFwiJiM5Njc5O1wiKSxcbiAgICAgICAgICAgICAgICBtKFwiYnJcIiksXG4gICAgICAgICAgICAgICAgbS50cnVzdChcIiYjOTY3OTtcIiksXG4gICAgICAgICAgICAgICAgbShcImJyXCIpLFxuICAgICAgICAgICAgICAgIG0udHJ1c3QoXCImIzk2Nzk7XCIpXG4gICAgICAgICAgICBdKVxuICAgICAgICApLFxuICAgICAgICBtKFwiLnBhbmVsLWhlYWRpbmcudGV4dC1jZW50ZXJbaWQ9J3JpZ2h0cGFuZWx0aXRsZSddXCIsXG4gICAgICAgICAgICBtKFwiaDMucGFuZWwtdGl0bGVcIixcbiAgICAgICAgICAgICAgICBcIk1vZGVsIFNlbGVjdGlvblwiXG4gICAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIG0oXCIuYnRuLWdyb3VwLmJ0bi1ncm91cC1qdXN0aWZpZWRbYXJpYS1sYWJlbD0nLi4uJ11bcm9sZT0nZ3JvdXAnXVwiLCB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIFwibWFyZ2luLXRvcFwiOiBcIi41ZW1cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXG4gICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5hY3RpdmVbaWQ9J2J0bk1vZGVscyddW29uY2xpY2s9J3RhYlJpZ2h0KFxcJ2J0bk1vZGVsc1xcJyk7J11bdHlwZT0nYnV0dG9uJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjMzJVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiTW9kZWxzXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdFtpZD0nYnRuU2V0eCddW29uY2xpY2s9J3RhYlJpZ2h0KFxcJ2J0blNldHhcXCcpOyddW3R5cGU9J2J1dHRvbiddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIzNCVcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIlNldCBDb3Zhci5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0W2lkPSdidG5SZXN1bHRzJ11bb25jbGljaz0ndGFiUmlnaHQoXFwnYnRuUmVzdWx0c1xcJyk7J11bdHlwZT0nYnV0dG9uJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjMzJVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiUmVzdWx0c1wiXG4gICAgICAgICAgICApXG4gICAgICAgIF0pLFxuICAgICAgICBtKFwiLnJvdy1mbHVpZFwiLFxuICAgICAgICAgICAgbShcIltpZD0ncmlnaHRwYW5lbGNvbnRlbnQnXVwiLFxuICAgICAgICAgICAgICAgIG0oXCJbaWQ9J3JpZ2h0Q29udGVudEFyZWEnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm92ZXJmbG93XCI6IFwic2Nyb2xsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiBcIjQ4OHB4XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgbShcIltpZD0ncmVzdWx0cyddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tdG9wXCI6IFwiLjVlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIuY29udGFpbmVyW2lkPSdyZXN1bHRzVmlldyddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiODAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbG9hdFwiOiBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3ZlcmZsb3dcIjogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2hpdGUtc3BhY2VcIjogXCJub3dyYXBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcIltpZD0nbW9kZWxWaWV3J11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIyMCVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsb2F0XCI6IFwibGVmdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwicFtpZD0ncmVzdWx0c0hvbGRlciddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmdcIjogXCIuNWVtIDFlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIG0oXCJbaWQ9J3NldHgnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbShcIltpZD0nbW9kZWxzJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJibG9ja1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZ1wiOiBcIjZweCAxMnB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0LWFsaWduXCI6IFwiY2VudGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgKVxuICAgICAgICApXG4gICAgXSk7XG59XG5cbmxldCBmaWxlaWQgPSBcIlwiO1xubGV0IGhvc3RuYW1lID0gXCJcIjtcbmxldCBhcGlrZXkgPSBcIlwiO1xubGV0IGRkaXVybCA9IFwiXCI7XG5sZXQgZGF0YXVybCA9IFwiXCI7XG5cbmNsYXNzIEJvZHkge1xuICAgIG9uY3JlYXRlKCkge1xuICAgICAgICAkKCcjbGVmdHBhbmVsIHNwYW4nKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghJCgnI2xlZnRwYW5lbCcpLmhhc0NsYXNzKCdmb3JjZWNsb3NlcGFuZWwnKSkge1xuICAgICAgICAgICAgICAgICQoJyNsZWZ0cGFuZWwnKS5yZW1vdmVDbGFzcygnZXhwYW5kcGFuZWwnKTtcbiAgICAgICAgICAgICAgICAkKCcjbGVmdHBhbmVsID4gZGl2LnJvdy1mbHVpZCcpLnRvZ2dsZUNsYXNzKCdjbG9zZXBhbmVsJyk7XG4gICAgICAgICAgICAgICAgJCgnI2xlZnRwYW5lbCcpLnRvZ2dsZUNsYXNzKCdjbG9zZXBhbmVsJyk7XG4gICAgICAgICAgICAgICAgJCgnI21haW4nKS50b2dnbGVDbGFzcygnc3ZnLWxlZnRwYW5lbCcpO1xuICAgICAgICAgICAgICAgICQoJyNidG5TZWxlY3QnKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgJCgnI3JpZ2h0cGFuZWwgc3BhbicpLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCEkKCcjbGVmdHBhbmVsJykuaGFzQ2xhc3MoJ2ZvcmNlY2xvc2VwYW5lbCcpKSB7XG4gICAgICAgICAgICAgICAgJCgnI3JpZ2h0cGFuZWwnKS5yZW1vdmVDbGFzcygnZXhwYW5kcGFuZWwnKTtcbiAgICAgICAgICAgICAgICAkKCcjcmlnaHRwYW5lbCA+IGRpdi5yb3ctZmx1aWQnKS50b2dnbGVDbGFzcygnY2xvc2VwYW5lbCcpO1xuICAgICAgICAgICAgICAgICQoJyNyaWdodHBhbmVsJykudG9nZ2xlQ2xhc3MoJ2Nsb3NlcGFuZWwnKTtcbiAgICAgICAgICAgICAgICAkKCcjbWFpbicpLnRvZ2dsZUNsYXNzKCdzdmctcmlnaHRwYW5lbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgbXl1cmwgPSB3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGNpbmRleCA9IDA7XG4gICAgICAgIGlmIChteXVybC5pbmRleE9mKFwiZGZJZD1cIikgPiAwKSB7XG4gICAgICAgICAgICBmaWxlaWQgPSBteXVybC5zdWJzdHJpbmcobXl1cmwuaW5kZXhPZihcImRmSWQ9XCIpICsgNSk7XG4gICAgICAgICAgICBjaW5kZXggPSBmaWxlaWQuaW5kZXhPZihcIiZcIik7XG4gICAgICAgICAgICBpZiAoY2luZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIGZpbGVpZCA9IGZpbGVpZC5zdWJzdHJpbmcoMCwgY2luZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGlmIChteXVybC5pbmRleE9mKFwiaG9zdD1cIikgPiAwKSB7XG4gICAgICAgICAgICBob3N0bmFtZSA9IG15dXJsLnN1YnN0cmluZyhteXVybC5pbmRleE9mKFwiaG9zdD1cIikgKyA1KTtcbiAgICAgICAgICAgIGNpbmRleCA9IGhvc3RuYW1lLmluZGV4T2YoXCImXCIpO1xuICAgICAgICAgICAgaWYgKGNpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBob3N0bmFtZSA9IGhvc3RuYW1lLnN1YnN0cmluZygwLCBjaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG15dXJsLmluZGV4T2YoXCJrZXk9XCIpID4gMCkge1xuICAgICAgICAgICAgYXBpa2V5ID0gbXl1cmwuc3Vic3RyaW5nKG15dXJsLmluZGV4T2YoXCJrZXk9XCIpICsgNCk7XG4gICAgICAgICAgICBjaW5kZXggPSBhcGlrZXkuaW5kZXhPZihcIiZcIik7XG4gICAgICAgICAgICBpZiAoY2luZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIGFwaWtleSA9IGFwaWtleS5zdWJzdHJpbmcoMCwgY2luZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XHRcdFxuICAgICAgICBpZiAobXl1cmwuaW5kZXhPZihcImRkaXVybD1cIikgPiAwKSB7XG4gICAgICAgICAgICBkZGl1cmwgPSBteXVybC5zdWJzdHJpbmcobXl1cmwuaW5kZXhPZihcImRkaXVybD1cIikgKyA3KTtcbiAgICAgICAgICAgIGRkaXVybCA9IGRkaXVybC5yZXBsYWNlKC8lMjUvZywgXCIlXCIpO1xuICAgICAgICAgICAgZGRpdXJsID0gZGRpdXJsLnJlcGxhY2UoLyUzQS9nLCBcIjpcIik7XG4gICAgICAgICAgICBkZGl1cmwgPSBkZGl1cmwucmVwbGFjZSgvJTJGL2csIFwiL1wiKTtcbiAgICAgICAgICAgIGNpbmRleCA9IGRkaXVybC5pbmRleE9mKFwiJlwiKTtcbiAgICAgICAgICAgIGlmIChjaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgZGRpdXJsID0gZGRpdXJsLnN1YnN0cmluZygwLCBjaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcdFx0XG4gICAgICAgIGlmIChteXVybC5pbmRleE9mKFwiZGF0YXVybD1cIikgPiAwKSB7XG4gICAgICAgICAgICBkYXRhdXJsID0gbXl1cmwuc3Vic3RyaW5nKG15dXJsLmluZGV4T2YoXCJkYXRhdXJsPVwiKSArIDgpO1xuICAgICAgICAgICAgZGF0YXVybCA9IGRhdGF1cmwucmVwbGFjZSgvJTI1L2csIFwiJVwiKTtcbiAgICAgICAgICAgIGRhdGF1cmwgPSBkYXRhdXJsLnJlcGxhY2UoLyUzQS9nLCBcIjpcIik7XG4gICAgICAgICAgICBkYXRhdXJsID0gZGF0YXVybC5yZXBsYWNlKC8lMkYvZywgXCIvXCIpO1xuICAgICAgICAgICAgY2luZGV4ID0gZGF0YXVybC5pbmRleE9mKFwiJlwiKTtcbiAgICAgICAgICAgIGlmIChjaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgZGF0YXVybCA9IGRhdGF1cmwuc3Vic3RyaW5nKDAsIGNpbmRleCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiZmlsZWlkOiBcIiArIGZpbGVpZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiaG9zdG5hbWU6IFwiICsgaG9zdG5hbWUpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImFwaWtleTogXCIgKyBhcGlrZXkpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImRkaXVybDogXCIgKyBkZGl1cmwpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImRhdGF1cmw6IFwiICsgZGF0YXVybCk7XG4gICAgXG5cdFx0bWFpbihmaWxlaWQsIGhvc3RuYW1lLCBkZGl1cmwsIGRhdGF1cmwpO1x0XG5cdH1cblxuICAgIHZpZXcoKSB7XG4gICAgICAgIHJldHVybiBtKCdtYWluJyxcbiAgICAgICAgICAgIG0oXCJuYXYubmF2YmFyLm5hdmJhci1kZWZhdWx0W2lkPSdvcHRpb24nXVtyb2xlPSduYXZpZ2F0aW9uJ11cIixcbiAgICAgICAgICAgICAgICBtKFwiZGl2XCIsIFtcbiAgICAgICAgICAgICAgICAgICAgbShcIi5uYXZiYXItaGVhZGVyW2lkPSduYXZiYXJoZWFkZXInXVwiLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiaW1nW2FsdD0nVHdvUmF2ZW5zJ11bb25tb3VzZW91dD0nY2xvc2VhYm91dCgpOyddW29ubW91c2VvdmVyPSdhYm91dCgpOyddW3NyYz0naW1hZ2VzL1R3b1JhdmVucy5wbmcnXVt3aWR0aD0nMTAwJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLWxlZnRcIjogXCIyZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tdG9wXCI6IFwiLTAuNWVtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwucGFuZWwtZGVmYXVsdFtpZD0nYWJvdXQnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGVmdFwiOiBcIjE0MHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMzgwcHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiei1pbmRleFwiOiBcIjUwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC1ib2R5XCIsIClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIG0oXCIuZmllbGRbaWQ9J2RhdGFGaWVsZCddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0LWFsaWduXCI6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tdG9wXCI6IFwiMC41ZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiaDRbaWQ9J2RhdGFOYW1lJ11bb25jbGljaz0nY2l0ZXRvZ2dsZT1jbGlja2NpdGUoY2l0ZXRvZ2dsZSk7J11bb25tb3VzZW91dD0nY2xvc2VjaXRlKGNpdGV0b2dnbGUpOyddW29ubW91c2VvdmVyPSdvcGVuY2l0ZSgpOyddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImlubGluZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRGF0YXNldCBOYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLnBhbmVsLWRlZmF1bHRbaWQ9J2NpdGUnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmlnaHRcIjogXCI1MCVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIzODBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ6LWluZGV4XCI6IFwiNTBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dC1hbGlnblwiOiBcImxlZnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWJvZHlcIiwgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0LmxhZGRhLWJ1dHRvbi5uYXZiYXItcmlnaHRbZGF0YS1zcGlubmVyLWNvbG9yPScjMDAwMDAwJ11bZGF0YS1zdHlsZT0nem9vbS1pbiddW2lkPSdidG5Fc3RpbWF0ZSddW29uY2xpY2s9J2VzdGltYXRlKFxcJ2J0bkVzdGltYXRlXFwnKSddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLWxlZnRcIjogXCIyZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLXJpZ2h0XCI6IFwiMWVtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcInNwYW4ubGFkZGEtbGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJFc3RpbWF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0Lm5hdmJhci1yaWdodFtpZD0nYnRuUmVzZXQnXVtvbmNsaWNrPSdyZXNldCgpJ11bdGl0bGU9J1Jlc2V0J11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBcIjIuMGVtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcInNwYW4uZ2x5cGhpY29uLmdseXBoaWNvbi1yZXBlYXRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250LXNpemVcIjogXCIxZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIjogXCIjODE4MTgxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBvaW50ZXItZXZlbnRzXCI6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIudHJhbnNmb3JtVG9vbFtpZD0ndHJhbnNmb3JtYXRpb25zJ11bdGl0bGU9J0NvbnN0cnVjdCB0cmFuc2Zvcm1hdGlvbnMgb2YgZXhpc3RpbmcgdmFyaWFibGVzIHVzaW5nIHZhbGlkIFIgc3ludGF4LiBGb3IgZXhhbXBsZSwgYXNzdW1pbmcgYSB2YXJpYWJsZSBuYW1lZCBkLCB5b3UgY291bGQgZW50ZXIgXFwnbG9nKGQpXFwnIG9yIFxcJ2ReMlxcJy4nXVwiLCApXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBtKFwiLmxlZnQuc3ZnLWxlZnRwYW5lbC5zdmctcmlnaHRwYW5lbC5jYXJvdXNlbC5zbGlkZVtpZD0nbWFpbiddXCIsIFtcbiAgICAgICAgICAgICAgICBtKFwiLmNhcm91c2VsLWlubmVyXCIsICksXG4gICAgICAgICAgICAgICAgbShcIi5zcGFjZVRvb2xbaWQ9J3NwYWNldG9vbHMnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInotaW5kZXhcIjogXCIxNlwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXG4gICAgICAgICAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0W2lkPSdidG5Gb3JjZSddW29uY2xpY2s9J2ZvcmNlU3dpdGNoKCknXVt0aXRsZT0nUGluIHRoZSB2YXJpYWJsZSBwZWJibGVzIHRvIHRoZSBwYWdlLiddXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwic3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLXB1c2hwaW5cIilcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHRbaWQ9J2J0bkVyYXNlciddW29uY2xpY2s9J2VyYXNlKCknXVt0aXRsZT0nV2lwZSBhbGwgdmFyaWFibGVzIGZyb20gdGhlIG1vZGVsaW5nIHNwYWNlLiddXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwic3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLW1hZ25ldFwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgbShcIi5sZWdlbmRhcnkucGFuZWwucGFuZWwtZGVmYXVsdFtpZD0nbGVnZW5kJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXG4gICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwtaGVhZGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcImgzLnBhbmVsLXRpdGxlXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkxlZ2VuZCAgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcInNwYW4uZ2x5cGhpY29uLmdseXBoaWNvbi1sYXJnZS5nbHlwaGljb24tY2hldnJvbi1kb3duLnB1bGwtcmlnaHRbZGF0YS10YXJnZXQ9JyNjb2xsYXBzZUxlZ2VuZCddW2RhdGEtdG9nZ2xlPSdjb2xsYXBzZSddW2hyZWY9JyNjb2xsYXBzZUxlZ2VuZCddW29uY2xpY2s9JyQodGhpcykudG9nZ2xlQ2xhc3MoXFwnZ2x5cGhpY29uLWNoZXZyb24tdXBcXCcpLnRvZ2dsZUNsYXNzKFxcJ2dseXBoaWNvbi1jaGV2cm9uLWRvd25cXCcpOyddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY3Vyc29yXCI6IFwicG9pbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjdXJzb3JcIjogXCJoYW5kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWNvbGxhcHNlLmNvbGxhcHNlLmluW2lkPSdjb2xsYXBzZUxlZ2VuZCddXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWJvZHlcIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIuY2xlYXJmaXguaGlkZVtpZD0ndGltZUJ1dHRvbiddXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0Q29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzdmdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjIwcHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IFwiMjBweFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJjaXJjbGVbY3g9JzEwJ11bY3k9JzEwJ11bZmlsbD0nd2hpdGUnXVtyPSc5J11bc3Ryb2tlPSdibGFjayddW3N0cm9rZS13aWR0aD0nMiddXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucmVjdExhYmVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRpbWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5jbGVhcmZpeC5oaWRlW2lkPSdjc0J1dHRvbiddXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0Q29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzdmdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjIwcHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IFwiMjBweFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJjaXJjbGVbY3g9JzEwJ11bY3k9JzEwJ11bZmlsbD0nd2hpdGUnXVtyPSc5J11bc3Ryb2tlPSdibGFjayddW3N0cm9rZS13aWR0aD0nMiddXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucmVjdExhYmVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNyb3NzIFNlY1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLmNsZWFyZml4LmhpZGVbaWQ9J2R2QnV0dG9uJ11cIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RDb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcInN2Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMjBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCIyMHB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcImNpcmNsZVtjeD0nMTAnXVtjeT0nMTAnXVtmaWxsPSd3aGl0ZSddW3I9JzknXVtzdHJva2U9J2JsYWNrJ11bc3Ryb2tlLXdpZHRoPScyJ11cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0TGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRGVwIFZhclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLmNsZWFyZml4LmhpZGVbaWQ9J25vbUJ1dHRvbiddXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0Q29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzdmdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjIwcHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IFwiMjBweFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJjaXJjbGVbY3g9JzEwJ11bY3k9JzEwJ11bZmlsbD0nd2hpdGUnXVtyPSc5J11bc3Ryb2tlPSdibGFjayddW3N0cm9rZS13aWR0aD0nMiddXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucmVjdExhYmVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk5vbSBWYXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBtKFwiLmxvZ2JveC5wYW5lbC5wYW5lbC1kZWZhdWx0W2lkPSdsb2dkaXYnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC1oZWFkaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiaDMucGFuZWwtdGl0bGVcIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSGlzdG9yeSBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwic3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLWxhcmdlLmdseXBoaWNvbi1jaGV2cm9uLWRvd24ucHVsbC1yaWdodFtkYXRhLXRhcmdldD0nI2NvbGxhcHNlTG9nJ11bZGF0YS10b2dnbGU9J2NvbGxhcHNlJ11baHJlZj0nI2NvbGxhcHNlTG9nJ11baWQ9J2xvZ2ljb24nXVtvbmNsaWNrPSckKHRoaXMpLnRvZ2dsZUNsYXNzKFxcJ2dseXBoaWNvbi1jaGV2cm9uLWRvd25cXCcpLnRvZ2dsZUNsYXNzKFxcJ2dseXBoaWNvbi1jaGV2cm9uLXVwXFwnKTsnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImN1cnNvclwiOiBcInBvaW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY3Vyc29yXCI6IFwiaGFuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC1jb2xsYXBzZS5jb2xsYXBzZS5pbltpZD0nY29sbGFwc2VMb2cnXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC1ib2R5XCIsIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIG0oXCJbaWQ9J3RpY2tlciddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwb3NpdGlvblwiOiBcImZpeGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCI1MHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmRcIjogXCIjRjlGOUY5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJib3R0b21cIjogXCIwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbShcImFbaHJlZj0nc29tZWxpbmsnXVtpZD0nbG9nSUQnXVt0YXJnZXQ9J19ibGFuayddXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlJlcGxpY2F0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbGVmdHBhbmVsKCksXG4gICAgICAgICAgICAgICAgcmlnaHRwYW5lbCgpXG4gICAgICAgICAgICBdKVxuICAgICAgICApO1xuICAgIH1cbn1cblxubS5tb3VudChkb2N1bWVudC5ib2R5LCBCb2R5KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvaW5kZXguanMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFDQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFPQTtBQUNBO0FBREE7QUFEQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQVFBO0FBQ0E7QUFEQTtBQURBO0FBWUE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQVFBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFRQTtBQUNBO0FBREE7QUFEQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBa0JBO0FBQ0E7QUFEQTtBQURBO0FBTUE7QUFDQTtBQURBO0FBREE7QUFRQTtBQUNBO0FBREE7QUFEQTtBQVFBO0FBQ0E7QUFEQTtBQURBO0FBV0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBQ0E7QUFEQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQURBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBREE7QUFTQTtBQUNBO0FBREE7QUFEQTtBQU9BO0FBQ0E7QUFEQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQURBO0FBYUE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBQ0E7QUFEQTtBQURBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQURBO0FBYUE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQVdBO0FBQ0E7QUFEQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBZUE7QUFDQTtBQURBO0FBREE7QUFhQTtBQUNBO0FBREE7QUFEQTtBQVNBO0FBQ0E7QUFEQTtBQURBO0FBYUE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQWdCQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBZ0JBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFnQkE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQWlCQTtBQUNBO0FBREE7QUFEQTtBQVNBO0FBQ0E7QUFEQTtBQURBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFEQTtBQWlCQTs7Ozs7O0FBR0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 7 */
/* unknown exports provided */
/* all exports used */
/*!******************************!*\
  !*** ./~/process/browser.js ***!
  \******************************/
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzPzgyZTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 8 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ./~/setimmediate/setImmediate.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 0), __webpack_require__(/*! ./../process/browser.js */ 7)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz80YTgwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 9 */
/* unknown exports provided */
/* all exports used */
/*!*************************************!*\
  !*** ./~/timers-browserify/main.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ 8);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz9iMDg4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ]);